<!DOCTYPE html>
<html lang="de">
     <head>
         <meta charset="utf-8"/>
         <title>Project Cars DS - live view with position update.</title>
         
         <script src="https://maps.google.com/maps/api/js??v=3.exp&sensor=true"></script>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.3.3/d3.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/js-url/1.8.6/url.min.js"></script>
 
 	 <script src="./config.js" charset="utf-8"></script>
	 <script src="./pcars_driver.js" charset="utf-8"></script>
	 <script src="./pcars_track.js" charset="utf-8"></script>
	 <script src="./pcars_vehicle.js" charset="utf-8"></script>
	 <script src="./receive_ds_data.js" charset="utf-8"></script>
	 <script src="./calc_coordinates.js" charset="utf-8"></script>
	 <script src="./class_reference_points.js" charset="utf-8"></script>
	 <script src="./get_url_param.js" charset="utf-8"></script>
	 <script src="./css_classchanger.js" charset="utf-8"></script>
	 <script src="./demo_data.js" charset="utf-8"></script>

	<!--Ermoeglicht das verschieben von DIV Bloecken -->
	<!-- Jquery UI needed for jTable-->
        <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
        <script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
        <script>
                $(function() {
					$( "#DSdata" ).draggable();
					$( "#TrackList" ) .draggable();
					$( "#CarList" ) .draggable();
					$( "#DriverDataArea" ) .draggable();
					$( "#Settings" ) .draggable();
                });
		
		$(function() {
            		$( "#DSdata" ).resizable({
//             			animate: true
						ghost: true
            		});
//		        $( "#tracklisttable" ).resizable({
//               			ghost: true
//            		});
         	});
	
        </script>

	<!-- The jqGrid language file code-->
        <link rel="stylesheet" type="text/css" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/css/ui.jqgrid.css">
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/i18n/grid.locale-de.js"></script>
        <!-- The atual jqGrid code -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/jquery.jqGrid.src.js"></script>


        <!-- CSS definitions--> 
        <style type="text/css">

		html, body, #map {
                 width: 100%;
                 height: 100%;
                 margin: 0;
                 padding: 0;
		}
        
	     #DSdata{
				position: 	absolute; 
				left: 		55%; 
				top: 		0px; 
				width: 		300px; 
				height: 	200px;
				border:		1;
				background:	lightgreen;
	     }

	     #TrackList{
				position:       absolute;
                left:           5%;
                top:            30px;
                border:         1;
				text-align: 	center;
	     }
	     #TrackList .ui-jqgrid-bdiv{
				max-height: 400px;
				overflow-x: hidden;
				word-wrap: break-word; /* IE 5.5+ and CSS3 */
    			white-space: pre-wrap; /* CSS3 */
    			white-space: -pre-wrap; /* Opera 4-6 */
    			white-space: -o-pre-wrap; /* Opera 7 */
    			white-space: normal !important;
		 }
	     
	     #CarList{
				position:       absolute;
                left:           5%;
                top:            60px;
                border:         1;
				text-align: 	center;
	     }
	     #CarList .ui-jqgrid-bdiv{
				max-height: 400px;
				overflow-x: hidden;
				word-wrap: break-word; /* IE 5.5+ and CSS3 */
    			white-space: pre-wrap; /* CSS3 */
    			white-space: -pre-wrap; /* Opera 4-6 */
    			white-space: -o-pre-wrap; /* Opera 7 */
    			white-space: normal !important;
		 }

	     #DriverData{
				position:       absolute;
                left:           55%;
				top:			250px;
	     }
	     #DriverData .ui-jqgrid-bdiv{
				max-height: 400px;
				overflow-x: hidden;
				word-wrap: break-word; /* IE 5.5+ and CSS3 */
    			white-space: pre-wrap; /* CSS3 */
    			white-space: -pre-wrap; /* Opera 4-6 */
    			white-space: -o-pre-wrap; /* Opera 7 */
    			white-space: normal !important;
		 }
		
	     #DriverDataArea{
				position:       absolute;
				left:           5%;
				top:            0px;
				background:	lightgrey
	     }
	    	         
	     #hide or unhide objects
	     starthidden {
   				 display: none;
  		}

	     #Settings{
		position:       absolute;
                left:           75%;
                top:            25px;
                background:     lightgrey
	     }

		
		.stations, .stations svg {
			position: absolute;
		}

		.stations svg {
			width: 60px;
			height: 20px;
			padding-right: 100px;
			font: 10px sans-serif;
		}

		.stations circle {
			fill: blue;
			stroke: black;
			stroke-width: 1.5px;
		}
             
		.tableoption {
			background:     lightgrey;
		}
		
        </style>
     </head>
   <body>

	<!-- definition of data areas, the order of the tables decides which one is in foreground and which in background-->
	<div id="map"></div>
	<div id="DSdata">
		<p0>-</p0><br><p1></p1><br><p2></p2><br><p3></p3><br><p4></p4><br><p7></p7><br><p8></p8><br><p9></p9><br>----- Settings ----<br><p5></p5><br><p6></p6>
		<div id="DSdataInformation"></div>
		<div id="DSdataSettings"></div>
	</div>
	<div id="CarList">
		<table id="carlisttable"></table>
	</div>
	<div id="TrackList">
		<table id="tracklisttable"></table>
		<div id="pager_tracklisttable"></div>
	</div>
	<div id="DriverDataArea">
		<table id="DriverDataTable"></table>
	</div>

	<!-- definition of option panel-->	
	<div id="Settings">
		Settings: <br>

		<!-- API dropdown -->
		<form action="#">
		  <fieldset id="fieldset">
			<label for="APIMODE">Select API Type</label>
	    	<select class="APIMODE" name="APIMODE" id="APIMODE">
	      		<option>DS</option>
	      		<option>CREST</option>
	      		<option>DEMO</option>
			</select>
		</fieldset>
		</form>
		
		<label for="DRIVERCOLOR">color driver objects</label>
		<select class="DRIVERCOLOR" name="DRIVERCOLOR" id="DRIVERCOLOR">
	    	<option></option>
	    	<option value="hidedrivers">hide-drivers</option>
	    	<option value="unhidedrivers">unhide-drivers</option>
	    	<option value="colortop3">Top 3 vehicles</option>
	    	<option value="deletecssclasses">reset CSS Classes</option>
		</select>
	
		<br>----<br>
  			<label for="amount">WORKERDELAY_DSDATA:</label>
			<input type="text" id="workerdelay_dsdata" readonly style="border:0;">
			<div id="slider-workerdelay_dsdata"></div>			
		<br>----<br>
		<p>
  			<label for="amount">DisplayDurationCorrector:</label>
			<input type="text" id="amount" readonly style="border:0;">
		</p>
		<!-- Slider Duration -->
		<div id="slider-range-max"></div>
		
	</div>

       <script>
	// initialize vars
	var aDrivers 			= new Array();		// array for PCARSdriver objects
	var aSensorData 		= new Array();		// array of Hashes, each hash includes parameters of a driver
	var XMLHTTPTimeout		= 2000;
	var StopTransitionDelay = "true";	// if set to true, DisplayDuration set to 0 ( cases: zoom, mapchange )
	var StopTransitionDelay_StartTime = Date.now();	//timestamp for StopTransitionDelay is set to "true"
	var global_i			= 0;
	var map;				// google map object
	var sensorLayer;
	var sensorLayer_UpdateTime;		//time, when marker are updated
	var sensorLayer_UpdateTime_old;		//time of the recent dsdata-worker run, when the marker were updated
	var sensorLayer_UpdateDelta;		//time between recent and current dsdata-worker run, when the marker were updated
	var UnHide                      = "false";	//UnHide markers
	var UnHide_Timer                = 0;		//Timer for UnHide markers
	var DisplayDurationCorrector = 0;
	var aRefPointTMP			= 	new Refpoint("-1");		// hash of all RefPoints for available tracks
	var aVehicleList			=	new Array();			// array of pcars_vehicle.js objects
	var aVehicleIdToName		=	new Array();			// hash to translate vehicleID to VehicleName
	var StopRefreshTracklist	=	"false";
	var StopRefreshDriverlist	=	"false";
	var SessionState		=       "";
	var SessionState_old		=       "";
	var SessionStage		=	"";
	var SessionStage_old		=	"";
	//var APIMODE				=	"DS";   // possible values DS,CREST,DEMO
	
	var PCARSd					=	new PCARSdriver(); // only use the object to get functions of it
	var CSSClassChanger			=	new CSSClassChanger(CSSDEFINITIONS);	// CSS defined in config.js	

	PCARSd.SetExampleData();
	
	var recording_count = 0;        //used as array index comment during recording demo data
	var record_pos;			//used for playback of data during DEMO mode
	var record_pos_helper;          //for WORKERDELAY_DEMODATA calculation needed
	
	var sensorLayer_UpdateDelta_DEMOdiff;	//Difference between sensorLayer_UpdateDelta of the recorded data and the playback
	var WORKERDELAY_DEMODATA = WORKERDELAY_DSDATA;	//Worker delay for DEMO mode to adapt the playback speed to the recording

	// set to global var, to modify in future stage for periodical updates via ajax
	var DsName			=	"-+-"; // aDsData.name;
	var DsState			=	"-+-"; //aDsData.state;		//idle/running
	var DsTrackName		=	"Slightly Mad Studios Ltd";		//aTrackList[aDsData.TrackId];
	var DsMaxMemberCnt	=	"-+-"; //aDsData.max_member_count;
	var cuircitID		=	9999999999;		//aDsData.TrackId;
	
	var CSVExport = {	//CSV Export Data
		Practice1:	"",
		Practice2:	"",
		Qualifying:	"",
		Warmup:		"",
		Race1:		"",
		Race2:		""
	}
	
	/* aSensorData init was only necessary as the draw function call was disabled, but the commands of the draw function were not moved to the update function
	var GPSinit                         = calc_coordinates (9999999999 , PCARSd.GetPosX() , PCARSd.GetPosZ() , aRefPointTMP);
        aSensorData[0] = {
		"Key":			PCARSd.GetName()
		,"MarkerLabel" :	PCARSd.GetRacePosition() + "-" + PCARSd.GetName()
		,"DateTime":		"2013-09-04T09:41:09+10:00"
		,"Lat":			GPSinit["Lat"]
		,"Long":		GPSinit["Long"]
		,"Heading":		286.0
		,"Speed":		PCARSd.GetSpeed()
		,"CSSTextClasses":	PCARSd.GetCSSTextClass()
		,"CSSCircleClasses":	PCARSd.GetCSSCircleClass()
        }*/

	// catch demo array boundary breaks
	if(demo_start_pos > demo.length-1 || demo_start_pos < 0){
		demo_start_pos = 0;
	}
	record_pos = demo_start_pos;
	if(demo_end_pos < 0){
		demo_end_pos = 0;
	}
								
	// hide or unhide objects defined within config.js
	if ( SHOWTRACKLIST 	== false ) { 	$( "#TrackList" ).hide();			}
	if ( SHOWDSDATA 	== false ) { 	$( "#DSdata" ).hide();				}						
	if ( SHOWDRIVERDATA	== false ) { 	$( "#DriverDataArea" ).hide();		}
	if ( SHOWSETTINGS	== false ) { 	$( "#Settings" ).hide();			}
	if ( SHOWCARLIST	== false ) { 	$( "#CarList" ).hide();			}
	
	//set dropdown menu APIMODE
	switch(APIMODE) {
		case "DS":
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DS";
			break;
		case "CREST":
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "CREST";
			break;
		case "DEMO":
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DEMO";
			break;
		default:
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DS";
	}
								
	// check if url params overwrite the default ds info
	if (get_url_param('dsurl') && get_url_param('dsport'))
        {
			DsServerURL     =       get_url_param('dsurl');
			DsPort          =       get_url_param('dsport');
			APIMODE         =       "DS";
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DS";

			if(log >= 3){
				console.log("overwrite ds default settings with: " 
					+ get_url_param('dsurl') 
					+ " / " 
					+ get_url_param('dsport'));
			}
	}
	
	// check if url params overwrite the default CREST info
	if (get_url_param('cresturl') && get_url_param('crestport'))
	{
		CRESTServerURL		=	get_url_param('cresturl');
		CRESTPort		=	get_url_param('crestport');
		APIMODE			=	"CREST";
		DisplayDuration		=	DisplayDurationCREST;
		document.getElementById("fieldset").elements.namedItem("APIMODE").value = "CREST";
		
		if(log >= 3){
			console.log("overwrite crest default settings with: " 
				+ get_url_param('cresturl') 
				+ " / " 
				+ get_url_param('crestport'));
		}
	}


	/////////////////////////////////////
	// Event Handler
	// Dropdown API
	$("#APIMODE").change(function() {
			$("#APIMODE option:selected").each(function() {
					APIMODE = $( this ).text();
			});			
	}); // end #APIMODE change event
	
	$( "#DRIVERCOLOR" ).change(function() {
        $("#DRIVERCOLOR option:selected").each(function() {
        	var str1 = $( this ).val();
	        switch ( str1 ) {
	        
	        	case "hidedrivers":
	        		CSSClassChanger.HideAllSvg();
	        		break;
	        		
	        	case "unhidedrivers":
		        	CSSClassChanger.UnHideAllSvg();
	        		break;
	        	
	        	case "colortop3":
	        		CSSClassChanger.ColorTop3vehicles();
		    		break;
		    		
	        	case "deletecssclasses":
	        		CSSClassChanger.ClearAllCssClases();
	        		break;
	        		
	    	    default:
	        		CSSClassChanger.ClearAllCssClases();
	    			break;
	        }
        });            
	}); // end #DRIVERCOLOR change Venet

	
	
	// Event handler for Slider
	$(function() {
		$( "#slider-range-max" ).slider({
			range: "max",
			min: -1000,
			max: 1000,
      			value: DisplayDurationCorrector, 
			step: 25,
      			slide: function( event, ui ) {
        			$( "#amount" ).val( ui.value );
				//set new value
				DisplayDurationCorrector = ui.value;
      			}
    		});
    		$( "#amount" ).val( $( "#slider-range-max" ).slider( "value" ) );
  	});
	
	
	$(function() {
		$( "#slider-workerdelay_dsdata" ).slider({
			range: "max",
			min:	0,
			max:	1500,
      		value:	WORKERDELAY_DSDATA, 
			step:	50,
			slide:	function( event, ui ) {
						$( "#workerdelay_dsdata" ).val( ui.value );
						//set new value
						WORKERDELAY_DSDATA = ui.value;
      			}
    		});
    		$( "#workerdelay_dsdata" ).val( $( "#slider-workerdelay_dsdata" ).slider( "value" ) );
  	});

	// initiate jqGrid for DriverData
	// todo: make table searchable   and  add new Theme
	// todo: add subgrid information like: Long,Lat,RefPoint,...
	jQuery("#tracklisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        width:	790,
	        hiddengrid: true,
	        colNames:['ID','TrackID','TrackName','Max Gridsize', 'RefPoints exists?','Comment'],
	        colModel:[
					{name:'id', index:'id', formatter: 'integer', width:45, sorttype:"int"},
					{name:'trackid', index:'trackid', width:80, sorttype:"int"},
					{name:'trackname', index: 'trackname', width:240, sorttype:"text"},
					{name:'gridsize', width:50, align:"center", sorttype:"text"},
					{name:'refpoint', width:70, align:"center", sorttype:"text"},
					{name:'comment', width:250, align:"left", sorttype:"text"},
	        ],
		caption: "List of available Tracks",
		rowNum: 200,
		//rowList:[10,20,30],
		//pager: 'pager_tracklisttable',
	});
			
	// add filter option bar
	jQuery("#tracklisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });

	// initial data for grid !!! Needed because of Refresh problem !!
	// todo: really needed ?
	jQuery("#tracklisttable").jqGrid('addRowData',0,{	
								id: 		0
								,trackid:	"2" 
								,trackname:	"initialdata2"
								,gridsize:	"-"
								,refpoint:	"no"
								,comment:	"test comment" 
							});
	
	// add StopRefresh Table button in jqgrid header
	//Method with checkbox
	//$('#TrackList span.ui-jqgrid-title').after(' | Stop refresh table:<input type="checkbox" id="cbTracklistRefresh"/>');
	//Method with Button
	jQuery('#tracklisttable').setCaption('List of available Tracks&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Stop automatic refresh of table" id="cbTracklistRefresh" value="Stop" style="background-color:#dddddd"></input>');


	// car lis overview
	jQuery("#carlisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        hiddengrid: true,
	        colNames:['ID','CarName','class','Set1', 'Set2','Comment'],
	        colModel:[
					{name:'vehicleid', 	width:100, 	sorttype:"float",align:"left", index:'id', formatter: 'float'},
					{name:'name', 		width:100, 	sorttype:"text"},
					{name:'cls',  		width:200, 	sorttype:"text"},
					{name:'set1', 		width:40, 	sorttype:"text", align:"right"},
					{name:'set2', 		width:90, 	sorttype:"text", align:"center"},
					{name:'comment', 	width:160, 	sorttype:"text", align:"left"},
	        ],
	        caption: "List of available Cars with properties.",
		rowNum: 200,
	});
	// add filter option bar
	jQuery("#carlisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create worker to get vehicle list
	var workerVEHICLELIST      =       new Worker('./worker_vehiclelist.js');
	
	workerVEHICLELIST.addEventListener('message', function(e) {
		
		if(log >= 3){console.log('+++++++++++ GETVEHICLELIST Worker returned: e ', e );}
		if ( e.data.avehiclelist.length > 0 ){
			
			aVehicleList	=	e.data.avehiclelist;	//copy the array of vehicle objects to global var
			
			aVehicleIdToName = transformVehicleObjectToHash(aVehicleList);
		
			//display vehicle data in table 
			refreshVehicleList(aVehicleList);
			
			// no additional worker call needed, because needed data available			
			if(log >= 3){console.log('+++++++++++ GETVEHICLELIST Worker stopped and copy data to aVehicleList', aVehicleList );}
			
			
			
		}else{
			
			// no return value from DS, start another run
			if(log >= 3){console.log('+++++++++++ GETVEHICLELIST start new Worker run.' );}
			workerVEHICLELIST.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETVEHICLELIST", arefpoint: aRefPointTMP});
		}
		
	}, false);
	workerVEHICLELIST.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETVEHICLELIST", arefpoint: aRefPointTMP});
	

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create DS data object
	var workerDSDATA      =       new Worker('./worker_dsdata.js');
	sensorLayer_UpdateTime_old = Date.now();	//initialize a value for first time
	//event handler of the worker
	workerDSDATA.addEventListener('message', function(e) {
		
		if(log >= 3){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: ', e);}
                
                SessionState = e.data.globals.attributes.SessionState;
		SessionStage = e.data.globals.attributes.SessionStage;
                
		// write in HTML page for DS status
		document.getElementsByTagName('p0')[0].innerHTML = 'DS URL:   		' + DsServerURL + " : " +  DsPort; 
		document.getElementsByTagName('p1')[0].innerHTML = 'DS Status:   	' + e.data.globals.state;
		document.getElementsByTagName('p2')[0].innerHTML = 'DS Joinable: 	' + e.data.globals.joinable;
		document.getElementsByTagName('p3')[0].innerHTML = 'DS Lobby ID: 	' + e.data.globals.lobbyid;
		document.getElementsByTagName('p4')[0].innerHTML = 'DS now:      	' + e.data.globals.now; 
		document.getElementsByTagName('p5')[0].innerHTML = 'used API type:	' + APIMODE;
		document.getElementsByTagName('p6')[0].innerHTML = 'Display Duration:      ' + DisplayDuration;
		document.getElementsByTagName('p7')[0].innerHTML = 'TrackName:     	' + e.data.arefpoint[e.data.globals.attributes.TrackId]["Name"];		
		document.getElementsByTagName('p8')[0].innerHTML = 'SessionStage:   ' + SessionStage;
		document.getElementsByTagName('p9')[0].innerHTML = 'SessionState:   ' + SessionState;
		
		var resttime = ConvertLaptimeInReadbaleFormat((e.data.globals.attributes.SessionTimeDuration-e.data.globals.attributes.SessionTimeElapsed)*1000);	//Times in seconds, but function need it in milliseconds, multiplied by 1000
		if (SessionState == "Race"){
			document.getElementById("txtSessionStage").value = ' ' + e.data.globals.attributes.SessionStage + ': ' + resttime.slice(0,-4);;	//slice for deleting the milliseconds part of the time
		}else{
			document.getElementById("txtSessionStage").value = '  ----  ';
		}
		
		//todo:  replace document.get... by Jquery functionality
		//$('#DSdataInformation').append( 
		//				$("<p0>").text("DS URL2: " + DsServerURL + " : " +  DsPort)
		//);
		
		//Reset CSVs on a new Race Weekend
		if (SessionState_old != "Loading" && SessionState == "Loading"){
			for (var key in CSVExport) {
				CSVExport[key] = "";
			}
		}

		// Build CSVs - must be done before refreshDriverList updates the table, because we need the data of the last worker run of a SessionStage and the if statements match on the first worker run of the following SessionStage
		//TODO: search for better implementation
		//after Practice1
		if (SessionState_old != "Lobby" && SessionStage_old == "Practice1" && SessionStage != "Practice1"){     //During SessionState Lobby the SessionStage is Practice1
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");	//sort grid for the case that the user changed the sorting
			CSVExport.Practice1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Practice 1 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
		}
		//after Practice2
		if (SessionStage_old == "Practice2" && SessionStage != "Practice2"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Practice2 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Practice 2 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
		}
		//after Qualifying
		if (SessionStage_old == "Qualifying" && SessionStage != "Qualifying"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Qualifying = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Qualifying Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
		}
		//after Warmup
		if (SessionStage_old == "Warmup" && SessionStage != "Warmup"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Warmup = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Warmup Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
		}
		//after Race1 if there is a Race2
		if (SessionStage_old == "Race1" && SessionStage != "Race1" && SessionState == "Race"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Race1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race 1 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
		}
		//after Race Weekend finished
		if (SessionState_old != "PostRace" && SessionState == "PostRace"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			if (SessionStage_old == "Race1"){       //matches if Race1 is the only race
				CSVExport.Race1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
			}
			if (SessionStage_old == "Race2"){
				CSVExport.Race2 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race 2 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]);
			}
			//Auto Export
			if (autoExport == "true"){
				var CSVall = "";
				for (var key in CSVExport) {
					if(CSVExport[key] != ""){
						CSVall += CSVExport[key] + '\r\n\n';
					}
				}
				ExportCSV(CSVall,"Results");
			}
		}

		if(log >= 3){console.log("SessionState: ", SessionState, " , CSV Oject", CSVExport)};
		
		/////////////////////////////////////////// update driver data /////////////////////
		// refresh table of Driver data
        refreshDriverList(e.data.driverlist);
		
		//todo var declaration needed within loop ???
		var tmpcuircitID;
		tmpcuircitID = e.data.globals.attributes.TrackId;
		if(log >= 3){console.log("tmpcuircitID worker: ", tmpcuircitID);}

		if (SessionState_old != "Loading" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}  //Hide markers on Loading / before calculation, unhide is after calculation.
                //if (SessionState_old == "Lobby" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}    //Hide markers before calculation, unhide is after calculation.
                //if (SessionState_old == "" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}         //Hide if you open the website during "Loading"
		//if (SessionState_old == "NA" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}       //Hide if you switch receivemodes, because the default SessionState = "NA"
		
		if (SessionStage_old != SessionStage){
			StopTransitionDelay = "true";
			StopTransitionDelay_StartTime = Date.now();
			sensorLayer.interruptTransition();
		}
		
		//update map
		for (var i = 0; i < e.data.driverlist.length; i++ ){

				//calculate GPS coordinates
				gpsCoTmp =  calc_coordinates (cuircitID , e.data.driverlist[i].PosX , e.data.driverlist[i].PosZ , e.data.arefpoint);

				if(log >= 3){console.log('+++++++++++ DriverData Array  ', e.data.driverlist);}
				
				//cast object type because losing while webworker transfer
				e.data.driverlist[i].__proto__ = PCARSdriver.prototype;
				
				//fill data array
				aSensorData[i] = {
						"Key": 				e.data.driverlist[i].Name
						,"MarkerLabel" :	e.data.driverlist[i].RacePosition + "-" + e.data.driverlist[i].Name
						,"DateTime":		"2013-09-04T09:41:09+10:00"
						,"Lat": 			gpsCoTmp["Lat"]
						,"Long": 			gpsCoTmp["Long"]
						,"Heading":			286.0
						,"Speed":			e.data.driverlist[i].Speed
						,"CSSTextClasses":	e.data.driverlist[i].GetCSSTextClass()
						,"CSSCircleClasses":	e.data.driverlist[i].GetCSSCircleClass()
				}
				
        		//tmpcuircitID = e.data.driverlist[i].variousParameters.TrackId;	//TrackId is available in globals, not necessary reading it from variousParameters
        		//if(log >= 2){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: PosX:' + e.data.driverlist[i].PosX + ", Speed:" + e.data.driverlist[i].Speed);}	//analyzing problem with asynchronous marker updates
		}
		
        sensorLayer_UpdateTime = Date.now();
		sensorLayer_UpdateDelta = sensorLayer_UpdateTime - sensorLayer_UpdateTime_old;	//Determine time duration between recent and currrent worker run
		sensorLayer_UpdateTime_old = sensorLayer_UpdateTime;
		if(log >= 2){console.log("+++++++++Sensor Update Delta:",sensorLayer_UpdateDelta);}
                
		//Calculation of dynamic DisplayDuration
		if ((APIMODE == "DS" || APIMODE == "DEMO") && sensorLayer_UpdateDelta < UpdateRateDS) {
				DisplayDuration = UpdateRateDS + DisplayDurationCorrector       //If the worker runs more often than the data is updated in the DS API, then the duration is set to the DS update rate
		}else{
				DisplayDuration = sensorLayer_UpdateDelta  + DisplayDurationCorrector;
		}
		if (DisplayDuration < 0) { DisplayDuration = 0 }        //catch a negative value
		if (DisplayDuration > 2000) { DisplayDuration = 2000 }	// set a max DisplayDuration
		if(log >= 2){console.log("+++++++++DisplayDuration:    ",DisplayDuration);}
                
		if(log >= 3){console.log("++++++++ aSensorData_NEW" , aSensorData);}
		sensorLayer.update(aSensorData);

		// in case track changes on DS adjust the map settings for new possition
        if ( cuircitID != tmpcuircitID ){
		//if(log >= 3){console.log("----------- TrackID SHOULDbe changed: ", aRefPointTMP);}
		if (typeof tmpcuircitID == 'undefined'){tmpcuircitID = 9999999999;}	//tmpcuircitID is undefined if you switch to an APIMODE where the data source is not available, for example the pcars DS is not running
		//map.setCenter({lat: 50.332733, lng: 6.943355});
		changeMapSettings(e.data.arefpoint[tmpcuircitID] , map);

            cuircitID = tmpcuircitID;  // give the global var the new TrackId
            if(log >= 3){console.log("----------- TrackID changed. Call map.SetCenter(),  cuircitID / tmpcuircitID " + cuircitID + " / " + tmpcuircitID);}
		}
		
		if (SessionState_old != "Race" && SessionState == "Race"){   //Unhide markers after calculation, with a delay of 1000 ms
                        UnHide = "true";
                }
                if (UnHide == "true"){
                        UnHide_Timer = UnHide_Timer + sensorLayer_UpdateDelta;
                        if (UnHide_Timer > 1000){
                        	StopTransitionDelay = "true";
                                sensorLayer.interruptTransition();
                                sensorLayer.update(aSensorData);
                                CSSClassChanger.UnHideAllSvg();
                                UnHide_Timer = 0;
                                UnHide = "false";
                                if(log >= 2){console.log("+++++++++UnHide StopTransitionDelay:    ",StopTransitionDelay);}
                        }
                }
                SessionState_old = SessionState;
                SessionStage_old = SessionStage;

		if (recording_demo_data == "true"){
                        console.log("           {//" + recording_count);
                        console.log("                globals:{sensorLayer_UpdateDelta:"+sensorLayer_UpdateDelta+", state:\""+e.data.globals.state+"\", name:\""+e.data.globals.name+"\", lobbyid:"+e.data.globals.lobbyid+", joinable:\""+e.data.globals.joinable+"\", max_member_count:"+e.data.globals.max_member_count+", now:"+e.data.globals.now+", attributes:{TrackId:"+e.data.globals.attributes.TrackId+", SessionState:\""+e.data.globals.attributes.SessionState+"\", SessionStage:\""+e.data.globals.attributes.SessionStage+"\", GridSize:"+e.data.globals.attributes.GridSize+", MaxPlayers:"+e.data.globals.attributes.MaxPlayers+", SessionTimeDuration:"+e.data.globals.attributes.SessionTimeDuration+", SessionTimeElapsed:"+e.data.globals.attributes.SessionTimeElapsed+"}},");
                        console.log("                participants:[");
                        for (var i = 0; i < e.data.driverlist.length; i++ ){
                                if ((i+1) == e.data.driverlist.length){
                                        console.log("                        {RefId:"+e.data.driverlist[i].RefID+", Name:\""+e.data.driverlist[i].Name+"\", IsPlayer:"+e.data.driverlist[i].IsPlayer+", GridPosition:"+e.data.driverlist[i].GridPosition+", VehicleId:\""+VehicleIdToName(e.data.driverlist[i].VehicleId , aVehicleIdToName)+"\", RacePosition:"+e.data.driverlist[i].RacePosition+", CurrentLap:"+e.data.driverlist[i].CurrentLap+", CurrentSector:"+e.data.driverlist[i].CurrentSector+", LastLapTime:"+e.data.driverlist[i].LastLapTime+", FastestLapTime:"+e.data.driverlist[i].FastestLapTime+", State:\""+e.data.driverlist[i].State+"\", Speed:"+e.data.driverlist[i].Speed+", PositionX:"+e.data.driverlist[i].PosX+", PositionY:"+e.data.driverlist[i].PosY+", PositionZ:"+e.data.driverlist[i].PosZ+", Orientation:"+e.data.driverlist[i].Orientation+"}");
                                }else{
                                        console.log("                        {RefId:"+e.data.driverlist[i].RefID+", Name:\""+e.data.driverlist[i].Name+"\", IsPlayer:"+e.data.driverlist[i].IsPlayer+", GridPosition:"+e.data.driverlist[i].GridPosition+", VehicleId:\""+VehicleIdToName(e.data.driverlist[i].VehicleId , aVehicleIdToName)+"\", RacePosition:"+e.data.driverlist[i].RacePosition+", CurrentLap:"+e.data.driverlist[i].CurrentLap+", CurrentSector:"+e.data.driverlist[i].CurrentSector+", LastLapTime:"+e.data.driverlist[i].LastLapTime+", FastestLapTime:"+e.data.driverlist[i].FastestLapTime+", State:\""+e.data.driverlist[i].State+"\", Speed:"+e.data.driverlist[i].Speed+", PositionX:"+e.data.driverlist[i].PosX+", PositionY:"+e.data.driverlist[i].PosY+", PositionZ:"+e.data.driverlist[i].PosZ+", Orientation:"+e.data.driverlist[i].Orientation+"},");
                                }
                        }
                        console.log("                ]");
                        console.log("        },");
                        recording_count = recording_count + 1;
                }
		
		//call worker again for next itteration -> currently endless loop
		switch(APIMODE) {
                        case "DS":
                                //DS receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 DsServerURL
                                        ,dsport:                DsPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   "GETDSANDDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
                        case "CREST":                   //CREST receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 CRESTServerURL
                                        ,dsport:                CRESTPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   "GETCRESTDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
                        case "DEMO":
                                //DEMO receive mode

	                        //Calculation of WORKERDELAY_DEMODATA to adapt the playback speed to the recording speed
	                        //The record_pos is the array element of the recorded data and correlates to one worker run. Each element includes the sensorLayer_UpdateDelta. This is the time between the last and the current worker run. Now we calculate the WORKERDELAY_DEMODATA, which is the delay to the next worker run. Because of that we need the sensorLayer_UpdateDelta of the next array element and not of the current.
	                        record_pos_helper = record_pos + 1;
	                        if(record_pos_helper > demo.length-1){record_pos_helper = 0;}	//if last array element with record_pos is reached, record_pos_helper exceeds the upper array boundary. In this case the helper jumps to the first array element
	                        
	                        sensorLayer_UpdateDelta_DEMOdiff = demo[record_pos_helper].globals.sensorLayer_UpdateDelta - sensorLayer_UpdateDelta;	//diff time between recorded data and playback sensorLayer_UpdateDelta
	                        WORKERDELAY_DEMODATA = WORKERDELAY_DEMODATA + sensorLayer_UpdateDelta_DEMOdiff;		//adapt playback speed to recorded data with the worker delay
	                        if(WORKERDELAY_DEMODATA < 0){WORKERDELAY_DEMODATA = 0;} //catch negative values. If the playback machine is to slow and is not able to hold the playback speed of the recording machine, then the delay is calculated negative, but the delay must be positive
	                        if(log >= 2){console.log("Demo Delta: ",demo[record_pos].globals.sensorLayer_UpdateDelta,", cur Delta: ",sensorLayer_UpdateDelta, "diff: ", sensorLayer_UpdateDelta_DEMOdiff, "Delay: ", WORKERDELAY_DEMODATA);}
	
	                        workerDSDATA.postMessage({
	                                workerdelay:            WORKERDELAY_DEMODATA
	                                ,dsurl:                 ""
	                                ,dsport:                0
	                                ,timeout:               record_pos
	                                ,receivemode:   "GETDEMODATA"
	                                ,arefpoint:             e.data.arefpoint});
	                        record_pos = record_pos + 1;
	                        if(record_pos > demo.length-1 || record_pos > demo_end_pos-1){          //jump to beginning if end of array or demo_end_pos is reached/ -1, because the array begins with 0
	                                record_pos = demo_start_pos;
	                                StopTransitionDelay = "true";
	                                StopTransitionDelay_StartTime = Date.now();
	                        }
	                        break;
                        default:
                                //DS receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 DsServerURL
                                        ,dsport:                DsPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   "GETDSANDDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                }
	}, false);
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// receive data from pcars dedicated server (DS) and returns an array of PCARSdriver objects
	//         Receive_DS_data(url,port,timeout,RetrivelMode)
	// initial call of the worker
	// initial call for map initialization

	switch(APIMODE) {
		case "DS":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
			break;
		case "CREST":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: CRESTServerURL, dsport: CRESTPort, timeout: XMLHTTPTimeout, receivemode: "GETCRESTDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(CRESTServerURL, CRESTPort, 2000, "GETCRESTDRIVERDATA", aRefPointTMP);
			break;
		case "DEMO":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: "", dsport: 0, timeout: record_pos, receivemode: "GETDEMODATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data("", 0, record_pos, "GETDEMODATA", aRefPointTMP);
			cuircitID = aDrivers.globals.attributes.TrackId;
			break;
		default:
			workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
	}
        
        for (var i = 0; i < aDrivers.driverlist.length; i++ ){

                // calculate GPS coordinates
                gpsCoTmp =  calc_coordinates (cuircitID , aDrivers.driverlist[i].GetPosX() , aDrivers.driverlist[i].GetPosZ() , aRefPointTMP );

                // fill data array
                aSensorData[i] = {
                                "Key":                          aDrivers.driverlist[i].GetName()
                                ,"MarkerLabel" :        buildDriverName ( aDrivers.driverlist[i].GetRacePosition(), aDrivers.driverlist[i].GetName() )
                                ,"DateTime":            "2013-09-04T09:41:09+10:00"
                                ,"Lat":                         gpsCoTmp["Lat"]
                                ,"Long":                        gpsCoTmp["Long"]
                                ,"Heading":                     286.0
                                ,"Speed":                       aDrivers.driverlist[i].Speed
                                ,"CSSTextClasses":      aDrivers.driverlist[i].GetCSSTextClass()
                                ,"CSSCircleClasses":    aDrivers.driverlist[i].GetCSSCircleClass()
                }
                // bookmark current TrackID to detect track changes and adjust Map
                //tmpcuircitID = aDrivers.driverlist[i].GetVariousParameter("TrackId");	//tmpcuircitID never used after here
        }

	// init google map
	init_map(cuircitID , aRefPointTMP);

	// add map Listener
	map.addListener('zoom_changed', function() {
		if(log >= 3){console.log("+++++++++++++++++++++++++++++++++++++++++++ current StopTransitionDelay: " , StopTransitionDelay);}
        	StopTransitionDelay = "true";
        	//StopTransitionDelay_StartTime = Date.now();
        	sensorLayer.interruptTransition();
        	sensorLayer.update(aSensorData);
		if(log >= 3){console.log("+++++++++++++++++++++++++++++++++++++++++++ set StopTransitionDelay to: " + StopTransitionDelay + ", StopTransitionDelay_StartTime:" + StopTransitionDelay_StartTime);}
  	});

	// create Table with list of all tracks
	// checkbox Event handling
	$('#cbTracklistRefresh').click(function () {

		/* Method with checkbox
		if ($('#cbTracklistRefresh').is(':checked') == true) {
			StopRefreshTracklist 	= "true";
			WORKERDELAY_TRACKLIST 	= 10000;
		}else{
			StopRefreshTracklist 	= "false";
			WORKERDELAY_TRACKLIST	= 5000;
		}*/
		//Method with button
		var self = this;
                changeRefreshTracklist(self);
                
	});
	
	function changeRefreshTracklist(data){
                if(data.value === "Stop"){
                        StopRefreshTracklist    = "true";
                        WORKERDELAY_TRACKLIST   = 10000;
                        data.value = "Start";
                        data.title = "Start automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshTracklist    = "false";
                        WORKERDELAY_TRACKLIST   = 5000;
                        data.value = "Stop";
                        data.title = "Stop automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
        }


	// create worker for Tracklist updates //////////////////////////////////////////////////////////////////////
	var w_tracklist      =       new Worker('./worker_tracklist.js');
	
	w_tracklist.addEventListener('message', function(e) {

			if(log >= 3){console.log("+++++++++++ GETTRACKLIST Worker Trackliste Event: ", e );}
					
		//	var str = e.data;	// data string from return object

			refreshTrackList(buildTracklist(e.data.aTrack , e.data.aRefpoint ));
			w_tracklist.postMessage({
								workerdelay: 	WORKERDELAY_TRACKLIST
								,dsurl: 		DsServerURL
								,dsport: 		DsPort
								,timeout: 		2000
								,receivemode: 	"GETTRACKLIST" 
								,aRefpoint:		e.data.aRefpoint});
	}, false);
	
	//initial call of the tracklist worker. initiate endless loop
	w_tracklist.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETTRACKLIST", aRefpoint: aRefPointTMP });



	//todo: add subgrid for more drivers information
	jQuery("#DriverDataTable").jqGrid({
                datatype: "local",
                height: 'auto',
		width: 900,
		hiddengrid: true,
		rowNum: 200,
		caption: "List of available drivers",
                colNames:['RefID','Pos', 'Driver Name', 'State', 'Sector', 'Lap', 'Vehicle', 'last lap', 'fastest lap','diff','gap','Hu/AI','PosX', 'PosY', 'PosZ' ],
                colModel:[
                        {name:'refid',hidden: true, index:'invdate', width:40, sorttype:"int"},
                        {name:'driverposition', width:18, sorttype:"int", search:true},
                        {name:'drivername', width:100,sorttype:"text", search:true},
                        {name:'driverstate',width:40, align:"center",sorttype:"text"},
                        {name:'driversector',width:20, align:"center",sorttype:"int"},
                        {name:'lapnumber',width:18, align:"center",sorttype:"int"},
                        {name:'vehiclename',width:90,sorttype:"text"},
                        {name:'lastlap',width:35, align:"center",sorttype:"text"},
                        {name:'fastestlap',width:35, align:"center",sorttype:"text"},
                        {name:'gap2ahead',width:30, align:"center",sorttype:"text"},
			{name:'gap2first',width:30, align:"center",sorttype:"text"},
                        {name:'isplayer',width:20, align:"center",sorttype:"text"},
                        {name:'posx',hidden: true,width:20, align:"center",sorttype:"float"},
                        {name:'posy',hidden: true,width:20, align:"center",sorttype:"float"},
                        {name:'posz',hidden: true,width:20, align:"center",sorttype:"float"}
                ],
                afterInsertRow: function (rowid, rowdata) {
			if (rowdata.driverposition == 1){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: 'gold' });}
			if (rowdata.driverposition == 2){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: 'silver' });}
			if (rowdata.driverposition == 3){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: '#CD7F32' });}
		}
	});
	
	// add filter option bar
	jQuery("#DriverDataTable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	// sort driver table on startup
	jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
	// add StopRefresh Table button in jqgrid header
	//Method with checkbox
	//$('#DriverDataArea span.ui-jqgrid-title').after(' | Stop refresh table:<input type="checkbox" id="cbDriverlistRefresh"/>');
	//Method with Button
	//TODO: tune Layout
	jQuery('#DriverDataTable').setCaption('List of available drivers&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Stop automatic refresh of table" id="cbDriverlistRefresh" value="Stop" style="background-color:#dddddd"></input>'+ '&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Export table to CSV" id="cbDriverlistExport" value="Export" style="background-color:#dddddd"></input>' + '&nbsp;&nbsp;' + '<input type="button" title="Export all past session results of this race weekend to CSV" id="cbDriverlistExportAll" value="Export All" style="background-color:#dddddd"></input>' + '&nbsp;&nbsp;' + '<input type="text" id="txtSessionStage" readonly style="border:0; background: #eeeeee;">');
			
	// checkbox Event handling
        $('#cbDriverlistRefresh').click(function () {

                /* Method with checkbox
                if ($('#cbDriverlistRefresh').is(':checked') == true) {
                        StopRefreshDriverlist   = "true";
                }else{
                        StopRefreshDriverlist  	= "false";
                }*/
                //Method with Button
                var self = this;
                changeRefreshDriverlist(self);
                                                
        });
        
        function changeRefreshDriverlist(data){
                if(data.value === "Stop"){
                        StopRefreshDriverlist   = "true";
                        data.value = "Start";
                        data.title = "Start automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshDriverlist  	= "false";
                        data.value = "Stop";
                        data.title = "Stop automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
        }

	$('#cbDriverlistExport').click(function () {
		//jqGrid("getRowData") used, because with jqGrid("getGridParam", "data") is nor sort possible. getRowData is automatically sorted like you see it on the website, but only works for the current page if you have a pager enabled.
		//JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getGridParam", "data"), "",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",],"Report_DriverTable");
		ExportCSV(JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Session Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","posx","posy","posz",]/*,"Report_DriverTable"*/),"Report_DriverTable");
	});
	
	$('#cbDriverlistExportAll').click(function () {
		var CSVall = "";
		for (var key in CSVExport) {
			if(CSVExport[key] != ""){
				CSVall += CSVExport[key] + '\r\n\n';
			}
		}
		ExportCSV(CSVall,"Results");
	}); 
        
	// setting up google maps overlays
	function GPSSensor(initData) {
               //state information
               var _div = null;
               var _data = initData;
               var _projection = null;

               function transform(d) {
                   var padding = 10;                   
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this) 
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }
               
               function transformWithEase(d) {
                   var padding = 10;
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this)
                       .transition().duration(DisplayDuration)
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }

               //superclass methods for google maps
               this.onAdd = function() {
                   _div = d3.select(this.getPanes().overlayLayer)
                            .append("div")
                            .attr("class", "stations");
               };               
                              
               this.draw = function () {                   
                   var padding = 10;
                   _projection = this.getProjection();
		  
					// complete block moved to update function
		/*
                   var marker = _div.selectAll("svg")
                       .data(_data, function (d) { return d.Key; })
                       .each(transform) // update existing markers
                        .enter().append("svg:svg")
                       .each(transform)
                       //.attr("class", "marker");
                   		.attr("class", function (d){ return d.CSSTextClasses });
           
                   
		   		   //if(log >= 3){console.log("++ Marker" , marker);}

                   // Add a circle.
                   marker.append("svg:circle") 
                       .attr("r", 4.5)
                       .attr("cx", padding)
                       .attr("cy", padding)
                       .attr("class", function (d){ return d.CSSCircleClasses } );
		       		   //.style("fill", "red");

					//todo experimental method call	
					//marker.text("test123456");	
					if(log >= 3){console.log("Marker: " , marker);}
		

                   // Add a label.
					if(log >= 3){console.log ("++++ in function draw() ->  aSensorData: " , aSensorData);}
                   marker.append("svg:text")
                       .attr("x", padding + 7)
                       .attr("y", padding)
                       .attr("dy", ".31em")
			//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
			//      it seem that the function within .text(...) will called only once at the beginning 
			//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
		       .text(function (d) {
						//if(log >= 4){console.log("+++++ d: " , d );}
						//if(log >= 4){console.log("+++++ this: " , this );}

						for (var i = 0; i < aSensorData.length; i++){
						
							//if(log >= 4){console.log(" for Update MarkerLabel:" , aSensorData);}
							if (aSensorData[i].Key == d.Key){
								if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
								return  aSensorData[i].MarkerLabel;
							}
						}
						
						//todo: during update d is not an array its an individual hash
						//if(log >= 3){console.log("++++not array:");}
						return d.MarkerLabel;
						
					})
               //       .text(function (d) { return d.Key; });                                      
			*/
               };

               this.onRemove = function () {
                   _div.remove();
               };


               // todo: known issue: Beim Wechsel der Position, bleibt eine "Leiche" auf der Karte uebrig, weil Key "Pos - Name" zusammensetzt
               // easyt solution:  deleting leading position number 
               this.update = function (data) {     
			
				var marker;
				var padding = 10;
					
				//update internal data which drive redrawing on zoom_changed
				_data = data.slice();
			   
			   //Detect time between StopTransitionDelay set to "true" and now
			   var CurrentTime = Date.now();
			   var StopTransitionDelay_TimeRun = CurrentTime - StopTransitionDelay_StartTime;

			   if( StopTransitionDelay == "true" )
			   {
					if(log >= 3){console.log ("++++++++++++++++++++++++++++++ stopped StopTransitionDelay: " + StopTransitionDelay + " , TimeRun:" + StopTransitionDelay_TimeRun);}
					//this.draw();
					marker = _div.selectAll("svg")
						.data(_data, function (d) { return d.Key; })
						.each(transform) // update existing markers
						.enter().append("svg:svg")
						.each(transform)
						.attr("class", function (d){ return d.CSSTextClasses });
	
					// reset to default after zoom event finished. 
					//A zoom change in Google Maps takes some time. If the worker runs have a short interval you need a minimum time where the transformWithEase have to be interrupted
					if (StopTransitionDelay_TimeRun > StopTransitionDelay_minTimeRun) {StopTransitionDelay = "false";}
			
			   }else{

					if(log >= 3){console.log ("++++++++++++++++++++++++++++++ normal StopTransitionDelay: " , StopTransitionDelay );}
					//this.draw();
	
					marker = _div.selectAll("svg")
						.data(_data, function (d) { return d.Key; })
						.each(transformWithEase) // update existing markers
						.enter().append("svg:svg")
						.each(transform)
						.attr("class", function (d){ return d.CSSTextClasses });
	
					// reset to default after zoom event finished
					//StopTransitionDelay = "false";
			  }
			
			// Add a circle.
			marker.append("svg:circle")
				.attr("r", 4.5)
				.attr("cx", padding)
				.attr("cy", padding)
				.attr("class", function (d){ return d.CSSCircleClasses } );

			// Add a label.
			marker.append("svg:text")
				.attr("x", padding + 7)
				.attr("y", padding)
				.attr("dy", ".31em")
				//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
				//      it seem that the function within .text(...) will called only once at the beginning
				//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
				.text(function (d) {
					if(log >= 4){console.log("+++++ d: " , d );}

					for (var i = 0; i < aSensorData.length; i++){
						if (aSensorData[i].Key == d.Key){
						if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
						return  aSensorData[i].MarkerLabel;
						}
					}
					return d.MarkerLabel;

				})
				
			// Update CSS classes new
			var svgs = _div.selectAll("circle")
						.data(_data, function (d){ return d.Key; })
						.attr("class" ,(function(d){ return d.CSSCircleClasses; }));
			
			// Update labels new
			var svgs = _div.selectAll("text")
						.data(_data, function (d){ return d.Key; })
						.text(function(d){ return d.MarkerLabel; });

			// delete unneeded svg objects from dom tree
			this.CleanupDriverObjects(_data);			
			
		  	}; //end update()
            
		  	this.CleanupDriverObjects = function(data) {
		  		// remapping of array of drivers to array of key
		  		var aTmp = {};
		  		for ( i = 0; i < data.length; i++) {
		  			aTmp[data[i].Key] = "";
		  		}
		  			
		  		var svgs = 	d3.selectAll("svg")
		  					.each(function( d ) {
		  							if ( aTmp[d.Key] == undefined ) {		  								
		  								//if(log >= 4){console.log("---- CleanupDriverObjects() - Ghost car deleted from map d.Key: " , d.Key);}
		  								this.remove(); 	// delete svg object
		  							}	
		  					});
		  	}; // end CleanupDriverObjects()

			this.interruptTransition = function (){
		  		// interrupt transition while zoom event
				if(_div != null){
					_div.selectAll("svg")
						.interrupt();
				}
            }; // end interruptTransition()
            
          }


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////				
//////////////////////////////////////////////////////////////////////////
function init_map(_TrackID , aRefPoint)
{
           //subclassing
           GPSSensor.prototype = new google.maps.OverlayView();


           // Create the Google Map
           map = new google.maps.Map(d3.select("#map").node(), {
               zoom: aRefPoint[cuircitID]["Zoom"],

                // use cuircit RefPoint for center google map
                center: new google.maps.LatLng( aRefPoint[_TrackID]["MapInitLat"] , aRefPoint[_TrackID]["MapInitLong"] ),
                mapTypeId: google.maps.MapTypeId.SATELLITE
           });

           //if(log >= 3){console.log("-+-+- aSensorData-Array: ", aSensorData);}
           sensorLayer = new GPSSensor(aSensorData);
           sensorLayer.setMap(map);
}

function changeMapSettings(newTrackObj, mapobj)
{
	//if(log >= 3){console.log("----- call function changeMapSettings() with track data: " , newTrackObj );}
	//if(log >= 3){console.log("----- call function changeMapSettings() with map data: " , mapobj );}

	//todo: replace map (global variable) with mapobj(if this is not a copy)
	//example: map.setCenter({lat: 50.332733, lng: 6.943355});
	map.setCenter({lat: newTrackObj["MapInitLat"], lng: newTrackObj["MapInitLong"]});

	map.setZoom(newTrackObj["Zoom"]);

	StopTransitionDelay = "true";
	StopTransitionDelay_StartTime = Date.now();

	//todo: change also picture Overlay prevered mapsourc(google,openstreetmap) in needed
	return 1;
}

///////////////////
function refreshTrackList(a)
{
	//if(log >= 3){console.log("------------------------ refreshTrackList() parameter a : " , a);}

	// if set to true, no refresh of table wanted
	if (StopRefreshTracklist == "true")
	{
		if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshTracklist set to:", StopRefreshTracklist );}
		return 1;
	}

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#tracklisttable").jqGrid("clearGridData");

	var gridcnt = 0;
	var _data;
	
	for (var key in a ){

		//if(log >= 3){console.log("--- Info for loop value a[key]: ", a[key]);}
		_data = {
                                        id:             gridcnt
                                        ,trackid:       a[key]["trackid"]
                                        ,trackname:     a[key]["trackname"]
                                        ,gridsize:      a[key]["gridsize"]
                                        ,refpoint:      a[key]["refpoint"]
                                        ,comment:       a[key]["comment"]
                                };		
		jQuery("#tracklisttable").jqGrid('addRowData',gridcnt, _data);

		gridcnt++
	}

	// relaod data into jqGrid
	jQuery("#tracklisttable").trigger("reloadGrid");
	
}

//fill
function refreshVehicleList(a)
{
	var _data;
	
	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#carlisttable").jqGrid("clearGridData");	
	
	
	for (i=0; i < a.length; i++) {
		_data = {
   					vehicleid:	a[i].vehicleid,
					name:		a[i].name,
					cls:		a[i].cls,
					set1:		"-",
					set2:		"-",
					comment:	"-"
				};
		
		jQuery("#carlisttable").jqGrid('addRowData',i, _data);
	}
	
	return 1;	
}

//////////////////
function refreshDriverList(a)
{
	// if set to true, no refresh of table wanted
        if (StopRefreshDriverlist == "true") {
                if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshDriverlist set to:", StopRefreshDriverlist );}
                return 1;
        }

	//if(log >= 3){console.log("refreshDriverList(e): " , a);}

	var _data;
	var _allDrivers = new Array();
	var Gaps = [];

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#DriverDataTable").jqGrid("clearGridData");	

        // get current size of the table
        //var GridSize = jQuery("#DriverDataTable").getGridParam("reccount");	//disabled, because after clearGridData it is 0 every time


	//todo: if drivertable is longer then new driverlist, all old values should be deleted
	//todo: if clearGridData method is working, no need for a decision if use setRowData or addRowData !
	for (i=0; i < a.length; i++) {
		//if(log >= 3){console.log("update data on row: " + i + " / " + a.data[i]);}
		
		if (i == 0){
			Gaps = CalcGaps(a[i].FastestLapTime,a[0].FastestLapTime,a[i].FastestLapTime);
		}else{
			Gaps = CalcGaps(a[i].FastestLapTime,a[0].FastestLapTime,a[i-1].FastestLapTime);
		}
		if(log >= 3){console.log("Driver: " , a[i].Name , " , gap2ahead: ", Gaps.gap2ahead , " , gap2first: ", Gaps.gap2first);}
                
		_data = {   
					refid:			a[i].RefID
					,driverposition:	a[i].RacePosition	
					,drivername:		a[i].Name
					,driverstate:		a[i].State
					,driversector:		a[i].CurrentSector
					,lapnumber:		a[i].CurrentLap
					,vehiclename:		VehicleIdToName(a[i].VehicleId , aVehicleIdToName)	//in DEMO mode a[i].VehicleId contains directly the VehicleName and the VehicleIdToName returns it back
					,lastlap:		ConvertLaptimeInReadbaleFormat(a[i].LastLapTime)
					,fastestlap:		ConvertLaptimeInReadbaleFormat(a[i].FastestLapTime)
					,gap2ahead:		Gaps.gap2ahead
					,gap2first:		Gaps.gap2first
					,isplayer:		ConvertIsPlayer(a[i].IsPlayer)
					,posx:			a[i].PosX
					,posy:			a[i].PosY
					,posz:			a[i].PosZ
		};
		//decision if replace or add a row to jqGrid
		/*if (i < GridSize){	//disabled, because after clearGridData GridSize is 0 every time
				jQuery("#DriverDataTable").jqGrid('setRowData',i, _data);
				//if(log >= 3){console.log("+++++ set " + i );}
		}else{*/
				jQuery("#DriverDataTable").jqGrid('addRowData',i, _data);
				//if(log >= 3){console.log("+++++ add " + i );}
		//}
	
		//build hash for clean up map	
		_allDrivers[buildDriverName(a[i].Name, a[i].RacePosition)] =  {driverposition : a[i].RacePosition};

	}

	//Hide columns diff and gap during SessionStage Race1 and Race2
	if((SessionStage_old != "Race1" && SessionStage_old != "Race2") && (SessionStage == "Race1" || SessionStage == "Race2")){
		if(log >= 3){console.log("Hide Gaps");}
		jQuery("#DriverDataTable").hideCol(["gap2first","gap2ahead"]);
	}
	if((SessionStage_old == "Race1" || SessionStage_old == "Race2") && (SessionStage != "Race1" && SessionStage != "Race2")){
		if(log >= 3){console.log("Show Gaps");}
		jQuery("#DriverDataTable").showCol(["gap2first","gap2ahead"]);
	}

	jQuery("#DriverDataTable").trigger("reloadGrid");


	return 1;
}

function buildDriverName(drivername , raceposition)
{
	// Diego Xavier on race position 5 => "5-Diego Xavier"
	return raceposition + "-" + drivername;
}

function transformVehicleObjectToHash(a){
	
	var hash = {};
	
	for (var i=0; i < a.length; i++){
		// '' + a[i].vehicleid -> needed to convert negative numbers to string
		hash[ '' + a[i].vehicleid ] = a[i].name;
	}
				
	return hash;
}

function VehicleIdToName(id, array){
	
	if (array[id]){
		return array[id];	
	} else {
		// in the case vehilce IDs not in hash
		if(log >= 3){console.log("------- VehicleIdToName(), vehicle ID unknown: " , id)};
	}
	//if ID not found return id
	return id;
}

function ConvertIsPlayer(bool){
	
	if (bool){
		return "Hu";
	} else {
		return "AI";	
	}
}

///////////////////
function buildTracklist( aTrackList , aRefPoint ){

	// INFO: sometime problems with negative index number in associative array !!
	
	var aRefPointInt	= aRefPoint;
	//var aRefPointInt  = new Refpoint("-1"); // works fine, but slower because creating new RefPointArry
	//var aRefPointInt	= aRefPoint.slice(); // real copy an arrayworks but did not copy negative indexes
	
	var commenttmp 		= '';
	var tmpObj;
	var aNewTrackList 	= [];
	var aTmpTracklist	= [];
	var aSkipList		= []; //List of all existing RefIDs

	// go through all responded tracks from pcars dedicated server
	for (var i=0; i < aTrackList.length; i++)
	{
		tmpObject = aTrackList[i];

		//if refpoint for a track exists
		if (aRefPointInt['' + tmpObject.trackid]){

			aNewTrackList[tmpObject.trackid.toString()] = { 	
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"yes"
				,comment:	aRefPointInt[tmpObject.trackid]["Comment"]
            };

		//no Refpoint entry exists , fill with dummy values
		}else{
			
			aNewTrackList[tmpObject.trackid.toString()] = {
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"no"
				,comment:	"no comment because no refpoint"
           };
		}
			
		// remember trackids that allready covered by DS output from RefpointArray
		aSkipList['' + tmpObject.trackid] = "allready found";
	}
			
	//fill up with refpoint entries that are not listed in DS array
	for (var key in aRefPointInt ){
		
		
		//skip run if allready found 
		if ( aSkipList['' + key] ){
			continue;		
		};
				
		tmpObject = aRefPointInt['' + key];

		// check if comment field exists in the RefPoint array
		commenttmp = '';
		if ( 'Comment' in tmpObject ) {  commenttmp = tmpObject["Comment"];  };

		aNewTrackList['' + key] = {
				trackid:	key
				,trackname:	aRefPointInt[key]["Name"]
				,gridsize:	"no info"
				,refpoint:	"yes"
				,comment:	commenttmp 
		};
	}

	return aNewTrackList;
}

function CalcGaps(bestLaptime,bestLaptimeFirst,bestLaptimeAhead){
	var gap2ahead = 0;
	var gap2first = 0;

	if (bestLaptime != 0){
		if (bestLaptimeAhead != 0){gap2ahead = bestLaptime - bestLaptimeAhead;}
		if (bestLaptimeFirst != 0){gap2first = bestLaptime - bestLaptimeFirst;}
	}

	var Gaps = {
		gap2first: ConvertLaptimeInReadbaleFormat(gap2first),
		gap2ahead: ConvertLaptimeInReadbaleFormat(gap2ahead)
	}

	return Gaps;
}

function ConvertLaptimeInReadbaleFormat(milliseconds)
{
	//todo: implemet date format with leading zeros for seconds and milliseconds
	//var date = new Date(milliseconds);
	
	if (milliseconds == 0){
		return "-";
	}
	
	var str = '';

	var ms = parseInt((milliseconds%1000))
	 , s = parseInt((milliseconds/1000)%60)
	 , m = parseInt((milliseconds/(1000*60))%60);

	//m = (m < 10) ? "0" + m : m;
	s = (s < 10 && m > 0) ? "0" + s : s;
	ms = (ms < 10) ? "00" + ms : ms;
	ms = (ms > 9 && ms < 100) ? "0" + ms : ms;

	if (m > 0){
		str = m + ":" + s + "." + ms;
	}else{
		str = s + "." + ms;
	}

	return str;
}

function JSONToCSVConvertor(JSONData, ReportTitle, ShowLabel,header_names,excludeColumns/*,fileName*/) {
	//If JSONData is not an object then JSON.parse will parse the JSON string in an Object
	var arrData = typeof JSONData != 'object' ? JSON.parse(JSONData) : JSONData;

	//header mapping Names <--> IDs, for example header_mapping[0][3] correlates to header_mapping[1][3]
	var header_mapping = [];
	var header_ids = [];
	var cnt = 0;

	for (var colName in arrData[0]) {
		header_ids[cnt] = colName;
		cnt++;
	}

	header_mapping[0] = header_names;
	header_mapping[1] = header_ids;

	//if(log >= 3){console.log("Export - arrData:" , arrData , " , headers: " , header_mapping );}

	var CSV = '';
	//Set Report title in first row or line

	CSV += ReportTitle + '\r\n\n';

	//This condition will generate the Label/Header
	if (ShowLabel) {
		var row = "";

		for (var col in arrData[0]) {
			//Now convert each value to string and comma-seprated
			if(excludeColumns && excludeColumns.indexOf(col) != -1){
				continue;
			}
			if(header_names){
				row += header_mapping[0][header_ids.indexOf(col)] + ',';
			}else{
				row += col + ',';
			}
		}
		row = row.slice(0, -1);
		//append Label row with line break
		CSV += row + '\r\n';
	}

	//1st loop is to extract each row
	for (var i = 0; i < arrData.length; i++) {
		var row = "";

		//2nd loop will extract each column and convert it in string comma-seprated
		for (var colName in arrData[i]) {
			//if(log >= 2){console.log("Export - colName: " , colName , " , Exclude: ", excludeColumns.indexOf(colName));}
			if(excludeColumns && excludeColumns.indexOf(colName) != -1){
				continue;
			}
			row += '"' + arrData[i][colName] + '",';
		}

		row.slice(0, row.length - 1);

		//add a line break after each row
		CSV += row + '\r\n';
	}
        
	/*if (CSV == '') {
		alert("Invalid data");
		return;
	}

	if(!fileName){
		//Generate a file name
		fileName = "MyReport_";
		//this will remove the blank-spaces from the title and replace it with an underscore
		fileName += ReportTitle.replace(/ /g,"_");
	}

	if (navigator.appName == "Microsoft Internet Explorer") {
		var oWin = window.open();
		oWin.document.write('sep=,\r\n' + CSV);
		oWin.document.close();
		oWin.document.execCommand('SaveAs', true, fileName + ".csv");
		oWin.close();
	} else{
		//Initialize file format you want csv or xls
		var uri = 'data:text/csv;charset=utf-8,' + escape(CSV);

		// Now the little tricky part.
		// you can use either>> window.open(uri);
		// but this will not work in some browsers
		// or you will not get the correct file extension

		//this trick will generate a temp <a /> tag
		var link = document.createElement("a");
		link.href = uri;

		//set the visibility hidden so it will not effect on your web-layout
		link.style = "visibility:hidden";
		link.download = fileName + ".csv";

		//this part will append the anchor tag and remove it after automatic click
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}*/
	
	return CSV;
}

function ExportCSV(CSV,fileName){

	if (CSV == '') {
		alert("There are no results");
		return;
	}

	if(!fileName){
		//Generate a file name
		fileName = "MyReport_";
		//this will remove the blank-spaces from the title and replace it with an underscore
		//fileName += ReportTitle.replace(/ /g,"_");
	}

	if (navigator.appName == "Microsoft Internet Explorer") {
		var oWin = window.open();
		oWin.document.write('sep=,\r\n' + CSV);
		oWin.document.close();
		oWin.document.execCommand('SaveAs', true, fileName + ".csv");
		oWin.close();
	} else{
		//Initialize file format you want csv or xls
		var uri = 'data:text/csv;charset=utf-8,' + escape(CSV);

		// Now the little tricky part.
		// you can use either>> window.open(uri);
		// but this will not work in some browsers
		// or you will not get the correct file extension

		//this trick will generate a temp <a /> tag
		var link = document.createElement("a");
		link.href = uri;

		//set the visibility hidden so it will not effect on your web-layout
		link.style = "visibility:hidden";
		link.download = fileName + ".csv";

		//this part will append the anchor tag and remove it after automatic click
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

       </script>
   </body>
</html>

