<!DOCTYPE html>
<html lang="de">
     <head>
         <meta charset="utf-8"/>
         <title>Project Cars DS - live view with position update.</title>
         
         <script src="https://maps.google.com/maps/api/js??v=3.exp&sensor=true"></script>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.3.3/d3.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/js-url/1.8.6/url.min.js"></script>
 
 	 <script src="./config.js" charset="utf-8"></script>
	 <script src="./pcars_driver.js" charset="utf-8"></script>
	 <script src="./pcars_track.js" charset="utf-8"></script>
	 <script src="./pcars_vehicle.js" charset="utf-8"></script>
	 <script src="./receive_ds_data.js" charset="utf-8"></script>
	 <script src="./calc_coordinates.js" charset="utf-8"></script>
	 <script src="./class_reference_points.js" charset="utf-8"></script>
	 <script src="./get_url_param.js" charset="utf-8"></script>
	 <script src="./css_classchanger.js" charset="utf-8"></script>
	 <script src="./demo_data.js" charset="utf-8"></script>

	<!--Ermoeglicht das verschieben von DIV Bloecken -->
	<!-- Jquery UI needed for jTable-->
        <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
        <script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
        <script>
                $(function() {
					$( "#DSdata" ).draggable();
					$( "#TrackList" ) .draggable();
					$( "#CarList" ) .draggable();
					$( "#DriverDataArea" ) .draggable();
					$( "#Settings" ) .draggable();
                });
		
		$(function() {
            		$( "#DSdata" ).resizable({
//             			animate: true
						ghost: true
            		});
//		        $( "#tracklisttable" ).resizable({
//               			ghost: true
//            		});
         	});
	
        </script>

	<!-- The jqGrid language file code-->
        <link rel="stylesheet" type="text/css" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/css/ui.jqgrid.css">
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/i18n/grid.locale-de.js"></script>
        <!-- The atual jqGrid code -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/jquery.jqGrid.src.js"></script>


        <!-- CSS definitions--> 
        <style type="text/css">

		html, body, #map {
                 width: 100%;
                 height: 100%;
                 margin: 0;
                 padding: 0;
		}
        
	     #DSdata{
				position: 	absolute; 
				left: 		55%; 
				top: 		0px; 
				width: 		300px; 
				height: 	200px;
				border:		1;
				background:	lightgreen;
	     }

	     #TrackList{
				position:       absolute;
                left:           5%;
                top:            30px;
                border:         1;
				text-align: 	center;
	     }
	     #TrackList .ui-jqgrid-bdiv{
				max-height: 400px;
				overflow-x: hidden;
				word-wrap: break-word; /* IE 5.5+ and CSS3 */
    			white-space: pre-wrap; /* CSS3 */
    			white-space: -pre-wrap; /* Opera 4-6 */
    			white-space: -o-pre-wrap; /* Opera 7 */
    			white-space: normal !important;
		 }
	     
	     #CarList{
				position:       absolute;
                left:           5%;
                top:            60px;
                border:         1;
				text-align: 	center;
	     }
	     #CarList .ui-jqgrid-bdiv{
				max-height: 400px;
				overflow-x: hidden;
				word-wrap: break-word; /* IE 5.5+ and CSS3 */
    			white-space: pre-wrap; /* CSS3 */
    			white-space: -pre-wrap; /* Opera 4-6 */
    			white-space: -o-pre-wrap; /* Opera 7 */
    			white-space: normal !important;
		 }

	     #DriverData{
				position:       absolute;
                left:           55%;
				top:			250px;
	     }
	     #DriverData .ui-jqgrid-bdiv{
				max-height: 400px;
				overflow-x: hidden;
				word-wrap: break-word; /* IE 5.5+ and CSS3 */
    			white-space: pre-wrap; /* CSS3 */
    			white-space: -pre-wrap; /* Opera 4-6 */
    			white-space: -o-pre-wrap; /* Opera 7 */
    			white-space: normal !important;
		 }
		
	     #DriverDataArea{
				position:       absolute;
				left:           5%;
				top:            0px;
				background:	lightgrey
	     }
	    	         
	     #hide or unhide objects
	     starthidden {
   				 display: none;
  		}

	     #Settings{
		position:       absolute;
                left:           75%;
                top:            25px;
                background:     lightgrey
	     }

		
		.stations, .stations svg {
			position: absolute;
		}

		.stations svg {
			width: 60px;
			height: 20px;
			padding-right: 100px;
			font: 10px sans-serif;
		}

		.stations circle {
			fill: blue;
			stroke: black;
			stroke-width: 1.5px;
		}
             
		.tableoption {
			background:     lightgrey;
		}

		circle.CSS_RacePos_1 {
			fill: white;
			border-radius: 400%
		}		
		

         </style>
     </head>
   <body>

	<!-- definition of data areas, the order of the tables decides which one is in foreground and which in background-->
	<div id="map"></div>
	<div id="DSdata">
		<p0>-</p0><br><p1></p1><br><p2></p2><br><p3></p3><br><p4></p4><br><p7></p7><br><p8></p8><br><p9></p9><br>----- Settings ----<br><p5></p5><br><p6></p6>
		<div id="DSdataInformation"></div>
		<div id="DSdataSettings"></div>
	</div>
	<div id="CarList">
		<table id="carlisttable"></table>
	</div>
	<div id="TrackList">
		<table id="tracklisttable"></table>
		<div id="pager_tracklisttable"></div>
	</div>
	<div id="DriverDataArea">
		<table id="DriverDataTable"></table>
	</div>

	<!-- definition of option panel-->	
	<div id="Settings">
		Settings: <br>

		<!-- API dropdown -->
		<form action="#">
		  <fieldset id="fieldset">
			<label for="APIMODE">Select API Type</label>
	    		<select class="APIMODE" name="APIMODE" id="APIMODE">
	      			<option>DS</option>
	      			<option>CREST</option>
	      			<option>DEMO</option>
			</select>
		</fieldset>
		</form>

		<br>----<br>
		<p>
  			<label for="amount">DisplayDurationCorrector:</label>
			<input type="text" id="amount" readonly style="border:0;">
		</p> 			
		<!-- Slider Duration -->
		<div id="slider-range-max"></div>
	</div>

       <script>
	// initialize vars
	var aDrivers 			= new Array();		// array for PCARSdriver objects
	var aSensorData 		= new Array();		// array of Hashes, each hash includes parameters of a driver
	var XMLHTTPTimeout		= 2000;
	var StopTransitionDelay = "true";	// if set to true, DisplayDuration set to 0 ( cases: zoom, mapchange )
	var StopTransitionDelay_StartTime = Date.now();	//timestamp for StopTransitionDelay is set to "true"
	var global_i			= 0;
	var map;				// google map object
	var sensorLayer;
	var sensorLayer_UpdateTime;		//time, when marker are updated
        var sensorLayer_UpdateTime_old;		//time of the recent dsdata-worker run, when the marker were updated
        var sensorLayer_UpdateDelta;		//time between recent and current dsdata-worker run, when the marker were updated
        var UnHide                      = "false";	//UnHide markers
        var UnHide_Timer                = 0;		//Timer for UnHide markers
	var DisplayDurationCorrector = 0;
	var aRefPointTMP			= 	new Refpoint("-1");		// hash of all RefPoints for available tracks
	var aVehicleList			=	new Array();			// array of pcars_vehicle.js objects
	var aVehicleIdToName		=	new Array();			// hash to translate vehicleID to VehicleName
	var StopRefreshTracklist	=	"false";
	var StopRefreshDriverlist	=	"false";
	var SessionState                =       "";
        var SessionState_old            =       "";
	//var APIMODE					=	"DS";   // possible values DS,CREST
	var PCARSd	= new PCARSdriver(); // only use the object to get functions of it
	var CSSClassChanger			=	new CSSClassChanger ();
	PCARSd.SetExampleData();
	
	var recording_count = 0;        //used as array index comment during recording demo data
        var record_pos = demo_start_pos;//used for playback of data during DEMO mode
	var record_pos_helper;          //for WORKERDELAY_DEMODATA calculation needed
	
	var sensorLayer_UpdateDelta_DEMOdiff;	//Difference between sensorLayer_UpdateDelta of the recorded data and the playback
        var WORKERDELAY_DEMODATA = WORKERDELAY_DSDATA;	//Worker delay for DEMO mode to adapt the playback speed to the recording

	// set to global var, to modify in future stage for periodical updates via ajax
	var DsName			=	"-+-"; // aDsData.name;
	var DsState			=	"-+-"; //aDsData.state;		//idle/running
	var DsTrackName		=	"Slightly Mad Studios Ltd";		//aTrackList[aDsData.TrackId];
	var DsMaxMemberCnt	=	"-+-"; //aDsData.max_member_count;
	var cuircitID		=	9999999999;		//aDsData.TrackId;
	
	var GPSinit                         = calc_coordinates (9999999999 , PCARSd.GetPosX() , PCARSd.GetPosZ() , aRefPointTMP);
        aSensorData[0] = {
		"Key":			PCARSd.GetName()
		,"MarkerLabel" :	PCARSd.GetRacePosition() + "-" + PCARSd.GetName()
		,"DateTime":		"2013-09-04T09:41:09+10:00"
		,"Lat":			GPSinit["Lat"]
		,"Long":		GPSinit["Long"]
		,"Heading":		286.0
		,"Speed":		PCARSd.GetSpeed()
		,"CSSTextClasses":	PCARSd.GetCSSTextClass()
		,"CSSCircleClasses":	PCARSd.GetCSSCircleClass()
        }

						
								
	// hide or unhide objects defined within config.js
	if ( SHOWTRACKLIST 	== false ) { 	$( "#TrackList" ).hide();			}
	if ( SHOWDSDATA 	== false ) { 	$( "#DSdata" ).hide();				}						
	if ( SHOWDRIVERDATA	== false ) { 	$( "#DriverDataArea" ).hide();		}
	if ( SHOWSETTINGS	== false ) { 	$( "#Settings" ).hide();			}
	if ( SHOWCARLIST	== false ) { 	$( "#CarList" ).hide();			}
	
	//set dropdown menu APIMODE
	switch(APIMODE) {
		case "DS":
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DS";
			break;
		case "CREST":
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "CREST";
			break;
		case "DEMO":
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DEMO";
			break;
		default:
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DS";
	}
								
	// check if url params overwrite the default ds info
	if (get_url_param('dsurl') && get_url_param('dsport'))
        {
			DsServerURL     =       get_url_param('dsurl');
			DsPort          =       get_url_param('dsport');
			APIMODE         =       "DS";
			document.getElementById("fieldset").elements.namedItem("APIMODE").value = "DS";

			if(log >= 3){
				console.log("overwrite ds default settings with: " 
					+ get_url_param('dsurl') 
					+ " / " 
					+ get_url_param('dsport'));
			}
	}
	
	// check if url params overwrite the default CREST info
	if (get_url_param('cresturl') && get_url_param('crestport'))
	{
		CRESTServerURL		=	get_url_param('cresturl');
		CRESTPort		=	get_url_param('crestport');
		APIMODE			=	"CREST";
		DisplayDuration		=	DisplayDurationCREST;
		document.getElementById("fieldset").elements.namedItem("APIMODE").value = "CREST";
		
		if(log >= 3){
			console.log("overwrite crest default settings with: " 
				+ get_url_param('cresturl') 
				+ " / " 
				+ get_url_param('crestport'));
		}
	}


	/////////////////////////////////////
	// Event Handler
	// Dropdown API
	$( ".APIMODE" ).change(function() {

                var str = "";
                $( "select option:selected" ).each(function() {
                      str += $( this ).text();
                });

                APIMODE = str;
        });

	// Event handler for Slider
	$(function() {
		$( "#slider-range-max" ).slider({
			range: "max",
			min: -1000,
			max: 1000,
      			value: DisplayDurationCorrector, 
			step: 25,
      			slide: function( event, ui ) {
        			$( "#amount" ).val( ui.value );
				//set new value
				DisplayDurationCorrector = ui.value;
      			}
    		});
    		$( "#amount" ).val( $( "#slider-range-max" ).slider( "value" ) );
  	});

	// initiate jqGrid for DriverData
	// todo: make table searchable   and  add new Theme
	// todo: add subgrid information like: Long,Lat,RefPoint,...
	jQuery("#tracklisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        width:	790,
	        hiddengrid: true,
	        colNames:['ID','TrackID','TrackName','Max Gridsize', 'RefPoints exists?','Comment'],
	        colModel:[
					{name:'id', index:'id', formatter: 'integer', width:45, sorttype:"int"},
					{name:'trackid', index:'trackid', width:80, sorttype:"int"},
					{name:'trackname', index: 'trackname', width:240, sorttype:"text"},
					{name:'gridsize', width:50, align:"center", sorttype:"text"},
					{name:'refpoint', width:70, align:"center", sorttype:"text"},
					{name:'comment', width:250, align:"left", sorttype:"text"},
	        ],
		caption: "List of available Tracks",
		rowNum: 200,
		//rowList:[10,20,30],
		//pager: 'pager_tracklisttable',
	});
			
	// add filter option bar
	jQuery("#tracklisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });

	// initial data for grid !!! Needed because of Refresh problem !!
	// todo: really needed ?
	jQuery("#tracklisttable").jqGrid('addRowData',0,{	
								id: 		0
								,trackid:	"2" 
								,trackname:	"initialdata2"
								,gridsize:	"-"
								,refpoint:	"no"
								,comment:	"test comment" 
							});
	
	// add StopRefresh Table button in jqgrid header
	//Method with checkbox
	//$('#TrackList span.ui-jqgrid-title').after(' | Stop refresh table:<input type="checkbox" id="cbTracklistRefresh"/>');
	//Method with Button
	jQuery('#tracklisttable').setCaption('List of available Tracks&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Stop automatic refresh of table" id="cbTracklistRefresh" value="Stop" style="background-color:#dddddd"></input>');


	// car lis overview
	jQuery("#carlisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        hiddengrid: true,
	        colNames:['ID','CarName','class','Set1', 'Set2','Comment'],
	        colModel:[
					{name:'vehicleid', 	width:100, 	sorttype:"float",align:"left", index:'id', formatter: 'float'},
					{name:'name', 		width:100, 	sorttype:"text"},
					{name:'cls',  		width:200, 	sorttype:"text"},
					{name:'set1', 		width:40, 	sorttype:"text", align:"right"},
					{name:'set2', 		width:90, 	sorttype:"text", align:"center"},
					{name:'comment', 	width:160, 	sorttype:"text", align:"left"},
	        ],
	        caption: "List of available Cars with properties.",
		rowNum: 200,
	});
	// add filter option bar
	jQuery("#carlisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create worker to get vehicle list
	var workerVEHICLELIST      =       new Worker('./worker_vehiclelist.js');
	
	workerVEHICLELIST.addEventListener('message', function(e) {
		
		if(log >= 3){console.log('+++++++++++ GETVEHICLELIST Worker returned: e ', e );}
		if ( e.data.avehiclelist.length > 0 ){
			
			aVehicleList	=	e.data.avehiclelist;	//copy the array of vehicle objects to global var
			
			aVehicleIdToName = transformVehicleObjectToHash(aVehicleList);
		
			//display vehicle data in table 
			refreshVehicleList(aVehicleList);
			
			// no additional worker call needed, because needed data available			
			if(log >= 3){console.log('+++++++++++ GETVEHICLELIST Worker stopped and copy data to aVehicleList', aVehicleList );}
			
			
			
		}else{
			
			// no return value from DS, start another run
			if(log >= 3){console.log('+++++++++++ GETVEHICLELIST start new Worker run.' );}
			workerVEHICLELIST.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETVEHICLELIST", arefpoint: aRefPointTMP});
		}
		
	}, false);
	workerVEHICLELIST.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETVEHICLELIST", arefpoint: aRefPointTMP});
	

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create DS data object
	var workerDSDATA      =       new Worker('./worker_dsdata.js');
	sensorLayer_UpdateTime_old = Date.now();	//initialize a value for first time
	//event handler of the worker
	workerDSDATA.addEventListener('message', function(e) {
		
		if(log >= 3){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: ', e);}
                
		// write in HTML page for DS status
		document.getElementsByTagName('p0')[0].innerHTML = 'DS URL:   		' + DsServerURL + " : " +  DsPort; 
		document.getElementsByTagName('p1')[0].innerHTML = 'DS Status:   	' + e.data.globals.state;
		document.getElementsByTagName('p2')[0].innerHTML = 'DS Joinable: 	' + e.data.globals.joinable;
		document.getElementsByTagName('p3')[0].innerHTML = 'DS Lobby ID: 	' + e.data.globals.lobbyid;
		document.getElementsByTagName('p4')[0].innerHTML = 'DS now:      	' + e.data.globals.now; 
		document.getElementsByTagName('p5')[0].innerHTML = 'used API type:	' + APIMODE;
		document.getElementsByTagName('p6')[0].innerHTML = 'Display Duration:      ' + DisplayDuration;
		document.getElementsByTagName('p7')[0].innerHTML = 'TrackName:     	' + e.data.arefpoint[e.data.globals.attributes.TrackId]["Name"];		
		document.getElementsByTagName('p8')[0].innerHTML = 'SessionStage:   ' + e.data.globals.attributes.SessionStage;
		document.getElementsByTagName('p9')[0].innerHTML = 'SessionState:   ' + e.data.globals.attributes.SessionState;
		
		//todo:  replace document.get... by Jquery functionality
		//$('#DSdataInformation').append( 
		//				$("<p0>").text("DS URL2: " + DsServerURL + " : " +  DsPort)
		//);
		
		
		/////////////////////////////////////////// update driver data /////////////////////
		// refresh table of Driver data
        refreshDriverList(e.data.driverlist);
		
		//todo var declaration needed within loop ???
		var tmpcuircitID;
		
		SessionState = e.data.globals.attributes.SessionState;

		if (SessionState_old != "Loading" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}  //Hide markers on Loading / before calculation, unhide is after calculation.
                //if (SessionState_old == "Lobby" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}    //Hide markers before calculation, unhide is after calculation.
                //if (SessionState_old == "" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}         //Hide if you open the website during "Loading"
		//if (SessionState_old == "NA" && SessionState == "Loading"){CSSClassChanger.HideAllSvg();}       //Hide if you switch receivemodes, because the default SessionState = "NA"
		
		//update map
		for (var i = 0; i < e.data.driverlist.length; i++ ){

				//calculate GPS coordinates
				gpsCoTmp =  calc_coordinates (cuircitID , e.data.driverlist[i].PosX , e.data.driverlist[i].PosZ , e.data.arefpoint);

				if(log >= 3){console.log('+++++++++++ DriverData Array  ', e.data.driverlist);}
				
				//cast object type because losing while webworker transfer
				e.data.driverlist[i].__proto__ = PCARSdriver.prototype;
				
				//fill data array
				aSensorData[i] = {
						"Key": 				e.data.driverlist[i].Name
						,"MarkerLabel" :	e.data.driverlist[i].RacePosition + "-" + e.data.driverlist[i].Name
						,"DateTime":		"2013-09-04T09:41:09+10:00"
						,"Lat": 			gpsCoTmp["Lat"]
						,"Long": 			gpsCoTmp["Long"]
						,"Heading":			286.0
						,"Speed":			e.data.driverlist[i].Speed
						,"CSSTextClasses":	e.data.driverlist[i].GetCSSTextClass()
						,"CSSCircleClasses":	e.data.driverlist[i].GetCSSCircleClass()
				}
				
        		tmpcuircitID = e.data.driverlist[i].variousParameters.TrackId;
        		//if(log >= 2){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: PosX:' + e.data.driverlist[i].PosX + ", Speed:" + e.data.driverlist[i].Speed);}	//analyzing problem with asynchronous marker updates
		}
		
        sensorLayer_UpdateTime = Date.now();
		sensorLayer_UpdateDelta = sensorLayer_UpdateTime - sensorLayer_UpdateTime_old;	//Determine time duration between recent and currrent worker run
		sensorLayer_UpdateTime_old = sensorLayer_UpdateTime;
		if(log >= 2){console.log("+++++++++Sensor Update Delta:",sensorLayer_UpdateDelta);}
                
		//Calculation of dynamic DisplayDuration
		if ((APIMODE == "DS" || APIMODE == "DEMO") && sensorLayer_UpdateDelta < UpdateRateDS) {
				DisplayDuration = UpdateRateDS + DisplayDurationCorrector       //If the worker runs more often than the data is updated in the DS API, then the duration is set to the DS update rate
		}else{
				DisplayDuration = sensorLayer_UpdateDelta  + DisplayDurationCorrector;
		}
		if (DisplayDuration < 0) { DisplayDuration = 0 }        //catch a negative value
		if (DisplayDuration > 2000) { DisplayDuration = 2000 }	// set a max DisplayDuration
		if(log >= 2){console.log("+++++++++DisplayDuration:    ",DisplayDuration);}
                
		if(log >= 3){console.log("++++++++ aSensorData_NEW" , aSensorData);}
		sensorLayer.update(aSensorData);

		// in case track changes on DS adjust the map settings for new possition
        if ( (cuircitID != tmpcuircitID) && ( typeof tmpcuircitID != 'undefined') ){

        	//if(log >= 3){console.log("----------- TrackID SHOULDbe changed: ", aRefPointTMP);}
            //map.setCenter({lat: 50.332733, lng: 6.943355});
			changeMapSettings(e.data.arefpoint[tmpcuircitID] , map);

            cuircitID = tmpcuircitID;  // give the global var the new TrackId
            if(log >= 3){console.log("----------- TrackID changed. Call map.SetCenter(),  cuircitID / tmpcuircitID " + cuircitID + " / " + tmpcuircitID);}
		}
		
		if (SessionState_old != "Race" && SessionState == "Race"){   //Unhide markers after calculation, with a delay of 1000 ms
                        UnHide = "true";
                }
                if (UnHide == "true"){
                        UnHide_Timer = UnHide_Timer + sensorLayer_UpdateDelta;
                        if (UnHide_Timer > 1000){
                        	StopTransitionDelay = "true";
                                sensorLayer.interruptTransition();
                                sensorLayer.update(aSensorData);
                                CSSClassChanger.UnHideAllSvg();
                                UnHide_Timer = 0;
                                UnHide = "false";
                                if(log >= 2){console.log("+++++++++UnHide StopTransitionDelay:    ",StopTransitionDelay);}
                        }
                }
                SessionState_old = SessionState;

		if (recording_demo_data == "true"){
                        console.log("           {//" + recording_count);
                        console.log("                globals:{sensorLayer_UpdateDelta:"+sensorLayer_UpdateDelta+", state:\""+e.data.globals.state+"\", name:\""+e.data.globals.name+"\", lobbyid:"+e.data.globals.lobbyid+", joinable:\""+e.data.globals.joinable+"\", max_member_count:"+e.data.globals.max_member_count+", now:"+e.data.globals.now+", attributes:{TrackId:"+e.data.globals.attributes.TrackId+", SessionState:\""+e.data.globals.attributes.SessionState+"\", SessionStage:\""+e.data.globals.attributes.SessionStage+"\", GridSize:"+e.data.globals.attributes.GridSize+", MaxPlayers:"+e.data.globals.attributes.MaxPlayers+"}},");
                        console.log("                participants:[");
                        for (var i = 0; i < e.data.driverlist.length; i++ ){
                                if ((i+1) == e.data.driverlist.length){
                                        console.log("                        {RefId:\""+e.data.driverlist[i].RefID+"\", Name:\""+e.data.driverlist[i].Name+"\", IsPlayer:"+e.data.driverlist[i].IsPlayer+", GridPosition:\""+e.data.driverlist[i].GridPosition+"\", VehicleId:"+e.data.driverlist[i].VehicleId+", RacePosition:"+e.data.driverlist[i].RacePosition+", CurrentLap:"+e.data.driverlist[i].CurrentLap+", CurrentSector:"+e.data.driverlist[i].CurrentSector+", LastLapTime:"+e.data.driverlist[i].LastLapTime+", FastestLapTime:"+e.data.driverlist[i].FastestLapTime+", State:\""+e.data.driverlist[i].State+"\", Speed:"+e.data.driverlist[i].Speed+", PositionX:"+e.data.driverlist[i].PosX+", PositionY:"+e.data.driverlist[i].PosY+", PositionZ:"+e.data.driverlist[i].PosZ+", Orientation:"+e.data.driverlist[i].Orientation+"}");
                                }else{
                                        console.log("                        {RefId:\""+e.data.driverlist[i].RefID+"\", Name:\""+e.data.driverlist[i].Name+"\", IsPlayer:"+e.data.driverlist[i].IsPlayer+", GridPosition:\""+e.data.driverlist[i].GridPosition+"\", VehicleId:"+e.data.driverlist[i].VehicleId+", RacePosition:"+e.data.driverlist[i].RacePosition+", CurrentLap:"+e.data.driverlist[i].CurrentLap+", CurrentSector:"+e.data.driverlist[i].CurrentSector+", LastLapTime:"+e.data.driverlist[i].LastLapTime+", FastestLapTime:"+e.data.driverlist[i].FastestLapTime+", State:\""+e.data.driverlist[i].State+"\", Speed:"+e.data.driverlist[i].Speed+", PositionX:"+e.data.driverlist[i].PosX+", PositionY:"+e.data.driverlist[i].PosY+", PositionZ:"+e.data.driverlist[i].PosZ+", Orientation:"+e.data.driverlist[i].Orientation+"},");
                                }
                        }
                        console.log("                ]");
                        console.log("        },");
                        recording_count = recording_count + 1;
                }
		
		//call worker again for next itteration -> currently endless loop
		if (APIMODE == "DS"){
			//DS receive mode
			workerDSDATA.postMessage({
				workerdelay: 		WORKERDELAY_DSDATA
				,dsurl:			DsServerURL
				,dsport:		DsPort
				,timeout:		XMLHTTPTimeout
				,receivemode:	"GETDSANDDRIVERDATA"
				,arefpoint:		e.data.arefpoint});
		}
		if (APIMODE == "CREST"){
			//CREST receive mode
			workerDSDATA.postMessage({
				workerdelay: 		WORKERDELAY_DSDATA
				,dsurl:			CRESTServerURL
				,dsport:		CRESTPort
				,timeout:		XMLHTTPTimeout
				,receivemode:	"GETCRESTDRIVERDATA"
				,arefpoint:		e.data.arefpoint});
		}
		if (APIMODE == "DEMO"){
                        //DEMO receive mode

                        //Calculation of WORKERDELAY_DEMODATA to adapt the playback speed to the recording speed
                        //The record_pos is the array element of the recorded data and correlates to one worker run. Each element includes the sensorLayer_UpdateDelta. This is the time between the last and the current worker run. Now we calculate the WORKERDELAY_DEMODATA, which is the delay to the next worker run. Because of that we need the sensorLayer_UpdateDelta of the next array element and not of the current.
                        record_pos_helper = record_pos + 1;
                        if(record_pos_helper > demo.length-1){record_pos_helper = 0;}	//if last array element with record_pos is reached, record_pos_helper exceeds the upper array boundary. In this case the helper jumps to the first array element
                        
                        sensorLayer_UpdateDelta_DEMOdiff = demo[record_pos_helper].globals.sensorLayer_UpdateDelta - sensorLayer_UpdateDelta;	//diff time between recorded data and playback sensorLayer_UpdateDelta
                        WORKERDELAY_DEMODATA = WORKERDELAY_DEMODATA + sensorLayer_UpdateDelta_DEMOdiff;		//adapt playback speed to recorded data with the worker delay
                        if(WORKERDELAY_DEMODATA < 0){WORKERDELAY_DEMODATA = 0;} //catch negative values. If the playback machine is to slow and is not able to hold the playback speed of the recording machine, then the delay is calculated negative, but the delay must be positive
                        if(log >= 2){console.log("Demo Delta: ",demo[record_pos].globals.sensorLayer_UpdateDelta,", cur Delta: ",sensorLayer_UpdateDelta, "diff: ", sensorLayer_UpdateDelta_DEMOdiff, "Delay: ", WORKERDELAY_DEMODATA);}

                        workerDSDATA.postMessage({
                                workerdelay:            WORKERDELAY_DEMODATA
                                ,dsurl:                 ""
                                ,dsport:                0
                                ,timeout:               record_pos
                                ,receivemode:   "GETDEMODATA"
                                ,arefpoint:             e.data.arefpoint});
                        record_pos = record_pos + 1;
                        if(record_pos > demo.length-1 || record_pos > demo_end_pos-1){record_pos = demo_start_pos;}     //jump to beginning id end of array or demo_end_pos is reached/ -1, because the array begins with 0
                }
	}, false);
	
	//initail call of the worker
	workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// receive data from pcars dedicated server (DS) and returns an array of PCARSdriver objects
	//	   Receive_DS_data(url,port,timeout,RetrivelMode)
	// initial call for map initialization
	if (APIMODE == "DS"){
                aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
        }
        if (APIMODE == "CREST"){
                aDrivers = Receive_DS_data(CRESTServerURL, CRESTPort, 2000, "GETCRESTDRIVERDATA", aRefPointTMP);
        }
        if (APIMODE == "DEMO"){
                aDrivers = Receive_DS_data("", 0, record_pos, "GETDEMODATA", aRefPointTMP);
                cuircitID = aDrivers.globals.attributes.TrackId;
        }
        
        for (var i = 0; i < aDrivers.driverlist.length; i++ ){

                // calculate GPS coordinates
                gpsCoTmp =  calc_coordinates (cuircitID , aDrivers.driverlist[i].GetPosX() , aDrivers.driverlist[i].GetPosZ() , aRefPointTMP );

                // fill data array
                aSensorData[i] = {
                                "Key":                          aDrivers.driverlist[i].GetName()
                                ,"MarkerLabel" :        buildDriverName ( aDrivers.driverlist[i].GetRacePosition(), aDrivers.driverlist[i].GetName() )
                                ,"DateTime":            "2013-09-04T09:41:09+10:00"
                                ,"Lat":                         gpsCoTmp["Lat"]
                                ,"Long":                        gpsCoTmp["Long"]
                                ,"Heading":                     286.0
                                ,"Speed":                       aDrivers.driverlist[i].Speed
                                ,"CSSTextClasses":      aDrivers.driverlist[i].GetCSSTextClass()
                                ,"CSSCircleClasses":    aDrivers.driverlist[i].GetCSSCircleClass()
                }
                // bookmark current TrackID to detect track changes and adjust Map
                tmpcuircitID = aDrivers.driverlist[i].GetVariousParameter("TrackId");
        }

	// init google map
	init_map(cuircitID , aRefPointTMP);

	// add map Listener
	map.addListener('zoom_changed', function() {
		if(log >= 3){console.log("+++++++++++++++++++++++++++++++++++++++++++ current StopTransitionDelay: " , StopTransitionDelay);}
        	StopTransitionDelay = "true";
        	StopTransitionDelay_StartTime = Date.now();
        	sensorLayer.interruptTransition();
        	sensorLayer.update(aSensorData);
		if(log >= 3){console.log("+++++++++++++++++++++++++++++++++++++++++++ set StopTransitionDelay to: " + StopTransitionDelay + ", StopTransitionDelay_StartTime:" + StopTransitionDelay_StartTime);}
  	});

	// create Table with list of all tracks
	// checkbox Event handling
	$('#cbTracklistRefresh').click(function () {

		/* Method with checkbox
		if ($('#cbTracklistRefresh').is(':checked') == true) {
			StopRefreshTracklist 	= "true";
			WORKERDELAY_TRACKLIST 	= 10000;
		}else{
			StopRefreshTracklist 	= "false";
			WORKERDELAY_TRACKLIST	= 5000;
		}*/
		//Method with button
		var self = this;
                changeRefreshTracklist(self);
                
	});
	
	function changeRefreshTracklist(data){
                if(data.value === "Stop"){
                        StopRefreshTracklist    = "true";
                        WORKERDELAY_TRACKLIST   = 10000;
                        data.value = "Start";
                        data.title = "Start automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshTracklist    = "false";
                        WORKERDELAY_TRACKLIST   = 5000;
                        data.value = "Stop";
                        data.title = "Stop automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
        }


	// create worker for Tracklist updates //////////////////////////////////////////////////////////////////////
	var w_tracklist      =       new Worker('./worker_tracklist.js');
	
	w_tracklist.addEventListener('message', function(e) {

			if(log >= 3){console.log("+++++++++++ GETTRACKLIST Worker Trackliste Event: ", e );}
					
		//	var str = e.data;	// data string from return object

			refreshTrackList(buildTracklist(e.data.aTrack , e.data.aRefpoint ));
			w_tracklist.postMessage({
								workerdelay: 	WORKERDELAY_TRACKLIST
								,dsurl: 		DsServerURL
								,dsport: 		DsPort
								,timeout: 		2000
								,receivemode: 	"GETTRACKLIST" 
								,aRefpoint:		e.data.aRefpoint});
	}, false);
	
	//initial call of the tracklist worker. initiate endless loop
	w_tracklist.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETTRACKLIST", aRefpoint: aRefPointTMP });



	//todo: add subgrid for more drivers information
	jQuery("#DriverDataTable").jqGrid({
                datatype: "local",
                height: 'auto',
		width: 800,
		hiddengrid: true,
		rowNum: 200,
		caption: "List of available drivers",
                colNames:['RefID','Pos', 'Driver Name', 'State', 'Sector', 'Lap', 'Vehicle', 'fastest lap', 'last lap','Hu/AI','PosX', 'PosY', 'PosZ' ],
                colModel:[
                        {name:'refid',hidden: true, index:'invdate', width:40, sorttype:"int"},
                        {name:'driverposition', width:18, sorttype:"int", search:true},
                        {name:'drivername', width:80,sorttype:"text", search:true},
                        {name:'driverstate',width:40, align:"center",sorttype:"text"},
                        {name:'driversector',width:20, align:"center",sorttype:"int"},
                        {name:'lapnumber',width:18, align:"center",sorttype:"int"},
                        {name:'vehiclename',width:40, align:"center",sorttype:"text"},
                        {name:'fastestlap',width:35, align:"center",sorttype:"text"},
                        {name:'lastlap',width:35, align:"center",sorttype:"text"},
                        {name:'isplayer',width:15, align:"center",sorttype:"text"},
                        {name:'posx',hidden: true,width:20, align:"center",sorttype:"float"},
                        {name:'posy',hidden: true,width:20, align:"center",sorttype:"float"},
                        {name:'posz',hidden: true,width:20, align:"center",sorttype:"float"}
                ]
	});
	
	// add filter option bar
	jQuery("#DriverDataTable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	// sort driver table on startup
	jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
	// add StopRefresh Table button in jqgrid header
	//Method with checkbox
	//$('#DriverDataArea span.ui-jqgrid-title').after(' | Stop refresh table:<input type="checkbox" id="cbDriverlistRefresh"/>');
	//Method with Button
	jQuery('#DriverDataTable').setCaption('List of available drivers&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Stop automatic refresh of table" id="cbDriverlistRefresh" value="Stop" style="background-color:#dddddd"></input>');
			
	// checkbox Event handling
        $('#cbDriverlistRefresh').click(function () {

                /* Method with checkbox
                if ($('#cbDriverlistRefresh').is(':checked') == true) {
                        StopRefreshDriverlist   = "true";
                }else{
                        StopRefreshDriverlist  	= "false";
                }*/
                //Method with Button
                var self = this;
                changeRefreshDriverlist(self);
                                                
        });
        
        function changeRefreshDriverlist(data){
                if(data.value === "Stop"){
                        StopRefreshDriverlist   = "true";
                        data.value = "Start";
                        data.title = "Start automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshDriverlist  	= "false";
                        data.value = "Stop";
                        data.title = "Stop automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
        }

	 
        
	// setting up google maps overlays
	function GPSSensor(initData) {
               //state information
               var _div = null;
               var _data = initData;
               var _projection = null;

               function transform(d) {
                   var padding = 10;                   
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this) 
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }
               
               function transformWithEase(d) {
                   var padding = 10;
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this)
                       .transition().duration(DisplayDuration)
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }

               //superclass methods for google maps
               this.onAdd = function() {
                   _div = d3.select(this.getPanes().overlayLayer)
                            .append("div")
                            .attr("class", "stations");
               };               
                              
               this.draw = function () {                   
                   var padding = 10;
                   _projection = this.getProjection();
		  
		  /* complete block moved to update function
                   var marker = _div.selectAll("svg")
                       .data(_data, function (d) { return d.Key; })
                       .each(transform) // update existing markers
                        .enter().append("svg:svg")
                       .each(transform)
                       //.attr("class", "marker");
                   		.attr("class", function (d){ return d.CSSTextClasses });
           
                   
		   		   //if(log >= 3){console.log("++ Marker" , marker);}

                   // Add a circle.
                   marker.append("svg:circle") 
                       .attr("r", 4.5)
                       .attr("cx", padding)
                       .attr("cy", padding)
                       .attr("class", function (d){ return d.CSSCircleClasses } );
		       		   //.style("fill", "red");

					//todo experimental method call	
					//marker.text("test123456");	
					if(log >= 3){console.log("Marker: " , marker);}
		

                   // Add a label.
					if(log >= 3){console.log ("++++ in function draw() ->  aSensorData: " , aSensorData);}
                   marker.append("svg:text")
                       .attr("x", padding + 7)
                       .attr("y", padding)
                       .attr("dy", ".31em")
			//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
			//      it seem that the function within .text(...) will called only once at the beginning 
			//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
		       .text(function (d) {
						//if(log >= 4){console.log("+++++ d: " , d );}
						//if(log >= 4){console.log("+++++ this: " , this );}

						for (var i = 0; i < aSensorData.length; i++){
						
							//if(log >= 4){console.log(" for Update MarkerLabel:" , aSensorData);}
							if (aSensorData[i].Key == d.Key){
								if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
								return  aSensorData[i].MarkerLabel;
							}
						}
						
						//todo: during update d is not an array its an individual hash
						//if(log >= 3){console.log("++++not array:");}
						return d.MarkerLabel;
						
					})
               //       .text(function (d) { return d.Key; });                                      
               */
               };

               this.onRemove = function () {
                   _div.remove();
               };


               // todo: known issue: Beim Wechsel der Position, bleibt eine "Leiche" auf der Karte uebrig, weil Key "Pos - Name" zusammensetzt
               // easyt solution:  deleting leading position number 
               this.update = function (data) {     
			
					//update internal data which drive redrawing on zoom_changed                  
					var marker;
					var padding = 10;
					                    				
					for (var i = 0; i < data.length; i++) {

	                       var found = false;
	                       for (var j = 0; j < _data.length; j++) {
	                           if (_data[j].Key === data[i].Key) {
									found = true;
									_data[j].Lat = data[i].Lat;
									_data[j].Long = data[i].Long;
									_data[j].MarkerLabel = data[i].MarkerLabel;
									//	if(log >= 3){console.log("---12 _data changes for key:" + _data[j].Key + " // " + data[i].Key);}
	                           }
	                       }
	                       if (!found)
	                           _data.push(data[i]);
	                   }

			   //todo: what does this draw() call ?
			   //if(log >= 3){console.log ("THIS Updated data:" , _data);}
			   //if(log >= 3){console.log ("THIS:" , this);}
			   
			   //Detect time between StopTransitionDelay set to "true" and now
			   var CurrentTime = Date.now();
			   var StopTransitionDelay_TimeRun = CurrentTime - StopTransitionDelay_StartTime;

			   if( StopTransitionDelay == "true" )
			   {
				if(log >= 3){console.log ("++++++++++++++++++++++++++++++ stopped StopTransitionDelay: " + StopTransitionDelay + " , TimeRun:" + StopTransitionDelay_TimeRun);}
				//this.draw();
                                   /*_div.selectAll("svg")
                                       .data(_data, function (d) { return d.Key; })
                                       .each(transform);*/
				 marker = _div.selectAll("svg")
					.data(_data, function (d) { return d.Key; })
					.each(transform) // update existing markers
					.enter().append("svg:svg")
					.each(transform)
					//.attr("class", "marker");
					.attr("class", function (d){ return d.CSSTextClasses });

				// reset to default after zoom event finished. 
				//A zoom change in Google Maps takes some time. If the worker runs have a short interval you need a minimum time where the transformWithEase have to be interrupted
                                if (StopTransitionDelay_TimeRun > StopTransitionDelay_minTimeRun) {StopTransitionDelay = "false";}
			
			   }else{

				if(log >= 3){console.log ("++++++++++++++++++++++++++++++ normal StopTransitionDelay: " , StopTransitionDelay );}
		                   //this.draw();
		                   /*_div.selectAll("svg")
		                       .data(_data, function (d) { return d.Key; }) 
		                       .each(transformWithEase);*/
				 marker = _div.selectAll("svg")
					.data(_data, function (d) { return d.Key; })
					.each(transformWithEase) // update existing markers
					.enter().append("svg:svg")
					.each(transform)
					//.attr("class", "marker");
					.attr("class", function (d){ return d.CSSTextClasses });

				// reset to default after zoom event finished
				//StopTransitionDelay = "false";
			   }		 
			// Add a circle.
			marker.append("svg:circle")
				.attr("r", 4.5)
				.attr("cx", padding)
				.attr("cy", padding)
				.attr("class", function (d){ return d.CSSCircleClasses } );
				//.style("fill", "red");

			//todo experimental method call
			//marker.text("test123456");
			if(log >= 3){console.log("Marker: " , marker);}


			// Add a label.
			marker.append("svg:text")
				.attr("x", padding + 7)
				.attr("y", padding)
				.attr("dy", ".31em")
				//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
				//      it seem that the function within .text(...) will called only once at the beginning
				//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
				.text(function (d) {
					if(log >= 4){console.log("+++++ d: " , d );}
					//if(log >= 4){console.log("+++++ this: " , this );}

					for (var i = 0; i < aSensorData.length; i++){
						if (aSensorData[i].Key == d.Key){
						if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
						return  aSensorData[i].MarkerLabel;
						}
					}

					//todo: during update d is not an array its an individual hash
					//if(log >= 3){console.log("++++not array:");}
					return d.MarkerLabel;

				})
	
								
			}; //end update()
              

			this.interruptTransition = function (){
                        _div.selectAll("svg")
                                .interrupt();
            }; // end interruptTransition()
            
          }


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////				
//////////////////////////////////////////////////////////////////////////
function init_map(_TrackID , aRefPoint)
{
	
           //subclassing
           GPSSensor.prototype = new google.maps.OverlayView();


           // Create the Google Map
           map = new google.maps.Map(d3.select("#map").node(), {
               zoom: aRefPoint[cuircitID]["Zoom"],

                // use cuircit RefPoint for center google map
                center: new google.maps.LatLng( aRefPoint[_TrackID]["MapInitLat"] , aRefPoint[_TrackID]["MapInitLong"] ),
                mapTypeId: google.maps.MapTypeId.SATELLITE
           });

           //if(log >= 3){console.log("-+-+- aSensorData-Array: ", aSensorData);}
           sensorLayer = new GPSSensor(aSensorData);
           sensorLayer.setMap(map);
}

function changeMapSettings(newTrackObj, mapobj)
{
	if(log >= 3){console.log("----- call function changeMapSettings() with track data: " , newTrackObj );}
	if(log >= 3){console.log("----- call function changeMapSettings() with map data: " , mapobj );}

	//todo: replace map (global variable) with mapobj(if this is not a copy)
	//example: map.setCenter({lat: 50.332733, lng: 6.943355});
        map.setCenter({lat: newTrackObj["MapInitLat"], lng: newTrackObj["MapInitLong"]});

        map.setZoom(newTrackObj["Zoom"]);

	StopTransitionDelay = "true";
	StopTransitionDelay_StartTime = Date.now();

	//todo: change also picture Overlay prevered mapsourc(google,openstreetmap) in needed
        return 1;
}

///////////////////
function refreshTrackList(a)
{
	if(log >= 3){console.log("------------------------ refreshTrackList() parameter a : " , a);}

	// if set to true, no refresh of table wanted
	if (StopRefreshTracklist == "true")
	{
		if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshTracklist set to:", StopRefreshTracklist );}
		return 1;
	}

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#tracklisttable").jqGrid("clearGridData");

	var gridcnt = 0;
	var _data;

	
	for (var key in a ){

		//if(log >= 3){console.log("--- Info for loop value a[key]: ", a[key]);}
		_data = {
                                        id:             gridcnt
                                        ,trackid:       a[key]["trackid"]
                                        ,trackname:     a[key]["trackname"]
                                        ,gridsize:      a[key]["gridsize"]
                                        ,refpoint:      a[key]["refpoint"]
                                        ,comment:       a[key]["comment"]
                                };		
		jQuery("#tracklisttable").jqGrid('addRowData',gridcnt, _data);

		gridcnt++
	}

	// relaod data into jqGrid
	jQuery("#tracklisttable").trigger("reloadGrid");
	
}

//fill
function refreshVehicleList(a)
{
	var _data;
	
	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#carlisttable").jqGrid("clearGridData");	
	
	
	for (i=0; i < a.length; i++)
	{
	
		_data = {
   					vehicleid:	a[i].vehicleid,
					name:		a[i].name,
					cls:		a[i].cls,
					set1:		"-",
					set2:		"-",
					comment:	"-"
				};
		
		jQuery("#carlisttable").jqGrid('addRowData',i, _data);
	}
	
	
	return 1;
		
}

//////////////////
function refreshDriverList(a)
{
	// if set to true, no refresh of table wanted
        if (StopRefreshDriverlist == "true")
        {
                if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshDriverlist set to:", StopRefreshDriverlist );}
                return 1;
        }

	if(log >= 3){console.log("refreshDriverList(e): " , a);}

	var _data;
	var _allDrivers = new Array();

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#DriverDataTable").jqGrid("clearGridData");	

        // get current size of the table
        var GridSize = jQuery("#DriverDataTable").getGridParam("reccount");	


	//todo: if drivertable is longer then new driverlist, all old values should be deleted
	//todo: if clearGridData method is working, no need for a decision if use setRowData or addRowData !
	for (i=0; i < a.length; i++)
	{
		//if(log >= 3){console.log("update data on row: " + i + " / " + a.data[i]);}
		_data = {   
					refid:				a[i].RefID
					,driverposition:	a[i].RacePosition	
					,drivername:		a[i].Name
					,driverstate:		a[i].State
					,driversector:		a[i].CurrentSector
					,lapnumber:			a[i].CurrentLap
					,vehiclename:		VehicleIdToName(a[i].VehicleId , aVehicleIdToName)
					,fastestlap:		PCARSd.GetFastestLapTime(  a[i].FastestLapTime )
					,lastlap:			PCARSd.GetLastLapTime(  a[i].LastLapTime )
					,isplayer:			ConvertIsPlayer(a[i].IsPlayer)
					,posx:				a[i].PosX
					,posy:				a[i].PosY
					,posz:				a[i].PosZ
		};
		//decision if replace or add a row to jqGrid
		if (i < GridSize){
				jQuery("#DriverDataTable").jqGrid('setRowData',i, _data);
				//if(log >= 3){console.log("+++++ set " + i );}
		}else{
				jQuery("#DriverDataTable").jqGrid('addRowData',i, _data);
				//if(log >= 3){console.log("+++++ add " + i );}
		}
	
		//build hash for clean up map	
		_allDrivers[buildDriverName(a[i].Name, a[i].RacePosition)] =  {driverposition : a[i].RacePosition};

	}

	jQuery("#DriverDataTable").trigger("reloadGrid");

	CleanupDriverObjects(_allDrivers);

	return 1;
}

function buildDriverName(drivername , raceposition)
{
	// Diego Xavier on race position 5 => "5-Diego Xavier"
	return raceposition + "-" + drivername;
}

function CleanupDriverObjects(allDrivers)
{
	//if(log >= 3){console.log("---------- Call function CleanupDriverObjects() with driver list ----" , allDrivers );}
	
	var svgs = 	d3.selectAll("svg")
			.each(function( obj ) {
				if(log >= 3){console.log("---------- svg object this:" , this );}
		
				if ( allDrivers[this.textContent] === undefined )
				{
					if(log >= 3){console.log("------- Ghost car found and delete it from map (this.textContent): " , this.textContent);}
					//todo: delete ghost cars from map via D3 functions
					this.remove();
				}
			});
	//todo: maybe add an additional routine for cleaning up Driver names

        return 1;
}


function transformVehicleObjectToHash(a){
	
	var hash = new Array();
	
	if(log >= 3){console.log("------- transformVehicleObjectToHash() for a : " , a)};
	
	for (var i=0; i < a.length; i++){
		
		// '' + a[i].vehicleid -> needed to convert negative numbers to string
		hash[ '' + a[i].vehicleid ] = a[i].name;
		//if(log >= 5){console.log("------- transformVehicleObjectToHash(), VehicleID/Name: " + a[i].vehicleid + " / "+ a[i].name  );}
		
	}
	if(log >= 3){console.log("------- transformVehicleObjectToHash() for hash : " , hash)};
				
	return hash;
}


function VehicleIdToName(id, array){
	
	if (array[id]){
		
		return array[id];
		
	}
	else
	{
		// in the case vehilce IDs not in hash
		if(log >= 3){console.log("------- VehicleIdToName(), vehicle ID unknown: " , id)};
	}
	//if ID not found return id
	return id;
}

function ConvertIsPlayer(bool){
	
	if (bool){
		return "Hu";
	} else {
		return "AI";	
	}
}




///////////////////
function buildTracklist( aTrackList , aRefPoint ){

	if(log >= 3){console.log("--------------------------------- buildTracklist()  aTrackList: " , aTrackList)};
	if(log >= 3){console.log("--------------------------------- buildTracklist()  aRefPoint: " , aRefPoint)};
	
	
	var aRefPointInt = new Refpoint("-1"); // Workaround :-)
	//var aRefPointInt	= aRefPoint.slice(); // copy object to a new one, because the object will be changed
	var commenttmp 		= '';
	var tmpObj;
	var aNewTrackList 	= [];
	var aTmpTracklist	= [];

	// go through all responded tracks from pcars dedicated server
	for (var i=0; i < aTrackList.length; i++)
	{
		tmpObject = aTrackList[i];

		//if refpoint for a track exists
		if (aRefPointInt[tmpObject.trackid]){

			aNewTrackList[tmpObject.trackid] = { 	
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"yes"
				,comment:	aRefPointInt[tmpObject.trackid]["Comment"]
            };

		//no Refpoint entry exists , fill with dummy values
		}else{
			
			aNewTrackList[tmpObject.trackid] = {
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"no"
				,comment:	"no comment because no refpoint"
           };
		}
			
		// delete objects that allready covered by DS output from RefpointArray
		delete aRefPointInt[tmpObject.trackid];
	}
	
	if(log >= 3){console.log("--------------------------------- buildTracklist() aNewTrackList: " , aNewTrackList)};
	
	//fill up with refpoint entries that are not listed in DS array
	for (var key in aRefPointInt ){
		
		//if(log >= 3){console.log("--------------------------------- buildTracklist() aRefPointInt[key]" , aRefPointInt[key] );}

		tmpObject = aRefPointInt[key];

		// check if comment field exists in the RefPoint array
		commenttmp = '';
		if ( 'Comment' in tmpObject ) {  commenttmp = tmpObject["Comment"];  };

		aNewTrackList[key] = {
				trackid:	key
				,trackname:	aRefPointInt[key]["Name"]
				,gridsize:	"no info"
				,refpoint:	"yes"
				,comment:	commenttmp 
		};
	}

	if(log >= 3){console.log("--------------------------------- buildTracklist() with refpoint information:" , aNewTrackList);}

	return aNewTrackList;
}

       </script>
   </body>
</html>

