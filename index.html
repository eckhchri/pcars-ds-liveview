<!DOCTYPE html>
<html lang="de">
  <head>
	<meta charset="utf-8"/>
	<title>Project Cars - live view. (https://github.com/eckhchri/pcars-ds-liveview) </title>	
 
	<!-- static load google maps -->
 	<script type="text/javascript" src="https://maps.google.com/maps/api/js?v=3.exp"></script>
 	<!-- static load google maps with API Key 
 	<script type="text/javascript" src="https://maps.google.com/maps/api/js?v=3.exp&key=___________"></script>
 	 -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.3.3/d3.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/js-url/1.8.6/url.min.js"></script>
	<script src="./lib/FileSaver/FileSaver.js"></script>	
	<script src="./lib/jszip/jszip.min.js"></script>
	<link rel="stylesheet" href="./lib/LapChart/lap-chart.css">
	<script src="./lib/LapChart/lap-chart.js"></script>
	
		
	<link rel="stylesheet" type="text/css" href="./lib/w2ui/w2ui-1.4.3.min.css" />
    <script type="text/javascript" src="./lib/w2ui/w2ui-1.4.3.min.js"></script>
 
 	<link rel="stylesheet" type="text/css" href="./lib/jquery.qtip.custom/jquery.qtip.min.css" />
    <script type="text/javascript" src="./lib/jquery.qtip.custom/jquery.qtip.min.js"></script>
 
 	<!-- CSS definitions moved to folder ./css/ --> 
	<link rel="stylesheet" href="./css/pcars.css">
	<link rel="stylesheet" href="./css/w2ui.css">
	<link rel="stylesheet" href="./css/font-awesome.min.css">
	
 		
	<!-- Jquery UI needed for jTable and the function dragable/resize-->
	<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
	<script src="http://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>

	<!-- The jqGrid language file code-->
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/css/ui.jqgrid.css">
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/i18n/grid.locale-de.js"></script>
	<!-- The atual jqGrid code -->
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/jquery.jqGrid.src.js"></script>

	<script src="./config.js" charset="utf-8"></script>
	<script src="./pcars_driver.js" charset="utf-8"></script>
	<script src="./pcars_track.js" charset="utf-8"></script>
	<script src="./pcars_vehicle.js" charset="utf-8"></script>
	<script src="./pcars_vehiclelist.js" charset="utf-8"></script>
	<script src="./pcars_html_controls.js" charset="utf-8"></script>	
	<script src="./receive_ds_data.js" charset="utf-8"></script>
	<script src="./calc_coordinates.js" charset="utf-8"></script>
	<script src="./class_reference_points.js" charset="utf-8"></script>
	<script src="./css_classchanger.js" charset="utf-8"></script>
	<script src="./pcars_recorder.js" charset="utf-8"></script>	
		
   </head>
  <body>
   
	<!-- W2UI Toolbar top -->
	<div id="toolbar" style="padding: 4px; border: 1px solid silver; border-radius: 3px"></div>
	
	<div id="map">Google Maps.</div>
		
	<!--  -->		   
	<div id="DSstatistic" class="mapoverlay">
		Todo: Statistiken
		After implement a kind of recording Race Data, show some statistics of that.
		1st places, number of laps, common race statistics, extracted from pcars_recording.js ... 	
		<div id="chart"></div>	
	</div>
	
	<!-- Replay -->	
	<div id="DSreplay" class="mapoverlay">
		Todo: Replay
	</div>
	
   	<div id="DSdata" class="pcarswindowgrp2">
		<div id="pcars-dsurl"></div>
		<div id="pcars-dsstate"></div>
		<div id="pcars-dsjoinable"></div>
		<div id="pcars-dslobbyid"></div>
		<div id="pcars-dsnow"></div>
		<div id="pcars-trackname"></div>
		<div id="pcars-dssessionstage"></div>
		<div id="pcars-dssessionstate"></div>
		<br>----- Settings ----<br>
		<div id="pcars-apimode"></div>
		<div id="pcars-displayduration"></div>
		<div id="pcars-record_pos"></div>
		
		<div id="DSdataInformation"></div>
		<div id="DSdataSettings"></div>
		<div id="demo_start_pos"></div>
		<div id="demo_end_pos"></div>
		
	</div>
	
   	<!-- definition of data areas, the order of the tables decides which one is in foreground and which in background-->
	<div id="TrackList" class="pcarswindowgrp2">
		<table id="tracklisttable"></table>
		<div id="pager_tracklisttable"></div>
	</div>
	<div id="CarList" class="pcarswindowgrp2">
		<table id="carlisttable"></table>
	</div>
	<div id="DriverDataArea" class="pcarswindowgrp2">
		<table id="DriverDataTable"></table>
	</div>
	

	<div id="DSRecStatistics" class="box">
	<!-- https://www.w3.org/TR/CSS21/tables.html#table-display -->
		<div class="replay_row">
			<div class="box">				
				<div><i class="fa fa-fast-backward fa-2x"></i></div>				
			</div>
			<div class="box">
				<div><i class="fa fa-pause fa-2x"></i></div>
			</div>
			<div class="box">				
				<div><i class="fa fa-play fa-2x"></i></div>				
			</div>			
			<div class="box">
				<div><i class="fa fa-fast-forward fa-2x"></i></div>
			</div>
			<div class="box">				
				<div>loop start pos:</div>
				<div><input name="field_textarea" id="loop_start_pos" type="number" size="4" maxlength="4" style="width: 45px;"/></div>
			</div>			
			<div class="box">
				<div>loop end pos:</div>
				<div><input name="field_textarea" id="loop_end_pos" type="number" size="4" maxlength="4" style="width: 45px;"/></div>
			</div>
			<div class="box">
				<div id="pcars-record_pos"></div>
				<div id="pcars-record_max"></div>
			</div>
		</div>	
		<div class="replay_row">
			<div class="box replay_cell">
				<div>Start Recording:</div>
			</div>
			<div class="box">
				<label class="switch">
					<input type="checkbox" id="btn-start-rec-data">
					<div class="slider round"></div>
				</label>				
			</div>
			<div class="box">
				<div>Export Data:</div>
			</div>			
			<div class="box">
				<button id="btn-export-rec-data" class="btn" onclick="PCARS_Rec.exportDataCompressed('PCARS_DEMO_FILE.pcars')">export</button>
			</div>
			<div class="box">
				<div>load from local File:</div>
			</div>	
			<div class="box">
				<input id="RecFileUploader" type="file" name="Select PCARS File">				
			</div>
			<div class="box">
				<button id="btn-load-demo-file" class="btn" onclick="open_popup_load_demofile();">Load from URL</button>
			</div>
			<div class="box">
				<div>Rec Stats:</div>
			</div>	
			<div class="box">
				<div id="pcars-rec-elemnr" ></div>
				<div id="pcars-rec-elemsize" ></div>		
			</div>				
		</div>
	</div>
	

	<!-- definition of option panel-->	
	<div id="Settings" class="pcarswindowgrp2">
		Settings: <br>

		<!-- API dropdown -->
		<form action="#">
		  <fieldset id="fieldset">
			<label for="APIMODE">Select API Type</label>
	    	<select class="APIMODE" name="APIMODE" id="APIMODE">
	      		<option>DS</option>
	      		<option>CREST</option>
			<option>CREST2</option>
	      		<option>DEMO</option>
			</select>
		</fieldset>
		</form>


		<label for="DRIVERCOLOR">color driver objects</label>
		<select class="DRIVERCOLOR" name="DRIVERCOLOR" id="DRIVERCOLOR">
	    	<option></option>
	    	<option value="hidedrivers">hide-drivers</option>
	    	<option value="unhidedrivers">unhide-drivers</option>
	    	<option value="colortop3">Top 3 vehicles</option>
	    	<option value="colorsamename">same vehicles</option>
	    	<option value="colorsameclass">same classes</option>
	    	<option value="deletecssclasses">reset CSS Classes</option>
		</select>
		
		<br>
		<label for="DRIVERLABELSTYLE">Driverlabel Options</label>
		<select class="DRIVERLABELSTYLE" name="DRIVERLABELSTYLE" id="DRIVERLABELSTYLE">
	    	<option value="normal">Normal Labels</option>
	    	<option value="cutdriverlabel">Cut Labels</option>	    	
		</select>
		
	
		<br>----<br>
  			<label for="amount">WORKERDELAY_DSDATA:</label>
			<input type="text" id="workerdelay_dsdata" readonly style="border:0;">
			<div id="slider-workerdelay_dsdata"></div>			
		<br>----<br>
		<p>
  			<label for="amount">DisplayDurationCorrector:</label>
			<input type="text" id="amount" readonly style="border:0;">
			<div id="slider-range-max"></div>
		</p>		
		<br>----<br>
		<p>
  			<label for="amount">GuiElementUpdateInterval</label>
			<input type="text" id="gui_update_interval" readonly style="border:0;">
			<div id="slider-gui_update_interval"></div>
		</p>

	</div>
<script type="text/javascript" charset="utf-8">

	// initialize vars
	var aDrivers 			=	new Array();		// array for PCARSdriver objects
	var aSensorData 		=	new Array();		// array of Hashes, each hash includes parameters of a driver
	var XMLHTTPTimeout		=	2000;
	var StopTransitionDelay =	"true";	// if set to true, DisplayDuration set to 0 ( cases: zoom, mapchange )
	var StopTransitionDelay_StartTime =	Date.now();	//timestamp for StopTransitionDelay is set to "true"
	var global_i			= 0;
	var map;				// google map object
	var CurGameRunning		=	"PCARS1";   // PCARS1|PCARS2|PCARS2 show the name of the current game is running and should be the same string used PCARSVEHICLELIST.aVehicleInfoExt !
	var sensorLayer;
	var sensorLayer_UpdateTime;		//time, when marker are updated
	var sensorLayer_UpdateTime_old;		//time of the recent dsdata-worker run, when the marker were updated
	var sensorLayer_UpdateDelta;		//time between recent and current dsdata-worker run, when the marker were updated
	var UnHide					= "false";	//UnHide markers
	var UnHide_Timer			= 0;		//Timer for UnHide markers
	var DisplayDurationCorrector =	0;
	var aRefPointTMP			= 	new Refpoint("-1");		// hash of all RefPoints for available tracks		
	
	var StopRefreshTracklist	=	"false";
	var StopRefreshDriverlist	=	"false";
	var SessionState			=	"";
	var SessionState_old		=	"";
	var SessionStage			=	"";
	var SessionStage_old		=	"";
	var HTMLCTRL				=	new HTMLCONTROL(); 	//provide help functions
	//var aVehicleList			=	new Array();			// array of pcars_vehicle.js objects    // commented out on 17.03.2017
	var	PCARSVehicleList		=	new PCARSVEHICLELIST(); // creates an empty object
	//var aVehicleIdToName		=	PCARSVehicleList.getIdToNameMapping();		// hash to translate vehicleID to VehicleName
	var	aCurrentVehicleClasses	=	{};	// all vehicle classes within the current race
	var	aCurrentVehicleNames	=	{};	// all vehicle names within the current race
	var PCARSd					=	new PCARSdriver(); 	// only use the object to get functions of it
	PCARSd.SetExampleData();							// setDefaultValues
	
	var CSSClsChg			=	new CSSClassChanger(CSSDEFINITIONS);	// CSS defined in config.js
	var PCARS_Rec			=	new PCARSRECORDER(aRecConfig);			// initialize PcarsRecording instance	
	var record_pos;						//used for playback of data during DEMO mode
	var record_pos_helper;          	//for WORKERDELAY_DEMODATA calculation needed
	
	var sensorLayer_UpdateDelta_DEMOdiff;	//Difference between sensorLayer_UpdateDelta of the recorded data and the playback
	var WORKERDELAY_DEMODATA = WORKERDELAY_DSDATA;	//Worker delay for DEMO mode to adapt the playback speed to the recording

	// set to global var, to modify in future stage for periodical updates via ajax
	var DsName			=	"-+-"; // aDsData.name;
	var DsState			=	"-+-"; //aDsData.state;		//idle/running
	var DsTrackName		=	"Slightly Mad Studios Ltd";		//aTrackList[aDsData.TrackId];
	var DsMaxMemberCnt	=	"-+-"; //aDsData.max_member_count;
	var cuircitID		=	9999999999;		//aDsData.TrackId;
	
	//PolyLine global vars for trackmaps
	var PolyLineMid		=	null;
	var PolyLineOuter	=	null;
	var PolyLineInner	=	null;
	var PolyLineSF		=	null;
	
	// white background variables for fictional tracks
	var Polygon             =       null;
	var PolygonWorldCoords = [
		{lat: -90       ,lng: -180},
		{lat: 90        ,lng: -180},
		{lat: 90        ,lng: 180},
		{lat: -90       ,lng: 180},
		{lat: -90       ,lng: 0}
	];
	
	// trackmap debug markers for refPoint tuning
        var tm_debug_markers = [];
	
	var zoom_level;         //Google Maps zoom level
	
	// race statistics powered by lapChart library
	var aRacestats			= {};
	aRacestats['drivers']	= {};
	
	var CSVExport = {	//CSV Export Data
		Practice1:	"",
		Practice2:	"",
		Qualifying:	"",
		Warmup:		"",
		Race1:		"",
		Race2:		""
	}
	
	//Trackmap Google GPS coordinates
	var tmGPS = {};
	
	//init array for calculate InClassRacePosition		
	var aInClass;

	//preset HTML elemets
	setParamDemoStartPos(demo_start_pos , true);
	setParamDemoEndPos(demo_end_pos, true);
	// catch demo array boundary breaks
	if(demo_start_pos > demo.length-1 || demo_start_pos < 0){
		setParamDemoStartPos(0 , true);
		//demo_start_pos = 0;
	}
	record_pos = demo_start_pos;
	
	if(demo_end_pos < 0){
		setParamDemoEndPos(9999 , true);
		//demo_end_pos = 0;		
	}
		
	
	// in the case of APIMODE==DEMO, load zipped demo file to variable demo
	if ( APIMODE == "DEMO" && SHOWPOPUPLOADDEMO == "true" ) {			
		open_popup_load_demofile();						
	}
								
	// hide or unhide objects as defined within config.js
	if ( SHOWTRACKLIST 	== false ) { 	$( "#TrackList" ).hide();		}
	if ( SHOWDSDATA 	== false ) { 	$( "#DSdata" ).hide();			}						
	if ( SHOWDRIVERDATA	== false ) { 	$( "#DriverDataArea" ).hide();	}
	if ( SHOWSETTINGS	== false ) { 	$( "#Settings" ).hide();		}
	if ( SHOWCARLIST	== false ) { 	$( "#CarList" ).hide();			}
	if ( SHOWDSSTATISTIC== false ) { 	$( "#DSstatistic" ).hide();		}
	if ( SHOWDSRELAY	== false ) { 	$( "#DSreplay" ).hide();		}
	if ( SHOWRECSTATISTIC== false ) { 	$( "#DSRecStatistics" ).hide();		}
	
	//Set toggles to correct
	$("#btn-start-rec-data").prop( "checked", isRecEnabled);  // set state to button configure in config.js
			
	
	// init W2UI elemets
	// info: moved to start of the script and in front of init_map() to show google maps within a W2UI tab in correct format
	initW2UI();
	
	// init button and events for import Recording files from client
	initRecFileReader( HTMLCTRL );
	
	///////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////
	// BLOCK to set settings
	$( document ).ready(function() {
		
		//set default value for CSS coloration
		//$("#DRIVERCOLOR").val(  ).change();
		HTMLCTRL.DRIVERCOLOR_SetActiveElement( CSSDEFAULTSET );
		
		//set dropdown menu APIMODE	
		HTMLCTRL.APIMODE_SetSelection( APIMODE );
		
		//creat all tooltips
		initToolTips();
		
		//make elements dragable/resizable
		$(function() {
			$( "#DSdata" ).draggable();
			$( "#TrackList" ).draggable();
			$( "#CarList" ).draggable();
			$( "#DriverDataArea" ).draggable();
			$( "#Settings" ).draggable();
			
			$( "#DSdata" ).resizable({
				//animate: true
				ghost: true
       		});
		});			
		
	});

	if (AllowUrlParams) {
		// check if url params overwrite the default ds info
		if (get_url_param('dsurl') && get_url_param('dsport'))	{
				DsServerURL     =       get_url_param('dsurl');
				DsPort          =       get_url_param('dsport');
				APIMODE         =       "DS";
				//overwrite dropdown menu selection
				HTMLCTRL.APIMODE_SetSelection( APIMODE );
		}
		// check if url params overwrite the default CREST info
		if (get_url_param('cresturl') && get_url_param('crestport'))	{
			CRESTServerURL		=	get_url_param('cresturl');
			CRESTPort			=	get_url_param('crestport');
			APIMODE				=	"CREST";
			DisplayDuration		=	DisplayDurationCREST;
			//overwrite dropdown menu selection
			HTMLCTRL.APIMODE_SetSelection( APIMODE );
		}
		// check if url params overwrite the default CREST2 info
		if (get_url_param('crest2url') && get_url_param('crest2port'))	{
			CREST2ServerURL		=	get_url_param('crest2url');
			CREST2Port			=	get_url_param('crest2port');
			APIMODE				=	"CREST2";
			DisplayDuration		=	DisplayDurationCREST;
			//overwrite dropdown menu selection
			HTMLCTRL.APIMODE_SetSelection( APIMODE );
		}
		// check if url params overwrite the default autoExport option
		if (get_url_param('autoexport')){
			autoExport = get_url_param('autoexport');
		}
	}//END AllowUrlParams check
	
		
	
	/////////////////////////////////////
	// Event Handler 
	$("#APIMODE").change(function() {
			$("#APIMODE option:selected").each(function() {
					APIMODE = $( this ).text();
					if(log >= 4){console.log('------- Switch API Mode to: ', APIMODE );}										
			});			
	}); // end #APIMODE change event
	
	// Recording button
	$("#btn-start-rec-data").change(function() {			
		if ( !isRecEnabled){ PCARS_Rec.clearDataSet()};
		isRecEnabled = !isRecEnabled;	//switch between true/false					
	});
	
	//changing loop positions
	$("#loop_start_pos").change(function() {		
		setParamDemoStartPos( $( this ).val(), false );
	});
	$("#loop_end_pos").change(function() {		
		setParamDemoEndPos( $( this ).val(), false );		
	});
	
	
	$( "#DRIVERCOLOR" ).change(function() {
        $("#DRIVERCOLOR option:selected").each(function() {
        	var str1 = $( this ).val();
	        switch ( str1 ) {
	        
	        	case "hidedrivers":
	        		CSSClsChg.HideAllSvg();
	        		break;
	        		
	        	case "unhidedrivers":
		        	CSSClsChg.UnHideAllSvg();
	        		break;
	        	
	        	case "colortop3":
	        		CSSClsChg.ColorTop3vehicles();
		    		break;
		    		
	        	case "colorsameclass":
	        		CSSClsChg.ColorSameClass( aCurrentVehicleClasses );
	        		break;
		    		
	        	case "colorsamename":	        		
	        		CSSClsChg.ColorSameVName( aCurrentVehicleNames );
        			break;
	        		
	        	case "deletecssclasses":
	        		CSSClsChg.ClearAllCssClases();
	        		break;
	        	
	        	// for all dynamic generated selections
	    	    default:
	        		CSSClsChg.ColorDynClasses();
	    			break;
	        }
        });            
	}); // end #DRIVERCOLOR change Venet

	$( "#DRIVERLABELSTYLE" ).change(function() {
        $("#DRIVERLABELSTYLE option:selected").each(function() {
        	
               		CSSClsChg.setDriverLabelStyle($( this ).val());	        			         	
        });            
	}); // end #DRIVERLABELSTYLE change Venet
	
	
	
	// Event handler for Slider
	$(function() {
		$( "#slider-range-max" ).slider({
			range: "max",
			min: -1000,
			max: 1000,
      			value: DisplayDurationCorrector, 
			step: 25,
			slide: function( event, ui ) {
        		$( "#amount" ).val( ui.value );
				//set new value
				DisplayDurationCorrector = ui.value;
      			}
    		});
    		$( "#amount" ).val( $( "#slider-range-max" ).slider( "value" ) );
  	});
	
	
	$(function() {
		$( "#slider-workerdelay_dsdata" ).slider({
			range: "max",
			min:	0,
			max:	1500,
      		value:	WORKERDELAY_DSDATA, 
			step:	50,
			slide:	function( event, ui ) {
						$( "#workerdelay_dsdata" ).val( ui.value );
						//set new value
						WORKERDELAY_DSDATA = ui.value;
      			}
    		});
    		$( "#workerdelay_dsdata" ).val( $( "#slider-workerdelay_dsdata" ).slider( "value" ) );
  	});
	
	$(function() {
		$( "#slider-gui_update_interval" ).slider({
			range: "max",
			min:	1,
			max:	10,
      		value:	GuiUpdateIntervall, 
			step:	1,
			slide:	function( event, ui ) {
						$( "#gui_update_interval" ).val( ui.value );
						//set new value
						GuiUpdateIntervall = ui.value;
      			}
    		});
    		$( "#workerdelay_dsdata" ).val( $( "#slider-workerdelay_dsdata" ).slider( "value" ) );
  	});
				
	// initiate jqGrid for DriverData
	// todo: add subgrid information like: Long,Lat,RefPoint,...
	jQuery("#tracklisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        width:	830,
	        hiddengrid: true,
	        colNames:['ID','TrackID','TrackName','GameName', 'Max Gridsize', 'RefPoints exists?','Comment'],
	        colModel:[
					{name:'id', index:'id', formatter: 'integer', width:45, sorttype:"int"},
					{name:'trackid', index:'trackid', width:80, sorttype:"int"},
					{name:'trackname', index: 'trackname', width:240, sorttype:"text"},
					{name:'gamename', index: 'gamename', width:65, sorttype:"text"},
					{name:'gridsize', width:50, align:"center", sorttype:"text"},
					{name:'refpoint', width:70, align:"center", sorttype:"text"},
					{name:'comment', width:250, align:"left", sorttype:"text"},
	        ],
			onHeaderClick: function(gridstate){ 			        	
				//dynamic update of height of the div block        		       
				jQuery('#TrackList').height(0);
    		},
    		onSelectRow: function (rowId, status, e) {
				//change map location				
				if (!e || e.which === 1) {  // left click                  
					//Todo:  change fixed row id to name of the row
					var celltrackid = jQuery("#tracklisttable").jqGrid('getCell', rowId, 1);
					changeMapSettings_with_geojson(aRefPointTMP[celltrackid] , map , celltrackid);
                  
				}else if( !e || e.which === 3 ){	//right click				
              		changeMapSettings_with_geojson(aRefPointTMP[cuircitID] , map , cuircitID);
				}
			},
			ondblClickRow:	function (rowid, iRow, iCol, e) {
				//double clikc not used because overlapping event with onSelectRow				
			},
			caption: "List of available Tracks",
			rowNum: 200,
			//rowList:[10,20,30],
			//pager: 'pager_tracklisttable',
	});			
	//add filter option bar
	jQuery("#tracklisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	//add StopRefresh table button within jqgrid header - Method with Button
	jQuery('#tracklisttable').setCaption('List of available Tracks&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Stop automatic refresh of table" id="cbTracklistRefresh" value="Pause" style="background-color:#dddddd; width:50px"></input> <i class="fa fa-question pcarstooltip" aria-hidden="true" id="tt-tracklist-main"></i>');
	//disbale browser context menu on right click
	$('#tracklisttable').bind('contextmenu', function(e) {
	    return false;
	}); 

	// car list overview
	jQuery("#carlisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        hiddengrid: true,
	        width:	800,
	        colNames:['ID','Name','class', 'Game Scope', 'link', 'Comment'],
	        colModel:[
					{name:'vehicleid', 		width:100, 	sorttype:"float",align:"left", index:'id', formatter: 'float'},
					{name:'name', 			width:260, 	sorttype:"text"},
					{name:'cls',  			width:120, 	sorttype:"text"},
					{name:'gamescope', 		width:105, 	sorttype:"text", align:"center"},
					{name:'link', 			width:40, 	sorttype:"text", align:"right"},					
					{name:'comment', 		width:160, 	sorttype:"text", align:"left"},
	        ],
	    	onHeaderClick: function(gridstate){ 			        	
    			//dynamic update of height of the div block
    			jQuery('#CarList').height( 0 );        		       
    		},
	        caption: 'List of available Cars with properties. <div id="pcars-carlist-records-displayed" class="pcars_jqgrid_caption_additionalinfo"></div>',
			rowNum: 200,		
	});
	// add filter option bar
	jQuery("#carlisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });	
	// register event handler for calcualting current displayed rows after a Filter is set
	jQuery("#carlisttable").bind("jqGridToolbarAfterSearch", function (e, rowid, orgClickEvent) {	    
	    var currec = jQuery("#carlisttable").jqGrid('getGridParam', 'records');	    
	    var allrec = jQuery("#carlisttable").jqGrid('getGridParam','data');	    
	    ChangeHtmlContentByID( '#pcars-carlist-records-displayed' 		, "# of records: " + currec + " / " + allrec.length);
	    
	    return e.result === undefined ? true : e.result;
	});
	
	
	//set vehicleListtable data	
	refreshVehicleList( PCARSVehicleList.getVehicleList() );	
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////// create GUI worker thread
	var workerGUIUPDATES      =       new Worker('./worker_guiupdates.js');	
	var RecStatistics		  = 	[];
	workerGUIUPDATES.addEventListener('message', function(e) {			
					RecStatistics			=	PCARS_Rec.getStatistics();
					ChangeHtmlContentByID( '#pcars-rec-elemnr' 		, "Element number:  "	 	+ 	RecStatistics['number']  );
					ChangeHtmlContentByID( '#pcars-rec-elemsize' 		, "Element size:  "	 	+ 	RecStatistics['size']  );					
					workerGUIUPDATES.postMessage({workerdelay: GuiUpdateIntervall});				
	}, false);
	workerGUIUPDATES.postMessage({delay: GuiUpdateIntervall});
		
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create DS data object
	var workerDSDATA			=	new Worker('./worker_dsdata.js');
	sensorLayer_UpdateTime_old	=	Date.now();	//initialize a value for first time
	//event handler of the worker
	workerDSDATA.addEventListener('message', function(e) {
		
		//if(log >= 3){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: ', e);}
                
		SessionState = e.data.globals.attributes.SessionState;
		SessionStage = e.data.globals.attributes.SessionStage;
                
		// write in HTML page for DS status		 
		ChangeHtmlContentByID( '#pcars-dsurl' 		, "DS URL:  "	 	+ DsServerURL + " : " +  DsPort );
		ChangeHtmlContentByID( '#pcars-dsstate' 	, "DS State: " 		+ e.data.globals.state );
		ChangeHtmlContentByID( '#pcars-dsjoinable' 	, "DS Joinable: " 	+ e.data.globals.joinable );		
		ChangeHtmlContentByID( '#pcars-dslobbyid' 	, "DS Lobby ID:	" 	+ e.data.globals.lobbyid );		
		ChangeHtmlContentByID( '#pcars-dsnow' 		, "DS now: "		+ e.data.globals.now );				
		ChangeHtmlContentByID( '#pcars-apimode' 	, "API: "			+ APIMODE );		
		ChangeHtmlContentByID( '#pcars-displayduration' 	, "Display Duration: " + DisplayDuration );
		ChangeHtmlContentByID( '#pcars-record_pos' 	, "record_pos: " + record_pos + " / "  + demo.length);		
		ChangeHtmlContentByID( '#pcars-trackname' 	, 'TrackName:     	' + e.data.arefpoint[e.data.globals.attributes.TrackId]["Name"] );
		ChangeHtmlContentByID( '#pcars-dssessionstage' 	, "DS SessionStage:   " + SessionStage );		
		ChangeHtmlContentByID( '#pcars-dssessionstate' 	, "DS SessionState:   " + SessionState );
		ChangeHtmlContentByID( '#demo_start_pos' 	, "demo_start_pos:   " + demo_start_pos );
		ChangeHtmlContentByID( '#demo_end_pos' 	, "demo_end_pos:   " + demo_end_pos );
		
				
		if(StopRefreshDriverlist == "false"){
			var resttime = ConvertLaptimeInReadbaleFormat((e.data.globals.attributes.SessionTimeDuration-e.data.globals.attributes.SessionTimeElapsed)*1000);       //Times in seconds, but function need it in milliseconds, multiplied by 1000
			if(resttime != "-"){
				resttime = '  Time: ' + resttime;
			}
			if (SessionState == "Race" || SessionState == 2 || SessionState == 3){	//SessionState 2 and 3 is for CREST mode, enum for GAME_INGAME_PLAYING and GAME_INGAME_PAUSED
				document.getElementById("txtSessionStage").value = ' Session: ' + e.data.globals.attributes.SessionStage + resttime.slice(0,-4);     //slice for deleting the milliseconds part of the time
			}else{
				document.getElementById("txtSessionStage").value = '';
			}
		}
				
		//Reset CSVs on a new Race Weekend
		if (SessionState_old != "Loading" && SessionState == "Loading"){
			for (var key in CSVExport) {
				CSVExport[key] = "";
			}
		}

		// Build CSVs - must be done before refreshDriverList updates the table, because we need the data of the last worker run of a SessionStage and the if statements match on the first worker run of the following SessionStage
		//TODO: search for better implementation
		//after Practice1
		if (SessionState_old != "Lobby" && SessionState_old != "Loading" && SessionStage_old == "Practice1" && SessionStage != "Practice1"){     //During SessionState Lobby the SessionStage is Practice1
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");	//sort grid for the case that the user changed the sorting
			CSVExport.Practice1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Practice 1 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Practice2
		if (SessionStage_old == "Practice2" && SessionStage != "Practice2"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Practice2 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Practice 2 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Qualifying
		if (SessionStage_old == "Qualifying" && SessionStage != "Qualifying"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Qualifying = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Qualifying Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Warmup
		if (SessionStage_old == "Warmup" && SessionStage != "Warmup"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Warmup = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Warmup Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Race1 if there is a Race2
		if (SessionStage_old == "Race1" && SessionStage != "Race1" && SessionState == "Race"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Race1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race 1 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","gap2ahead","gap2first","posx","posy","posz",]);
		}
		//after Race Weekend finished
		if (SessionState_old == "Race" && SessionState == "PostRace"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			if (SessionStage_old == "Race1"){       //matches if Race1 is the only race
				CSVExport.Race1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","gap2ahead","gap2first","posx","posy","posz",]);
			}
			if (SessionStage_old == "Race2"){
				CSVExport.Race2 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race 2 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","gap2ahead","gap2first","posx","posy","posz",]);
			}
			//Auto Export
			if (autoExport == "true"){
				var CSVall = "";
				for (var key in CSVExport) {
					if(CSVExport[key] != ""){
						CSVall += CSVExport[key] + '\r\n\n';
					}
				}
				ExportCSV(CSVall,"Results");
			}
		}
		//if(log >= 4){console.log("SessionState: ", SessionState, " , CSV Oject", CSVExport)};
		
		//Hide drivertable columns diff and gap during SessionStage Race1 and Race2
		if((SessionStage_old != "Race1" && SessionStage_old != "Race2") && (SessionStage == "Race1" || SessionStage == "Race2")){
			//if(log >= 3){console.log("Hide Gaps");}
			jQuery("#DriverDataTable").hideCol(["gap2first","gap2ahead"]);
		}
		if((SessionStage_old == "Race1" || SessionStage_old == "Race2") && (SessionStage != "Race1" && SessionStage != "Race2")){
			//if(log >= 3){console.log("Show Gaps");}
			jQuery("#DriverDataTable").showCol(["gap2first","gap2ahead"]);
		}
		
		//keep cuircitID in mind for next run
		var tmpcuircitID = e.data.globals.attributes.TrackId;

		//if (SessionState_old != "Loading" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}  //20170321 disabled for troubleshooting to see what happens if the markers are normally hidden //Hide markers on Loading / before calculation, unhide is after calculation. 
		//if (SessionState_old == "Lobby" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}    //Hide markers before calculation, unhide is after calculation.
		//if (SessionState_old == "" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}         //Hide if you open the website during "Loading"
		//if (SessionState_old == "NA" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}       //Hide if you switch receivemodes, because the default SessionState = "NA"
		
		if ((SessionStage_old != SessionStage && SessionStage_old != "") || (SessionState_old != SessionState && SessionState_old != "")){	//SessionStage_old != "" for startup, because the init value is "" - SessionState check, because SessionStage stays from SessionState "Loading" to "Race" for example, but the markers are reset at SessionState change for this case
			StopTransitionDelay = "true";
			StopTransitionDelay_StartTime = Date.now();
			sensorLayer.interruptTransition();
		}
		
		//reset array		
		aInClass = {};
		
		//clean global variable to prevent ghosts entries while sitch map/rac if the previous driverfield was bigger then the current one issue #85
		// us this variant because it should be faster then aSensorData = new Array();
		aSensorData.length = 0;

		//update map
		for (var i = 0; i < e.data.driverlist.length; i++ ){
			
				//convert vehicleID to VehicleName
				e.data.driverlist[i].VehicleId			=  VehicleIdToName(e.data.driverlist[i].VehicleId , PCARSVehicleList.getIdToNameMapping() );				
				
				//calculate GPS coordinates
				gpsCoTmp =  calc_coordinates (cuircitID , e.data.driverlist[i].PosX , e.data.driverlist[i].PosZ , e.data.arefpoint);

				//cast object type because losing while webworker transfer
				e.data.driverlist[i].__proto__ = PCARSdriver.prototype;

				//set vehicle class full name
				e.data.driverlist[i].setVehicleClassNameByMapping( PCARSVehicleList.getNameToClassMapping() );
				
				//collect all vehicle classes of the current race
				aCurrentVehicleClasses[ PCARSVehicleList.getClassNormalizedByString( e.data.driverlist[i].VehicleId ) ] = 1; 
				aCurrentVehicleNames[ e.data.driverlist[i].getVehicleNameNormalized() ] = 1;
								
				//calculate "in class race position"
				//IMPORTANT assumption!!!!   :  Dirverarray is delivered in order of race positions				
				if (aInClass[ e.data.driverlist[i].VehicleClassName ] ){					
					//increment if class existing
					aInClass[ e.data.driverlist[i].VehicleClassName ]++;
				}else{
					//init value
					aInClass[ e.data.driverlist[i].VehicleClassName ] = 1;
				}
				// set the InClassRaceposition value
				e.data.driverlist[i].InClassPos = aInClass[ e.data.driverlist[i].VehicleClassName ];
				
												
				//fill data array
				aSensorData[i] = {
						"Key": 					e.data.driverlist[i].Name
						,"MarkerLabel" :		buildDriverName( e.data.driverlist[i].Name , e.data.driverlist[i].RacePosition )						
						,"DateTime":			"2013-09-04T09:41:09+10:00"
						,"Lat": 				gpsCoTmp["Lat"]
						,"Long": 				gpsCoTmp["Long"]
						,"Heading":				286.0
						,"Speed":				e.data.driverlist[i].Speed
						,"CSSTextClasses":		e.data.driverlist[i].GetCSSTextClass()
						,"CSSCircleClasses":	e.data.driverlist[i].GetCSSCircleClass()
						,"InClassPos":			aInClass[ e.data.driverlist[i].VehicleClassName ]
				}
				
				//TODO: check if it it possible to merge aSensorData + e.data.driverlist to prevent data redundancy refreshDriverList() + sensorLayer.update()
				e.data.driverlist[i].CSSGridClasses = e.data.driverlist[i].GetCSSGridClass();
				
				
				//////////////////////////////////////////////////////////////////////////////////////
				//save race statistics
				
				//format version 1
				/*
				var curlap		=	e.data.driverlist[i].CurrentLap;
				var curRacePos	=	e.data.driverlist[i].RacePosition;
				//init objects									
				if (! aRacestats[ curlap ] ){ aRacestats[ curlap ] = {}; }
				if (! aRacestats[ curlap ][ curRacePos ]){ aRacestats[ curlap ][ curRacePos ] = {}; }
				
				aRacestats[ curlap ][ curRacePos ] = {												
												'drivername':  	e.data.driverlist[i].Name,
												'laptime':	 	e.data.driverlist[i].Laptime														
										};
				*/
				//////////////////////////////////////////////////////////////////////////
				//format version 2
				/* {
		            "name": "Mark Webber",
            		"placing": [2, 3, 3, 3 ],
            		"pitstops": [3]
        		},      		*/
        		
        		if(e.data.driverlist[i].Name != ""){
					var drivername		=	e.data.driverlist[i].Name;
	        		var curlap			=	e.data.driverlist[i].CurrentLap;		// use driverlist[0] instead of driverlist[i] ? 
	        		var curRacePos		=	e.data.driverlist[i].RacePosition;
	        		if (!aRacestats['drivers'][ drivername ]){
	        			aRacestats['drivers'][ drivername ] 			= {};
	        			aRacestats['drivers'][ drivername ].name 		= drivername;
	        			aRacestats['drivers'][ drivername ].pitstops	= [];
	        			aRacestats['drivers'][ drivername ].placing		= [];
	        			aRacestats['drivers'][ drivername ].mechanical	= [];
	        			aRacestats['drivers'][ drivername ].accident	= [];
	        		}
	        		        		 
	        		aRacestats['drivers'][ drivername ].placing[curlap-1]	=	curRacePos;
	        		aRacestats['lapCount']									=	e.data.driverlist[0].CurrentLap; // use lap count from first position
        		}
        		
																					
		}// end update map

		// show coordinates of first driver in console for trackmap generation
		if(log >= 3 && aSensorData[0]){console.log("-,[" + aSensorData[0].Long.toFixed(6) + "," +  aSensorData[0].Lat.toFixed(6) + "]");}
		if(log >= 3 && e.data.driverlist[0]){console.log("+,[" + e.data.driverlist[0].PosX.toFixed(0) + "," + e.data.driverlist[0].PosZ.toFixed(0) + "]");}
		
		if(log >= 3){console.log("+++++++++ aRacestats: ", aRacestats);}
		
		
		//todo: dynamically fill up selection box with vehicle classes
		//Todo: Only update if Vehicle clasess changes ?!?
		//mapping Source
		//PCARS1-DS:   api/list/vehicles
		//PCARS1-CREST Not possible: no information regarding used vehicle available
		//PCARS2-DS:   ??
		//PCARS2-CREST ??
		/*		
		for (var key in aCurrentVehicleClasses ){				//use slow for loop because it has a low number of entries
			HTMLCTRL.DRIVERCOLOR_AddSelElement(key , key);						
		}		
		*/
		
		/////////////////////////////////////////// update driver data /////////////////////
		// refresh table of Driver data
        refreshDriverList(e.data.driverlist);
				
        sensorLayer_UpdateTime = Date.now();
		sensorLayer_UpdateDelta = sensorLayer_UpdateTime - sensorLayer_UpdateTime_old;	//Determine time duration between recent and currrent worker run
		sensorLayer_UpdateTime_old = sensorLayer_UpdateTime;
		//if(log >= 2){console.log("+++++++++Sensor Update Delta:",sensorLayer_UpdateDelta);}
                
		//Calculation of dynamic DisplayDuration
		if ((e.data.globals.datasource == "DSPCARS1" || e.data.globals.datasource == "DSPCARS2") && sensorLayer_UpdateDelta < UpdateRateDS) {
				DisplayDuration = UpdateRateDS + DisplayDurationCorrector       //If the worker runs more often than the data is updated in the DS API, then the duration is set to the DS update rate
		}else{
				DisplayDuration = sensorLayer_UpdateDelta  + DisplayDurationCorrector;
		}
		if (DisplayDuration < 0) { DisplayDuration = 0 }        //catch a negative value
		if (DisplayDuration > 2000) { DisplayDuration = 2000 }	// set a max DisplayDuration		
		
		sensorLayer.update(aSensorData);

		// in case track changes on DS adjust the map settings for new possition
        if ( cuircitID != tmpcuircitID ){			
			if (typeof tmpcuircitID == 'undefined'){tmpcuircitID = 9999999999;}	//tmpcuircitID is undefined if you switch to an APIMODE where the data source is not available, for example the pcars DS is not running
			//map.setCenter({lat: 50.332733, lng: 6.943355});			
			changeMapSettings_with_geojson(e.data.arefpoint[tmpcuircitID] , map , tmpcuircitID);

            cuircitID = tmpcuircitID;  // give the global var the new TrackId
		}
		
		if (SessionState_old != "Race" && SessionState == "Race"){   //Unhide markers after calculation, with a delay of 1000 ms
                        UnHide = "true";
                }
                if (UnHide == "true"){
                        UnHide_Timer = UnHide_Timer + sensorLayer_UpdateDelta;
                        if (UnHide_Timer > 2000){
                        	StopTransitionDelay = "true";
                                sensorLayer.interruptTransition();
                                sensorLayer.update(aSensorData);
                                CSSClsChg.UnHideAllSvg();
                                HTMLCTRL.DRIVERCOLOR_SetActiveElement( CSSDEFAULTSET );		// es workaround for the Problem with the UnHideAllSvg() call
                                UnHide_Timer = 0;
                                UnHide = "false";
                                if(log >= 2){console.log("+++++++++UnHide StopTransitionDelay:    ",StopTransitionDelay);}
                        }
                }
                SessionState_old = SessionState;
                SessionStage_old = SessionStage;

		// start recording data if option is enabled
		if (isRecEnabled){		
						// insert additional info before put into data record 
						e.data.globals.sensorLayer_UpdateDelta	=	sensorLayer_UpdateDelta;					
						// add new data set
						PCARS_Rec.addDataset({
									globals:		e.data.globals,
									participants:	e.data.driverlist
						});								                      
		}
		
		//call worker again for next itteration -> currently endless loop
		switch(APIMODE) {
                        case "DS": //DS receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 DsServerURL
                                        ,dsport:                DsPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   		"GETDSANDDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
                        case "CREST": //CREST receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 CRESTServerURL
                                        ,dsport:                CRESTPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   		"GETCRESTDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
						case "CREST2":  //CREST2 receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 CREST2ServerURL
                                        ,dsport:                CREST2Port
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   		"GETCREST2DRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
                        case "DEMO":   //DEMO receive mode

	                        //Calculation of WORKERDELAY_DEMODATA to adapt the playback speed to the recording speed
	                        //The record_pos is the array element of the recorded data and correlates to one worker run. Each element includes the sensorLayer_UpdateDelta. This is the time between the last and the current worker run. Now we calculate the WORKERDELAY_DEMODATA, which is the delay to the next worker run. Because of that we need the sensorLayer_UpdateDelta of the next array element and not of the current.
	                        record_pos_helper = record_pos + 1;
	                        if(record_pos_helper > demo.length-1){record_pos_helper = 0;}	//if last array element with record_pos is reached, record_pos_helper exceeds the upper array boundary. In this case the helper jumps to the first array element
	                        	                        	                        
	                        try {
	                        	sensorLayer_UpdateDelta_DEMOdiff = demo[record_pos_helper].globals.sensorLayer_UpdateDelta - sensorLayer_UpdateDelta;	//diff time between recorded data and playback sensorLayer_UpdateDelta	                        	
	                        } catch (e) {
	                        	if(log >= 3){console.log("ERROR: -------- record_pos_helper error catch: ", e);}	                        
	                        }
	                        
	                        
	                        WORKERDELAY_DEMODATA = WORKERDELAY_DEMODATA + sensorLayer_UpdateDelta_DEMOdiff;		//adapt playback speed to recorded data with the worker delay
	                        if(WORKERDELAY_DEMODATA < 0){WORKERDELAY_DEMODATA = 0;} //catch negative values. If the playback machine is to slow and is not able to hold the playback speed of the recording machine, then the delay is calculated negative, but the delay must be positive
	                  		//if(log >= 4){console.log("Record Pos: ", record_pos, ", Demo Delta: ",demo[record_pos].globals.sensorLayer_UpdateDelta,", cur Delta: ",sensorLayer_UpdateDelta, "diff: ", sensorLayer_UpdateDelta_DEMOdiff, "Delay: ", WORKERDELAY_DEMODATA);}
	
	                        workerDSDATA.postMessage({
	                                workerdelay:            WORKERDELAY_DEMODATA
	                                ,dsurl:                 ""
	                                ,dsport:                0
	                                ,timeout:               demo[record_pos]	//timeout parameter used for transerring demo_data array element to the worker
	                                ,receivemode:   		"GETDEMODATA"
	                                ,originaldatasource:	demo[record_pos]['globals']['datasource']	//keep original datasource 
	                                ,arefpoint:             e.data.arefpoint});
	                        
	                      //prepare next step size for e.g. fast forward scenarios 
	                        record_pos = record_pos + replay_step_size;				
	                        
	                        if(record_pos > demo.length-1 || record_pos > demo_end_pos-1){          //jump to beginning if end of array or demo_end_pos is reached/ -1, because the array begins with 0
	                                record_pos = demo_start_pos;
	                        		if (typeof record_pos !== 'number'){
	                        			if(log >= 3){console.log("ERROR: -------- var type changes of record_pos to: ",  typeof record_pos );}	                        			
	                        		}
	                        
	                                StopTransitionDelay = "true";
	                                StopTransitionDelay_StartTime = Date.now();
	                        }
	                        break;
                        default:
                                //DS receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 DsServerURL
                                        ,dsport:                DsPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   		"GETDSANDDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                }
	}, false);
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// receive data from pcars dedicated server (DS) and returns an array of PCARSdriver objects
	//         Receive_DS_data(url,port,timeout,RetrivelMode)
	// initial call of the worker
	// initial call for map initialization

	switch(APIMODE) {
		case "DS":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
			break;
		case "CREST":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: CRESTServerURL, dsport: CRESTPort, timeout: XMLHTTPTimeout, receivemode: "GETCRESTDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(CRESTServerURL, CRESTPort, 2000, "GETCRESTDRIVERDATA", aRefPointTMP);
			break;
		case "CREST2":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: CREST2ServerURL, dsport: CREST2Port, timeout: XMLHTTPTimeout, receivemode: "GETCREST2DRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(CREST2ServerURL, CREST2Port, 2000, "GETCREST2DRIVERDATA", aRefPointTMP);
			break;
		case "DEMO":
			//timeout parameter used for transerring demo_data array element to the worker
			workerDSDATA.postMessage({workerdelay: 100, dsurl: "", dsport: 0, timeout: demo[record_pos], receivemode: "GETDEMODATA", originaldatasource: demo[record_pos]['globals']['datasource'], arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data("", 0, demo[record_pos], "GETDEMODATA", aRefPointTMP, {originaldatasource : demo[record_pos]['globals']['datasource']});
			cuircitID = aDrivers.globals.attributes.TrackId;
			break;
		default:
			workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
	}

	//only used for the first input
	for (var i = 0; i < aDrivers.driverlist.length; i++ ){

               // calculate GPS coordinates
                gpsCoTmp =  calc_coordinates (cuircitID , aDrivers.driverlist[i].GetPosX() , aDrivers.driverlist[i].GetPosZ() , aRefPointTMP );

                // fill data array
                aSensorData[i] = {
                                "Key":					aDrivers.driverlist[i].GetName()
                                ,"MarkerLabel" :        buildDriverName( aDrivers.driverlist[i].GetName() , aDrivers.driverlist[i].GetRacePosition() )
                                ,"DateTime":            "2013-09-04T09:41:09+10:00"
                                ,"Lat":					gpsCoTmp["Lat"]
                                ,"Long":				gpsCoTmp["Long"]
                                ,"Heading":				286.0
                                ,"Speed":				aDrivers.driverlist[i].Speed
                                ,"CSSTextClasses":      aDrivers.driverlist[i].GetCSSTextClass()
                                ,"CSSCircleClasses":    ''
                }
	}
		
	// init google map		
	map = changeMapSettings_with_geojson(aRefPointTMP[cuircitID], map, cuircitID);

	// create Table with list of all tracks
	// checkbox Event handling
	$('#cbTracklistRefresh').click(function () {
	
		//Method with button
		var self = this;
		changeRefreshTracklist(self);                
	});
	
	function changeRefreshTracklist(data){
                if(data.value === "Pause"){
                        StopRefreshTracklist    = "true";
                        WORKERDELAY_TRACKLIST   = 10000;
                        data.value = "Play";
                        data.title = "Resume automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshTracklist    = "false";
                        WORKERDELAY_TRACKLIST   = 5000;
                        data.value = "Pause";
                        data.title = "Pause automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
	}


	// create worker for Tracklist updates //////////////////////////////////////////////////////////////////////
	var w_tracklist      =       new Worker('./worker_tracklist.js');
	
	w_tracklist.addEventListener('message', function(e) {

			if(log >= 3){console.log("+++++++++++ GETTRACKLIST Worker Trackliste Event: ", e );}
			
			if ( e.data.aTrack.length > 0 ){
				// in case DS return a result refresh track table
				refreshTrackList(buildTracklist(e.data.aTrack , e.data.aRefpoint ));

			}else{
				refreshTrackList(buildTracklist(e.data.aTrack , e.data.aRefpoint ));
				w_tracklist.postMessage({
					workerdelay: 	WORKERDELAY_TRACKLIST
					,dsurl: 		DsServerURL
					,dsport: 		DsPort
					,timeout: 		2000
					,receivemode: 	"GETTRACKLIST" 
					,aRefpoint:		e.data.aRefpoint});
				
			}
			
	}, false);
	//initial call of the tracklist worker. initiate endless loop
	w_tracklist.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETTRACKLIST", aRefpoint: aRefPointTMP });


	//todo: add subgrid for more drivers information
	jQuery("#DriverDataTable").jqGrid({
		datatype: "local",
		height: 'auto',
		width: 1000,
		hiddengrid: true,
		rowNum: 200,
		caption: "List of available drivers",
		colNames:['RefID','Pos', 'InClassPos', 'Driver Name', 'State', 'Sector', 'Lap', 'Vehicle', 'VehicleClass', 'last lap', 'fastest lap','diff','gap','Hu/AI','PosX', 'PosY', 'PosZ', 'CSSClasses' ],
		colModel:[
                        {name:'refid',hidden: true, index:'invdate', width:40, sorttype:"int"},
                        {name:'driverposition', width:18, align:"center", sorttype:"int", search:true},
			{name:'inclassposition', width:18, align:"center", sorttype:"int", search:true},
                        {name:'drivername', width:110,sorttype:"text", search:true},
                        {name:'driverstate',width:40, align:"center",sorttype:"text"},
                        {name:'driversector',width:20, align:"center",sorttype:"int"},
                        {name:'lapnumber',width:18, align:"center",sorttype:"int"},
                        {name:'vehiclename',width:130,sorttype:"text"},
                        {name:'vehicleclass',width:60,sorttype:"text"},
                        {name:'lastlap',width:35, align:"center",sorttype:"text"},
                        {name:'fastestlap',width:35, align:"center",sorttype:"text"},
                        {name:'gap2ahead',width:30, align:"center",sorttype:"text"},
			{name:'gap2first',width:30, align:"center",sorttype:"text"},
                        {name:'isplayer',width:20, align:"center",sorttype:"text"},
                        {name:'posx',hidden: JQGridIsDriversPOSHidden, width:40, align:"center",sorttype:"float"},
                        {name:'posy',hidden: JQGridIsDriversPOSHidden, width:40, align:"center",sorttype:"float"},
                        {name:'posz',hidden: JQGridIsDriversPOSHidden, width:40, align:"center",sorttype:"float"},
                        {name:'cssclasses',hidden: true, width:1, align:"center", sorttype:"text"}
                ],
		onHeaderClick: function(gridstate){ 			        	
        			//dynamic update of height of the div block
        			//jQuery('#DriverDataArea').height( jQuery('#DriverDataTable').height());        		       
					jQuery('#DriverDataArea').height(0);
        		},         
//TODO:
/*
		cellattr: function(rowId, val, rawObject) {                    
                        return " class='CSS_VehicleClass_GT_4'";                    
                },
*/
		afterInsertRow: function (rowid, rowdata, rowelem) {
			//Set data for row
			//if (rowdata.driverposition == 1){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: 'gold' });}
			
			//Set data for a cell - http://www.trirand.com/jqgridwiki/doku.php?id=wiki:methods
			if (rowdata.driverposition == 1){jQuery("#DriverDataTable").jqGrid('setCell', rowid, 'drivername', '', { background: 'gold' });}
			if (rowdata.driverposition == 2){jQuery("#DriverDataTable").jqGrid('setCell', rowid, 'drivername', '', { background: 'silver' });}
			if (rowdata.driverposition == 3){jQuery("#DriverDataTable").jqGrid('setCell', rowid, 'drivername', '', { background: '#CD7F32' });}
			
			// set CSS Styles -			
//1			jQuery("#DriverDataTable").jqGrid('setCell', rowid, 'vehicleclass', '', { background: '#CD1E32' });
			//http://stackoverflow.com/questions/2874906/jqgrid-setcell-method-how-to-set-class-of-the-fourth-parameter
			$("#DriverDataTable").jqGrid('setCell', rowid, 'vehicleclass', '', rowdata['cssclasses']);
			
//TODO:		
			if(log >= 3){console.log("--- jqGrid rowdata[]: ", rowdata );}			
			//http://stackoverflow.com/questions/3244909/how-can-i-change-the-background-color-of-a-cell-in-a-jqgrid-custom-formatter
			//			$("#DriverDataTable").setCell(rowId, 'vehicleclass', '', {'background-color':'#' + 'silver'});
			//$("tr.jqgrow#"+rowid).addClass( "CSS_VehicleClass_" + rowdata['vehicleclass'] );
			//$("tr.jqgrow#"+rowid).addClass( "CSS_VehicleClass_" + rowdata['vehicleclass'] );
						
			//TODO: set color of CLASS/Vehiclename
			//jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: 'gold' });
					
		}
	});
	
	// add filter option bar
	jQuery("#DriverDataTable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	// sort driver table on startup
	jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
	// add StopRefresh Table button in jqgrid header
	//Method with checkbox
	//$('#DriverDataArea span.ui-jqgrid-title').after(' | Stop refresh table:<input type="checkbox" id="cbDriverlistRefresh"/>');
	//Method with Button
	//TODO: tune Layout
	jQuery('#DriverDataTable').setCaption('Driver Table&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Pause automatic refresh of table" id="cbDriverlistRefresh" value="Pause" style="background-color:#dddddd; width:50px"></input>'+ '&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Export table to CSV" id="cbDriverlistExport" value="Export" style="background-color:#dddddd"></input>' + '&nbsp;&nbsp;' + '<input type="button" title="Export all past session results of this race weekend to CSV" id="cbDriverlistExportAll" value="Export All" style="background-color:#dddddd"></input>' + '&nbsp;&nbsp;&nbsp;&nbsp;' + '<input type="text" id="txtSessionStage" readonly size="30" style="border:0; background: transparent; font-weight:bold;">');
			
	// checkbox Event handling
	$('#cbDriverlistRefresh').click(function () {

		/* Method with checkbox
		if ($('#cbDriverlistRefresh').is(':checked') == true) {
			StopRefreshDriverlist   = "true";
		}else{
			StopRefreshDriverlist  	= "false";
		}*/
		//Method with Button
		var self = this;
		changeRefreshDriverlist(self);                                                
	});
        
	function changeRefreshDriverlist(data){
                if(data.value === "Pause"){
                        StopRefreshDriverlist   = "true";
                        data.value = "Play";
                        data.title = "Resume automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshDriverlist  	= "false";
                        data.value = "Pause";
                        data.title = "Pause automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
	}

	$('#cbDriverlistExport').click(function () {		
		ExportCSV(JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Current Driver Table",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","posx","posy","posz",]/*,"Report_DriverTable"*/),"Report_DriverTable");
	});
	
	$('#cbDriverlistExportAll').click(function () {
		var CSVall = "";
		for (var key in CSVExport) {
			if(CSVExport[key] != ""){
				CSVall += CSVExport[key] + '\r\n\n';
			}
		}
		ExportCSV(CSVall,"Results");
	});
	
	
	// setting up google maps overlays
	function GPSSensor(initData) {
               //state information
               var _div = null;
               var _data = initData;
               var _projection = null;

               function transform(d) {
                   var padding = 10;                   
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this) 
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }
               
               function transformWithEase(d) {
                   var padding = 10;
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this)
                       .transition().duration(DisplayDuration)
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }

               //superclass methods for google maps
               this.onAdd = function() {
                   _div = d3.select(this.getPanes().overlayLayer)
                            .append("div")
                            .attr("class", "stations");
               };               
                              
               this.draw = function () {                   
                   var padding = 10;
                   _projection = this.getProjection();		  
               };

               this.onRemove = function () {
                   _div.remove();
               };


               // todo: known issue: Beim Wechsel der Position, bleibt eine "Leiche" auf der Karte uebrig, weil Key "Pos - Name" zusammensetzt
               // easyt solution:  deleting leading position number 
               this.update = function (data) {  
            	   
				    if (!_div){	return 1;} // prevent situation where _div is undefined 
				    
					var marker;
					var padding = 10;
	
					//update internal data which drive redrawing on zoom_changed
					_data = data.slice();
					   
					//Detect time between StopTransitionDelay set to "true" and now
					var CurrentTime = Date.now();
					var StopTransitionDelay_TimeRun = CurrentTime - StopTransitionDelay_StartTime;
					
					if( StopTransitionDelay == "true" ){
													
							marker = _div.selectAll(".stations, svg")
								.data(_data, function (d) { return d.Key; })
								.each(transform) // update existing markers
								.enter().append("svg:svg")
								.each(transform)
								.attr("class", function (d){ return d.CSSTextClasses });
			
							//reset to default after zoom event finished. 
							//A zoom change in Google Maps takes some time. If the worker runs have a short interval you need a minimum time where the transformWithEase have to be interrupted
							if (StopTransitionDelay_TimeRun > StopTransitionDelay_minTimeRun) {StopTransitionDelay = "false";}
					
					}else{
									
							marker = _div.selectAll(".stations, svg")
								.data(_data, function (d) { return d.Key; })
								.each(transformWithEase) // update existing markers
								.enter().append("svg:svg")
								.each(transform)
								.attr("class", function (d){ return d.CSSTextClasses });
			
							//reset to default after zoom event finished
							//StopTransitionDelay = "false";
					}
				
					// Add a circle.
					marker.append("svg:circle")
						.attr("r", 4.5)
						.attr("cx", padding)
						.attr("cy", padding)
						.attr("class", function (d){ return d.CSSCircleClasses } );
		
					// Add a label.
					marker.append("svg:text")
						.attr("x", padding + 7)
						.attr("y", padding)
						.attr("dy", ".31em")
						//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
						//      it seem that the function within .text(...) will called only once at the beginning
						//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
						.text(function (d) {
							//if(log >= 4){console.log("+++++ d: " , d );}
		
							for (var i = 0; i < aSensorData.length; i++){
								if (aSensorData[i].Key == d.Key){
									//if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
									return  aSensorData[i].MarkerLabel;
								}
							}
							return d.MarkerLabel;
						})
						
					// Update CSS classes new
					var svgs = _div.selectAll("circle")
								.data(_data, function (d){ return d.Key; })
								.attr("class" ,(function(d){ return d.CSSCircleClasses; }));
					
					// Update labels new
					var svgs = _div.selectAll("text")
								.data(_data, function (d){ return d.Key; })							
								.text(function(d){ return d.MarkerLabel; });
		
					// delete unneeded svg objects from dom tree
					this.CleanupDriverObjects(_data);			
			
		  	}; //end update()
            
		  	this.CleanupDriverObjects = function(data) {
		  		// remapping of array of drivers to array of key
		  		var aTmp = {};
		  		for ( i = 0; i < data.length; i++) {
		  			aTmp[data[i].Key] = "";
		  		}
		  		
		  		d3.selectAll("svg, .driverlabel")
		  			.filter(".driverlabel")			// needed to prevent action to other svg in this project like LapChart
		  			.each(function( d ) {
		  					if ( aTmp[d.Key] == undefined ) {		  								
		  						this.remove(); 	// delete svg object / ghots cars
		  					}	
		  			});
		  	}; // end CleanupDriverObjects()

			this.interruptTransition = function (){
		  		// interrupt transition while zoom event
				if(_div != null){					
					_div.selectAll("svg, .driverlabel").interrupt();
				}
            }; // end interruptTransition()
            
          } // end GPSSensor(initData)

   
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////				
//////////////////////////////////////////////////////////////////////////
function init_map( newTrackObj ){
	 
	//subclassing			
	if(log >= 3){console.log("INFO: init google map instance.");}	
	GPSSensor.prototype = new google.maps.OverlayView();
						
	map = new google.maps.Map(d3.select("#map").node(), {        	 
			zoom: newTrackObj["Zoom"],                
		    center: new google.maps.LatLng( newTrackObj["MapInitLat"] , newTrackObj["MapInitLong"] ),
			mapTypeId: google.maps.MapTypeId.SATELLITE,		    
			streetViewControl: false,	//deactivate google streetview
			rotateControl: true,		// control for changing Tilt (0 or 45) and for map rotation
			scaleControl: true			//shows maps scale in the bottom right
	});
	
	//deactivate the automatic 45 Angel Tilt View on closest zoom steps
	map.setTilt(0);
	
	zoom_level	= newTrackObj["Zoom"];   //get initial zoom for zoom_settings		
	sensorLayer = new GPSSensor(aSensorData);
	sensorLayer.setMap(map); 
	
	// add map Listener
	map.addListener('zoom_changed', function() {
		//if(log >= 4){console.log("+++++++++++++++++++++++++++++++++++++++++++ current StopTransitionDelay: " , StopTransitionDelay);}
		StopTransitionDelay = "true";
        	//StopTransitionDelay_StartTime = Date.now();
		sensorLayer.interruptTransition();
		sensorLayer.update(aSensorData);
		//if(log >= 4){console.log("+++++++++++++++++++++++++++++++++++++++++++ set StopTransitionDelay to: " + StopTransitionDelay + ", StopTransitionDelay_StartTime:" + StopTransitionDelay_StartTime);}
		
		zoom_level = map.getZoom();	//get new changed zoom level
		if(log >= 3){console.log("zoom:", zoom_level, " ,lineWeight:", zoom_settings[zoom_level].lineWeight);}
		
		// Polylines on zoom change with changing lineWeight 
		PolyLineMid.setOptions({strokeWeight: zoom_settings[zoom_level].lineWeightMid});
		PolyLineOuter.setOptions({strokeWeight: zoom_settings[zoom_level].lineWeight});
		PolyLineInner.setOptions({strokeWeight: zoom_settings[zoom_level].lineWeight});
		PolyLineSF.setOptions({strokeWeight: zoom_settings[zoom_level].lineWeight});
  	});

		
	// deactivate because of problems with table height of div blocks
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('CarList'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('TrackList'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('DSdata'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('DriverDataArea'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('Settings'));
	//map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(document.getElementById('DSRecStatistics'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('DSstatistic'));       	

	//https://developers.google.com/maps/documentation/javascript/examples/polyline-simple?hl=de		
	//init line PolyLine objects
	PolyLineMid		= new google.maps.Polyline({});
	PolyLineInner	= new google.maps.Polyline({});
	PolyLineOuter	= new google.maps.Polyline({});
	PolyLineSF		= new google.maps.Polyline({});
	
	// init Polygon object for fictional tracks background
	Polygon         = new google.maps.Polygon({});
	
	return map;		       				
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/// change map settings
function changeMapSettings_with_geojson(newTrackObj, mapobj, trackid){
	
	//call if map was not init before	
	if (!mapobj){		
		// use local variable instead of global map		
		mapobj = init_map( newTrackObj );		
	}
		
	//load json file for a specific trackmap	
	d3.json( "./data/trackmaps/trackmap"+ trackid +".json" , function( gjdata ) {
		
		if (typeof gjdata === 'undefined' || !gjdata){								
			if(log >= 3){console.log("changeMapSettings_with_geojson() gjdata is empty or null:  ", gjdata );}
			tmGPS = {};	//clear trackmap data if there is no new trackmap data available
		}else{
			//transform the PosX und PosZ coordinates to GPS Longitude and Latitude
			for (var key in gjdata) {
				tmGPS[key] = [];
				if (key != "comment"){
					//if(log >= 3){console.log("gjdata pre calculation ", key, ": ", JSON.stringify(gjdata[key]));}
					for (var i = 0; i < gjdata[key].length; i++ ){
						gpsCoTmp = calc_coordinates (trackid , gjdata[key][i][0] , gjdata[key][i][1] , aRefPointTMP);
						//gjdata[key][i][0] = gpsCoTmp.Long;      //if numbers to long you can shorten it with gpsCoTmp.Long.toFixed(6)
						//gjdata[key][i][1] = gpsCoTmp.Lat;
						tmGPS[key][i] = {lat: gpsCoTmp.Lat, lng: gpsCoTmp.Long};
					}
					//if(log >= 3){console.log("gjdata ", key, ": ", gjdata[key]);}
					if(log >= 3){console.log("Google GPS ", key, ": ", tmGPS[key]);}
				}
			}
		}
		
		changeMapSettings(newTrackObj, mapobj, tmGPS);
	});         	  
	
	return mapobj;
}

function changeMapSettings(newTrackObj, mapobj, gjdata){
	//use local variable mapobj instead of global var map
	//example: map.setCenter({lat: 50.332733, lng: 6.943355});
	mapobj.setCenter({lat: newTrackObj["MapInitLat"], lng: newTrackObj["MapInitLong"]});
	mapobj.setZoom(newTrackObj["Zoom"]);
	StopTransitionDelay = "true";
	StopTransitionDelay_StartTime = Date.now();
		
	//delete old polyline instances each time a map change is triggert, not matter if new ones will created	
	PolyLineMid.setMap(null);	
	PolyLineOuter.setMap(null);
	PolyLineInner.setMap(null);
	PolyLineSF.setMap(null);
	Polygon.setMap(null);
	
	//remove old tm_debug_markers from map
	if(log >= 3){console.log("+++++++++ tm_debug_markers for deletion: ", tm_debug_markers);}
	for (var i = 0; i < tm_debug_markers.length; i++ ){
		tm_debug_markers[i].setMap(null);
	}
	//reset marker array
	tm_debug_markers = [];
	
	//set white background polygon for fictional tracks
	if (newTrackObj["fictional"]){
		Polygon = new google.maps.Polygon({
			paths: PolygonWorldCoords,
			strokeColor: '#FFFFFF',
			strokeOpacity: 1,
			strokeWeight: 2,
			fillColor: '#FFFFFF',
			fillOpacity: 1
		});
		Polygon.setMap(map);
	}
	
	//set trackmap polylines
	if ( gjdata ){				
		//create new instance MidLine if available
		if ( gjdata['line_mid'] ){		
			PolyLineMid = new google.maps.Polyline({
			    path: gjdata['line_mid'],
			    strokeColor: '#E0E0E0',
			    strokeOpacity: 0.5,
			    strokeWeight: zoom_settings[newTrackObj["Zoom"]].lineWeightMid
			  });
			
			PolyLineMid.setMap(map);			
		}
		
		//create new instance innerLine if available
		if ( gjdata['line_inner'] && (newTrackObj["fictional"] || devmode_tm) ){		
			PolyLineInner = new google.maps.Polyline({
			    path: gjdata['line_inner'],
			    strokeColor: '#FF0000',
			    strokeOpacity: 1.0,
			    strokeWeight: zoom_settings[newTrackObj["Zoom"]].lineWeight
			  });
			
			PolyLineInner.setMap(map);
		}
		
		//create new instance OuterLine if available
		if ( gjdata['line_outer'] && (newTrackObj["fictional"] || devmode_tm) ){		
			PolyLineOuter = new google.maps.Polyline({
			    path: gjdata['line_outer'],
			    strokeColor: '#FF0000',
			    strokeOpacity: 1.0,
			    strokeWeight: zoom_settings[newTrackObj["Zoom"]].lineWeight
			  });
			
			PolyLineOuter.setMap(map);
		}
		
		//create new instance Start/Finish Line if available
		if ( gjdata['line_SF'] && (newTrackObj["fictional"] || devmode_tm) ){		
			PolyLineSF = new google.maps.Polyline({
			    path: gjdata['line_SF'],
			    strokeColor: '#FF0000',
			    strokeOpacity: 1.0,
			    strokeWeight: zoom_settings[newTrackObj["Zoom"]].lineWeight
			  });
			
			PolyLineSF.setMap(map);
		}
		
		// create markers from debug array for refPoint tuning
		if ( gjdata['debug'] && devmode_tm ){
			if(log >= 3){console.log("+++++++++ trackmap debug array: ", gjdata['debug']);}
			var title;
			for (var i = 0; i < gjdata['debug'].length; i++ ){
				title = gjdata['debug'][i].lat.toFixed(6) + ", " + gjdata['debug'][i].lng.toFixed(6);
				var marker = new google.maps.Marker({
					position: gjdata['debug'][i],
					map:map,
					title: title
				});
				tm_debug_markers.push(marker);
			}
		}
	
	}// end map track polyline
	
	
	return 1;
}

///////////////////
function refreshTrackList(a){

	// if set to true, no refresh of table wanted
	if (StopRefreshTracklist == "true") {
		if(log >= 4){console.log("--- INFO stop refresh tracklist because StopRefreshTracklist set to:", StopRefreshTracklist );}
		return 1;
	}
	
	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#tracklisttable").jqGrid("clearGridData");

	var gridcnt = 0;
	var _data;
	
	for (var key in a ){		
		_data = {
					id:             gridcnt
					,trackid:       a[key]["trackid"]
					,trackname:     a[key]["trackname"]
					,gridsize:      a[key]["gridsize"]
					,refpoint:      a[key]["refpoint"]
					,comment:       a[key]["comment"]
		};		
		jQuery("#tracklisttable").jqGrid('addRowData',gridcnt, _data);

		gridcnt++
	}

	// relaod data into jqGrid
	jQuery("#tracklisttable").trigger("reloadGrid");
	
}

//fill
function refreshVehicleList(a){
	
	var _data;
					
	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#carlisttable").jqGrid("clearGridData");	
	
	//TODO: optimize way to load data 
	// http://www.trirand.com/jqgridwiki/doku.php?id=wiki:retrieving_data
	// Using data and localReader ???
	for (i=0; i < a.length; i++) {
		_data = {
   					vehicleid:		a[i].vehicleid,
					name:			a[i].name,
					cls:			a[i].cls,
					gamescope:		a[i].gamescope,
					link:			a[i].link,					
					comment:		a[i].comment
				};		
		jQuery("#carlisttable").jqGrid('addRowData',i, _data);		
	}
	
	return 1;	
}

//////////////////
function refreshDriverList(a){
	// stop refreshing jqgrid in several cases
	if (StopRefreshDriverlist == "true" || jQuery("#DriverDataTable").getGridParam('gridstate') == 'hidden') {
                //if(log >= 4){console.log("--- INFO stop refresh driverlist because StopRefreshDriverlist or grid is in status hidden!"  );}
                return 1;
	}
	
	var _data;
	//var _allDrivers = new Array();
	var Gaps = [];

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#DriverDataTable").jqGrid("clearGridData");	

	// get current size of the table
    //var GridSize = jQuery("#DriverDataTable").getGridParam("reccount");	//disabled, because after clearGridData it is 0 every time


	//todo: if drivertable is longer then new driverlist, all old values should be deleted
	//todo: if clearGridData method is working, no need for a decision if use setRowData or addRowData !
	for (i=0; i < a.length; i++) {
		
		if (i == 0){
			Gaps = CalcGaps(a[i].FastestLapTime,a[0].FastestLapTime,a[i].FastestLapTime);
		}else{
			Gaps = CalcGaps(a[i].FastestLapTime,a[0].FastestLapTime,a[i-1].FastestLapTime);
		}
		//if(log >= 3){console.log("Driver: " , a[i].Name , " , gap2ahead: ", Gaps.gap2ahead , " , gap2first: ", Gaps.gap2first);}
                
		_data = {   
					refid:					a[i].RefID
					,driverposition:		a[i].RacePosition
					,inclassposition:		a[i].InClassPos
					,drivername:			a[i].Name
					,driverstate:			a[i].State
					,driversector:			a[i].CurrentSector
					,lapnumber:				a[i].CurrentLap
					,vehiclename:			a[i].VehicleId
					,vehicleclass:			a[i].VehicleClassName
					,lastlap:				ConvertLaptimeInReadbaleFormat(a[i].LastLapTime)
					,fastestlap:			ConvertLaptimeInReadbaleFormat(a[i].FastestLapTime)
					,gap2ahead:				Gaps.gap2ahead
					,gap2first:				Gaps.gap2first
					,isplayer:				ConvertIsPlayer(a[i].IsPlayer)
					,posx:					a[i].PosX
					,posy:					a[i].PosY
					,posz:					a[i].PosZ
					,cssclasses:			a[i].CSSGridClasses
		};
		//update line
		jQuery("#DriverDataTable").jqGrid('addRowData',i, _data);
	
		//build hash for clean up map
		//deactivated 07.02.2017
		//_allDrivers[buildDriverName(a[i].Name, a[i].RacePosition)] =  {driverposition : a[i].RacePosition};		
	}

	// hide inclassposition drivertable column, if there is only one vehicle class active
	if (Object.keys(aInClass).length <= 1){
		jQuery("#DriverDataTable").hideCol(["inclassposition"]);
	} else {
		jQuery("#DriverDataTable").showCol(["inclassposition"]);
	}

	jQuery("#DriverDataTable").trigger("reloadGrid");

	return 1;
}

function buildDriverName(drivername , raceposition){
	// Diego Xavier on race position 5 => "5-Diego Xavier"
	return raceposition + " - " + drivername;
}

function transformVehicleObjectToHash(a){
	
	var hash = {};	
	for (var i=0; i < a.length; i++){
		// '' + a[i].vehicleid -> needed to convert negative numbers to string
		hash[ '' + a[i].vehicleid ] = a[i].name;
	}
				
	return hash;
}

function VehicleIdToName(id, array){
	
	if (array[id]){
		return array[id];	
	} else {
		// in the case vehilce IDs not in hash		
	}
	//if ID not found return id
	return id;
}

function ConvertIsPlayer(bool){
	
	if (bool){
		return "Hu";
	} else {
		return "AI";	
	}
}

///////////////////
function buildTracklist( aTrackList , aRefPoint ){

	// INFO: sometime problems with negative index number in associative array !!
	
	var aRefPointInt	= aRefPoint;
	//var aRefPointInt  = new Refpoint("-1"); // works fine, but slower because creating new RefPointArry
	//var aRefPointInt	= aRefPoint.slice(); // real copy an arrayworks but did not copy negative indexes
	
	var commenttmp 		= '';
	var tmpObj;
	var aNewTrackList 	= [];
	var aTmpTracklist	= [];
	var aSkipList		= []; //List of all existing RefIDs

	// go through all responded tracks from pcars dedicated server
	for (var i=0; i < aTrackList.length; i++) {
		tmpObject = aTrackList[i];

		//if refpoint for a track exists
		if (aRefPointInt['' + tmpObject.trackid]){

			aNewTrackList[tmpObject.trackid.toString()] = { 	
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"yes"
				,comment:	aRefPointInt[tmpObject.trackid]["Comment"]
            };

		//no Refpoint entry exists , fill with dummy values
		}else{
			
			aNewTrackList[tmpObject.trackid.toString()] = {
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"no"
				,comment:	"no comment because no refpoint"
           };
		}
			
		// remember trackids that allready covered by DS output from RefpointArray
		aSkipList['' + tmpObject.trackid] = "allready found";
	}
			
	//fill up with refpoint entries that are not listed in DS array
	for (var key in aRefPointInt ){
				
		//skip run if allready found 
		if ( aSkipList['' + key] ){
			continue;		
		};
				
		tmpObject = aRefPointInt['' + key];

		// check if comment field exists in the RefPoint array
		commenttmp = '';
		if ( 'Comment' in tmpObject ) {  commenttmp = tmpObject["Comment"];  };

		aNewTrackList['' + key] = {
				trackid:	key
				,trackname:	aRefPointInt[key]["Name"]
				,gridsize:	"no info"
				,refpoint:	"yes"
				,comment:	commenttmp 
		};
	}

	return aNewTrackList;
}

function CalcGaps(bestLaptime,bestLaptimeFirst,bestLaptimeAhead){
	var gap2ahead = 0;
	var gap2first = 0;

	if (bestLaptime != 0 && SessionStage != "Race1" && SessionStage != "Race2"){
		if (bestLaptimeAhead != 0){gap2ahead = bestLaptime - bestLaptimeAhead;}
		if (bestLaptimeFirst != 0){gap2first = bestLaptime - bestLaptimeFirst;}
	}

	var Gaps = {
		gap2first: ConvertLaptimeInReadbaleFormat(gap2first),
		gap2ahead: ConvertLaptimeInReadbaleFormat(gap2ahead)
	}

	return Gaps;
}

function ConvertLaptimeInReadbaleFormat(milliseconds){
	//todo: implemet date format with leading zeros for seconds and milliseconds
	//var date = new Date(milliseconds);
	
	if (milliseconds == 0){
		return "-";
	}
	
	var str = '';

	var ms = parseInt((milliseconds%1000))
	 , s = parseInt((milliseconds/1000)%60)
	 , m = parseInt((milliseconds/(1000*60))%60);

	//m = (m < 10) ? "0" + m : m;
	s = (s < 10 && m > 0) ? "0" + s : s;
	ms = (ms < 10) ? "00" + ms : ms;
	ms = (ms > 9 && ms < 100) ? "0" + ms : ms;

	if (m > 0){
		str = m + ":" + s + "." + ms;
	}else{
		str = s + "." + ms;
	}

	return str;
}

function JSONToCSVConvertor(JSONData, ReportTitle, ShowLabel,header_names,excludeColumns/*,fileName*/) {
	//If JSONData is not an object then JSON.parse will parse the JSON string in an Object
	var arrData = typeof JSONData != 'object' ? JSON.parse(JSONData) : JSONData;

	//header mapping Names <--> IDs, for example header_mapping[0][3] correlates to header_mapping[1][3]
	var header_mapping = [];
	var header_ids = [];
	var cnt = 0;

	for (var colName in arrData[0]) {
		header_ids[cnt] = colName;
		cnt++;
	}

	header_mapping[0] = header_names;
	header_mapping[1] = header_ids;

	//if(log >= 3){console.log("Export - arrData:" , arrData , " , headers: " , header_mapping );}

	var CSV = '';
	//Set Report title in first row or line

	CSV += ReportTitle + '\r\n\n';

	//This condition will generate the Label/Header
	if (ShowLabel) {
		var row = "";

		for (var col in arrData[0]) {
			//Now convert each value to string and comma-seprated
			if(excludeColumns && excludeColumns.indexOf(col) != -1){
				continue;
			}
			if(header_names){
				row += header_mapping[0][header_ids.indexOf(col)] + ',';
			}else{
				row += col + ',';
			}
		}
		row = row.slice(0, -1);
		//append Label row with line break
		CSV += row + '\r\n';
	}

	//1st loop is to extract each row
	for (var i = 0; i < arrData.length; i++) {
		var row = "";

		//2nd loop will extract each column and convert it in string comma-seprated
		for (var colName in arrData[i]) {
			//if(log >= 2){console.log("Export - colName: " , colName , " , Exclude: ", excludeColumns.indexOf(colName));}
			if(excludeColumns && excludeColumns.indexOf(colName) != -1){
				continue;
			}
			row += '"' + arrData[i][colName] + '",';
		}

		row.slice(0, row.length - 1);

		//add a line break after each row
		CSV += row + '\r\n';
	}
        	
	return CSV;
}

//SaveAsFile("text","filename.txt","text/plain;charset=utf-8");
function SaveAsFile(t,f,m) {
            try {
                var b = new Blob([t],{type:m});
                saveAs(b, f);
            } catch (e) {
                window.open("data:"+m+"," + encodeURIComponent(t), '_blank','');
            }
}

function ExportCSV(CSV,fileName){

	if (CSV == '') {
		alert("There are no results");
		return;
	}

	if(!fileName){
		//Generate a file name
		fileName = "MyReport_";
		//this will remove the blank-spaces from the title and replace it with an underscore
		//fileName += ReportTitle.replace(/ /g,"_");
	}

	if (navigator.appName == "Microsoft Internet Explorer") {
		var oWin = window.open();
		oWin.document.write('sep=,\r\n' + CSV);
		oWin.document.close();
		oWin.document.execCommand('SaveAs', true, fileName + ".csv");
		oWin.close();
	} else{
		//Initialize file format you want csv or xls
		var uri = 'data:text/csv;charset=utf-8,' + escape(CSV);

		// Now the little tricky part.
		// you can use either>> window.open(uri);
		// but this will not work in some browsers
		// or you will not get the correct file extension

		//this trick will generate a temp <a /> tag
		var link = document.createElement("a");
		link.href = uri;

		//set the visibility hidden so it will not effect on your web-layout
		link.style = "visibility:hidden";
		link.download = fileName + ".csv";

		//this part will append the anchor tag and remove it after automatic click
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

function get_url_param( name ) {
	
	name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
	var regexS = "[\\?&]"+name+"=([^&#]*)";
	var regex = new RegExp( regexS );
	var results = regex.exec( window.location.href );

	if ( results == null )
		return "";
	else
		return results[1];
}



/////////////////////////////////////////////////////////////////////////////////////////////
function initRecFileReader( HTMLCONTROLLHANDLE ){

	var fileInput 	= 	document.getElementById("RecFileUploader");

    readFile = function () {
        var reader = new FileReader();
        reader.onload = function () {

			//INFO: it slice file with static value 33. hopefully its each time the same length to cut off the prefix like "___PCARSCompressedJSONC_v01___" !! 
			// since moving to zip compression, set slice to 0
			PCARS_Rec.importData(reader.result.slice(0));	

			//switch to demo mode
			HTMLCTRL.APIMODE_SetSelection( "DEMO" );
			
			//and initialize demo array with new data -> because of async read of zipFile, initDemoData(...) called within pcars_recorder.js 			
        };		
        // start reading the file. When it is done, calls the onload event defined above.
        reader.readAsBinaryString(fileInput.files[0]);
    };
	fileInput.addEventListener('change', readFile);

	//TODO:  Reset fileInput. Needed to load file with same name again	
}


/////////////////////////////////////////////////////////////////////////////////////////////
function initDemoData(aNewData, SetApiModeTo ){
	
	//overwrite global array with new data
	demo = aNewData;			
			
	//reset values to default
	setParamDemoStartPos( 0 , true );
	setParamDemoEndPos( demo.length-1 , true );	
	record_pos 			= 0;
	record_pos_helper 	= 0;	
		
	return 1;
}

function LoadDemoFile(){
	
	$("#pcars_demofile_select option:selected").each(function() {
		
    	var url_demo_file =	GetURLPath() + "data/demo/" + $( this ).val();
    	
    	// load specific demo file		     
		$.ajax({			
		    type:    		"GET",
		    url:     		url_demo_file,
		    contentType:	'application/zip',
	        dataType:		'text',
			beforeSend: function( xhr ) {
				xhr.overrideMimeType( "text/plain; charset=x-user-defined" );
			},
		    success: function(text) {		        
		        PCARS_Rec.importData(text); // including decompress and set variable demo with new data via initdemodata()
		    },
		    statusCode: {
		        404: function() {
		          alert( "404 page not found" );
		        }
		    },
		    error:   function(e) {
		        // An error occurred
		    	alert("Error! Could not load file.");
		    }
		});
  	
    });			
}

function open_popup_load_demofile(){	  				
	// get list of available demo files in path ./data/demo/
	var url1 = GetURLPath() + "helper/dir_listing_demo.php";
	
	//http://api.jquery.com/jQuery.ajax/
	$.ajax({			
	    type:    		"GET",
	    url:     		url1,
	    //contentType:	'application/zip',
	    dataType:		'json',			
	    success: function(text) {
	    	var htmlselection;
			for (i = 0; i < text.length; i++){		    	   
				htmlselection += '<option value="' + text[i] +'">' + text[i] + '</option>';   
			}		    
	        
	        // open popup window with selection field
			w2popup.open({
	        	width: 600,
	            height: 150,
	            title:	'Popup Loading Demo Files',
	            body:
	            	'<div height="100%" align="center" vertical-align="middle">' +
		            '<label for="pcars_demofile_select">Select a file</label>' +
		            '<select id="pcars_demofile_select" name="pcars_demofile_select">' +
		              '<optgroup label="files online from ' + url1  + '">' +
		              	htmlselection	+ 	
		              '</optgroup>' +
		              '<optgroup label="Other files">' +
		                '<option value="somefile">Some other file from git URL</option>' +			                
		              '</optgroup>' +
		            '</select>' +
		            '</div>',
	            buttons:	'<button class="w2ui-btn" onclick="w2popup.close();LoadDemoFile();">Load</button>'+
	              			'<button class="w2ui-btn" onclick="w2popup.close()">Cancel</button>',
				onClose: 	function (event) { 
							//console.log('close'); 
							}
	        });
	    },		   
	    error:   function(e) {
	        if(log >= 3){console.log('+++++++++++ ERROR Ajax listing files: ', e );}
	    }
	});		
}

function setParamDemoStartPos(new_val, isHtmlChange){	
	//convert each time to a number
	new_val 	=	Number(new_val);
	
	//validate new value
	if (typeof new_val 	=== 'number'		&&
		new_val  		>=	0				&&
		new_val			<	demo_end_pos	&&			
		new_val  		<	demo.length			
	){
		demo_start_pos			= new_val;
		
		//each time jump to beginning of the loop
		record_pos			= new_val;
		record_pos_helper 	= record_pos+1;
		
		if (isHtmlChange){
			$("#loop_start_pos").val( new_val ).change();
		}
		
	}else{				
		// set to minum possible value
		$("#loop_start_pos").val( 0 ).change();		
	}
	
	return 1;
}

function setParamDemoEndPos(new_val, isHtmlChange){
	//convert each time to a number
	new_val 	=	Number(new_val);
	
	if (	typeof new_val 	=== 'number'		&&
			new_val  		>=	0				&&
			new_val			>	demo_start_pos	&&			
			new_val  		<	demo.length			
	){
		demo_end_pos		= Number(new_val);
	
		//TODO: check if vars record* should be set to a new value
		if(record_pos > new_val ){
			record_pos			= new_val - 1;
			record_pos_helper 	= new_val;
		}
		
		if (isHtmlChange){
			$("#loop_end_pos").val( new_val ).change();
		}
		
	}else{		
		// set to maximum possible value
		$("#loop_end_pos").val( demo.length-1 ).change();		
	}
	
	return 1;
}

//function definition
function GetURLPath(){
	var str1 = document.location.origin + document.location.pathname;		
	//get the path without any filename at the end. Static variant: return str1.replace("index.html","");  			
	return	str1.substr(0, str1.lastIndexOf("/") + 1 );
}		

/////////////////////////////////////////////////////////////////////////////////////////////
function initW2UI(){
	
	// start top toolbar
	$(function () {		
		$('#toolbar').w2toolbar({
            name: 'toolbar',
            items: [				
				{ type: 'break',  id: 'break0' },
				{ type: 'radio',  id: 'w2ui_liveview',  	group: '1', caption: 'Liveview', icon: 'w2ui-icon-plus', checked: true },
                { type: 'radio',  id: 'w2ui_replay',  		group: '1', caption: 'Replay', icon: 'w2ui-icon-plus' },
                { type: 'radio',  id: 'w2ui_statistics',  	group: '1', caption: 'Statistics', icon: 'w2ui-icon-plus' },                
				{ type: 'break',  id: 'break1' },
                { type: 'check',  id: 'w2ui_drivertable', 	caption: 'drivers', icon: 'w2ui-icon-check', checked: SHOWDRIVERDATA },
                { type: 'check',  id: 'w2ui_tracktable', 	caption: 'tracks', icon: 'w2ui-icon-check', checked: SHOWTRACKLIST },
                { type: 'check',  id: 'w2ui_cartable', 		caption: 'cars', icon: 'w2ui-icon-check', checked: SHOWCARLIST },
                { type: 'check',  id: 'w2ui_dsdata', 		caption: 'DS Data', icon: 'w2ui-icon-check', checked: SHOWDSDATA },
				{ type: 'check',  id: 'w2ui_recstatistics', caption: 'Rec/Save/Load', icon: 'w2ui-icon-check', checked: SHOWRECSTATISTIC },
                { type: 'break',  id: 'break2' },
                { type: 'check',  id: 'w2ui_dssettings', 	caption: 'DS Set.', icon: 'w2ui-icon-pencil', checked: SHOWSETTINGS },
                { type: 'break', id: 'break3' },
                { type: 'html',  id: 'common_stats',
                    html: '<div id="pcars-apimode" style="padding: 3px 10px;">' +
                          'API' +
                          '</div>' 
				},
				{ type: 'break', id: 'break4' },
                { type: 'spacer' },
				{ type: 'html', id: 'item9',
                	html:	'<div id="pcars-scriptversion">Version: ' + SCRIPTVERSION +
                			' | ' +
            				'<i class="fa fa-question pcarstooltip" aria-hidden="true" id="tt-toolbar-main"></i>' +
                			'</div>'                	
                }				                
            ],              		
        });
								
		//////////////////////////////////////////////////////
    	//// W2UI event handler
    	//w2ui.toolbar.on('*', function (event) { 
		w2ui.toolbar.on('click', function (event) { 
			if (event.target != undefined) {
	    		
	        	switch (event.target) {
	        	
	        		case "w2ui_drivertable": 	
	        									$( "#DriverDataArea" ).toggle();
	        									//w2ui.toolbar.items[5].icon = "w2ui-icon-cross";
	        									//w2ui.toolbar.refresh();	        									
	        									//this.refresh();
	        									//$( "#toolbar" ).refresh();
	        									break;
	        		
	        		case "w2ui_tracktable": 	$( "#TrackList" ).toggle(); break;
	        			             		             
	             	case "w2ui_cartable": 		$( "#CarList" ).toggle(); break;
	             			             	
	             	case "w2ui_dsdata":			$( "#DSdata" ).toggle(); break;
	             	
	             	case "w2ui_dssettings":		$( "#Settings" ).toggle(); break;
					
					case "w2ui_recstatistics":	$( "#DSRecStatistics" ).toggle(); break;
	             		             	
	             	case "w2ui_liveview":
	             								$( "#DSreplay" ).hide();
												$( "#DSstatistic" ).hide();
												$( ".pcarswindowgrp2" ).each(function( index ) {
													$( this ).removeClass( "pcars-force-hide" );	             									
             									});
												this.enable('w2ui_drivertable');
												this.enable('w2ui_tracktable');
												this.enable('w2ui_cartable');
												this.enable('w2ui_dsdata');
												break;	
	             	
	             	case "w2ui_statistics":		
	             								$( "#DSstatistic" ).fadeIn( "slow" ); 
	             								$( "#DSreplay" ).hide();	             								
	             								$( ".pcarswindowgrp2" ).each(function( index ) {
													$( this ).addClass( "pcars-force-hide" );	             									
             									});
	             								this.disable('w2ui_drivertable');
	             								this.disable('w2ui_tracktable');
	             								this.disable('w2ui_cartable');
	             								this.disable('w2ui_dsdata');
	             								
	             								//trigger lap Statistic call
	             								//alert ("test");
	             								initLap_LapChart( transformData(aRacestats) );
	             								break;	             							
	             	
	             	case "w2ui_replay":			             								
	             								$( "#DSreplay" ).fadeIn( "slow" );
	             								$( "#DSstatistic" ).hide();	             									             								
	             								$( ".pcarswindowgrp2" ).each(function( index ) {
													$( this ).addClass( "pcars-force-hide" );	             									
             									});
	             								this.disable('w2ui_drivertable');
	             								this.disable('w2ui_tracktable');
	             								this.disable('w2ui_cartable');
	             								this.disable('w2ui_dsdata');
	             								break;
													             			             			             		             		
	        	}
	        	

	     	}
	    }); // end of w2ui.toolbar.on()
		
	}); // end of function top toolbar

	
}; // end of initW2UI()


/////////////////////////////////////////////////////////////////////////////////////////////
function initToolTips(){ 

	///////// tooltip for the tracklist panel
	$('#tt-tracklist-main').qtip({		
		id: 	 'tracklistMaintooltip',
        content: '<b>Tooltip:<br>'
        		+'<b>left click on row:</b> switch map to new loacation.<br>' 
        		+'<b>rigth click on row:</b> switch back to original map location.<br>',
        position: {        
            target: 	'mouse', // Use the mouse position as the position origin
            at: 		'top left',
            adjust: {
                // Don't adjust continuously the mouse, just use initial position
                mouse: false
            } 
        }
    });
	///////// tooltip for toolbar
	$('#tt-toolbar-main').qtip({		
		id: 	 'tracklistMaintooltip',
        content: '<b>Tooltip:<br>'
        		+'<b><br>' 
        		+'<b>',
        position: {        
            target: 	'mouse', // Use the mouse position as the position origin
            at: 		'left',
            adjust: {
                // Don't adjust continuously the mouse, just use initial position
                mouse: false
            } 
        }
    });
		
	return 1;
}

       </script>
   </body>
</html>
