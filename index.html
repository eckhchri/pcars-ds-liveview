<!DOCTYPE html>
<html lang="de">
  <head>
	<meta charset="utf-8"/>
	<title>Project Cars DS - live view with position update. W2UI - https://github.com/eckhchri/pcars-ds-liveview </title>	
 
	<!-- static load google maps -->
 	<script type="text/javascript" src="https://maps.google.com/maps/api/js?v=3.exp"></script>
	<!-- dynamicly load google maps with/without API key if available -->
	<!-- // make trouble while loading google.maps object. Sometimes it is 'undefined'   20170116 -> back loading module without API key	 	
	<script type="text/javascript">	
		//function definition
		function GetURLPath(){
			var str1 = document.location.origin + document.location.pathname;		
			//get the path without any filename at the end. Static variant: return str1.replace("index.html","");  			
			return	str1.substr(0, str1.lastIndexOf("/") + 1 );
		}		
	 
		var head= document.getElementsByTagName('head')[0];
		var script= document.createElement('script');
		script.type= 'text/javascript';
		
		var url_google_api_key =	GetURLPath() + "config_googleapikey.txt";
		console.log('------- INFO: load google maps library from url: ', url_google_api_key );

		// load specific demo file		     
		$.ajax({			
		    type:    		"GET",
		    url:     		url_google_api_key,
		    contentType:	'text/plain',
	        dataType:		'text',
	        async: 			false,
			success: function(apikey) {		        
		        //load with api key
		        script.src= 'https://maps.google.com/maps/api/js?v=3.exp&key=' + apikey;
	        	head.appendChild(script);
	        	console.log('------- INFO: load google maps library WITH API key: ', apikey );
		    },
		    statusCode: {
		        404: function() {
		        	// file not found, load without api key		        	
		        	script.src= 'https://maps.google.com/maps/api/js?v=3.exp';
		        	head.appendChild(script);
		        	console.log('------- INFO: load google maps library withOUT API key (404)!');
		        }
		    },
		    error:   function(e) {
		        // An error occurred, load without api key		    	
		    	console.log('------- INFO: load google maps library withOUT API key error: ', e);
		    }
		});
	</script>
 -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.3.3/d3.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/js-url/1.8.6/url.min.js"></script>
	<script src="./lib/FileSaver/FileSaver.js"></script>	
	<script src="./lib/jszip/jszip.min.js"></script>
	<link rel="stylesheet" href="./lib/LapChart/lap-chart.css">
	<script src="./lib/LapChart/lap-chart.js"></script>
	
		
	<link rel="stylesheet" type="text/css" href="./lib/w2ui/w2ui-1.4.3.min.css" />
    <script type="text/javascript" src="./lib/w2ui/w2ui-1.4.3.min.js"></script>
 
 	<!-- CSS definitions moved to folder ./css/ --> 
	<link rel="stylesheet" href="./css/pcars.css">
	<link rel="stylesheet" href="./css/w2ui.css">
	<link rel="stylesheet" href="./css/font-awesome.min.css">
	
 		
	<!-- Jquery UI needed for jTable and the function dragable/resize-->
	<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
	<script src="http://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>

	<!-- The jqGrid language file code-->
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/css/ui.jqgrid.css">
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/i18n/grid.locale-de.js"></script>
	<!-- The atual jqGrid code -->
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/jquery.jqGrid.src.js"></script>

	<script src="./config.js" charset="utf-8"></script>
	<script src="./pcars_driver.js" charset="utf-8"></script>
	<script src="./pcars_track.js" charset="utf-8"></script>
	<script src="./pcars_vehicle.js" charset="utf-8"></script>
	<script src="./pcars_vehiclelist.js" charset="utf-8"></script>
	<script src="./pcars_html_controls.js" charset="utf-8"></script>	
	<script src="./receive_ds_data.js" charset="utf-8"></script>
	<script src="./calc_coordinates.js" charset="utf-8"></script>
	<script src="./class_reference_points.js" charset="utf-8"></script>
	<script src="./css_classchanger.js" charset="utf-8"></script>
	<script src="./pcars_recorder.js" charset="utf-8"></script>	
		
   </head>
  <body>
   
	<!-- W2UI Toolbar top -->
	<div id="toolbar" style="padding: 4px; border: 1px solid silver; border-radius: 3px"></div>
	
	<div id="map">Google Maps.</div>
		
	<!--  -->		   
	<div id="DSstatistic" class="mapoverlay">
		Todo: Statistiken
		After implement a kind of recording Race Data, show some statistics of that.
		1st places, number of laps, common race statistics, extracted from pcars_recording.js ... 	
		<div id="chart"></div>	
	</div>
	
	<!-- Replay -->	
	<div id="DSreplay" class="mapoverlay">
		Todo: Replay
	</div>
	
   	<div id="DSdata" class="pcarswindowgrp2">
		<div id="pcars-dsurl"></div>
		<div id="pcars-dsstate"></div>
		<div id="pcars-dsjoinable"></div>
		<div id="pcars-dslobbyid"></div>
		<div id="pcars-dsnow"></div>
		<div id="pcars-trackname"></div>
		<div id="pcars-dssessionstage"></div>
		<div id="pcars-dssessionstate"></div>
		<br>----- Settings ----<br>
		<div id="pcars-apimode"></div>
		<div id="pcars-displayduration"></div>
		<div id="pcars-record_pos"></div>
		
		<div id="DSdataInformation"></div>
		<div id="DSdataSettings"></div>
		<div id="demo_start_pos"></div>
		<div id="demo_end_pos"></div>
		
	</div>
	
   	<!-- definition of data areas, the order of the tables decides which one is in foreground and which in background-->
	<div id="TrackList" class="pcarswindowgrp2">
		<table id="tracklisttable"></table>
		<div id="pager_tracklisttable"></div>
	</div>
	<div id="CarList" class="pcarswindowgrp2">
		<table id="carlisttable"></table>
	</div>
	<div id="DriverDataArea" class="pcarswindowgrp2">
		<table id="DriverDataTable"></table>
	</div>
	

	<div id="DSRecStatistics" class="box">
	<!-- https://www.w3.org/TR/CSS21/tables.html#table-display -->
		<div class="replay_row">
			<div class="box">				
				<div><i class="fa fa-fast-backward fa-2x"></i></div>				
			</div>
			<div class="box">
				<div><i class="fa fa-pause fa-2x"></i></div>
			</div>
			<div class="box">				
				<div><i class="fa fa-play fa-2x"></i></div>				
			</div>			
			<div class="box">
				<div><i class="fa fa-fast-forward fa-2x"></i></div>
			</div>
			<div class="box">				
				<div>loop start pos:</div>
				<div><input name="field_textarea" id="loop_start_pos" type="number" size="4" maxlength="4" style="width: 45px;"/></div>
			</div>			
			<div class="box">
				<div>loop end pos:</div>
				<div><input name="field_textarea" id="loop_end_pos" type="number" size="4" maxlength="4" style="width: 45px;"/></div>
			</div>
			<div class="box">
				<div id="pcars-record_pos"></div>
				<div id="pcars-record_max"></div>
			</div>
		</div>	
		<div class="replay_row">
			<div class="box replay_cell">
				<div>Start Recording:</div>
			</div>
			<div class="box">
				<label class="switch">
					<input type="checkbox" id="btn-start-rec-data">
					<div class="slider round"></div>
				</label>				
			</div>
			<div class="box">
				<div>Export Data:</div>
			</div>			
			<div class="box">
				<button id="btn-export-rec-data" class="btn" onclick="PCARS_Rec.exportDataCompressed('PCARS_DEMO_FILE.pcars')">export</button>
			</div>
			<div class="box">
				<div>load from local File:</div>
			</div>	
			<div class="box">
				<input id="RecFileUploader" type="file" name="Select PCARS File">				
			</div>
			<div class="box">
				<button id="btn-load-demo-file" class="btn" onclick="open_popup_load_demofile();">Load from URL</button>
			</div>
			<div class="box">
				<div>Rec Stats:</div>
			</div>	
			<div class="box">
				<div id="pcars-rec-elemnr" ></div>
				<div id="pcars-rec-elemsize" ></div>		
			</div>				
		</div>
	</div>
	

	<!-- definition of option panel-->	
	<div id="Settings" class="pcarswindowgrp2">
		Settings: <br>

		<!-- API dropdown -->
		<form action="#">
		  <fieldset id="fieldset">
			<label for="APIMODE">Select API Type</label>
	    	<select class="APIMODE" name="APIMODE" id="APIMODE">
	      		<option>DS</option>
	      		<option>CREST</option>
			<option>CREST2</option>
	      		<option>DEMO</option>
			</select>
		</fieldset>
		</form>

		<label for="DRIVERCOLOR">color driver objects</label>
		<select class="DRIVERCOLOR" name="DRIVERCOLOR" id="DRIVERCOLOR">
	    	<option></option>
	    	<option value="hidedrivers">hide-drivers</option>
	    	<option value="unhidedrivers">unhide-drivers</option>
	    	<option value="colortop3">Top 3 vehicles</option>
	    	<option value="deletecssclasses">reset CSS Classes</option>
		</select>
		
		<br>
		<label for="DRIVERLABELSTYLE">Driverlabel Options</label>
		<select class="DRIVERLABELSTYLE" name="DRIVERLABELSTYLE" id="DRIVERLABELSTYLE">
	    	<option></option>
	    	<option value="normal">Normal Labels</option>
	    	<option value="cutdriverlabel">Cut Labels</option>	    	
		</select>
		
	
		<br>----<br>
  			<label for="amount">WORKERDELAY_DSDATA:</label>
			<input type="text" id="workerdelay_dsdata" readonly style="border:0;">
			<div id="slider-workerdelay_dsdata"></div>			
		<br>----<br>
		<p>
  			<label for="amount">DisplayDurationCorrector:</label>
			<input type="text" id="amount" readonly style="border:0;">
			<div id="slider-range-max"></div>
		</p>		
		<br>----<br>
		<p>
  			<label for="amount">GuiElementUpdateInterval</label>
			<input type="text" id="gui_update_interval" readonly style="border:0;">
			<div id="slider-gui_update_interval"></div>
		</p>
				
	</div>
<script type="text/javascript" charset="utf-8">

	// initialize vars
	var aDrivers 			=	new Array();		// array for PCARSdriver objects
	var aSensorData 		=	new Array();		// array of Hashes, each hash includes parameters of a driver
	var XMLHTTPTimeout		=	2000;
	var StopTransitionDelay =	"true";	// if set to true, DisplayDuration set to 0 ( cases: zoom, mapchange )
	var StopTransitionDelay_StartTime =	Date.now();	//timestamp for StopTransitionDelay is set to "true"
	var global_i			= 0;
	var map;				// google map object
	var sensorLayer;
	var sensorLayer_UpdateTime;		//time, when marker are updated
	var sensorLayer_UpdateTime_old;		//time of the recent dsdata-worker run, when the marker were updated
	var sensorLayer_UpdateDelta;		//time between recent and current dsdata-worker run, when the marker were updated
	var UnHide					= "false";	//UnHide markers
	var UnHide_Timer			= 0;		//Timer for UnHide markers
	var DisplayDurationCorrector =	0;
	var aRefPointTMP			= 	new Refpoint("-1");		// hash of all RefPoints for available tracks	
	var aVehicleList			=	new Array();			// array of pcars_vehicle.js objects
	var aVehicleIdToName		=	new Array();			// hash to translate vehicleID to VehicleName
	var StopRefreshTracklist	=	"false";
	var StopRefreshDriverlist	=	"false";
	var SessionState			=	"";
	var SessionState_old		=	"";
	var SessionStage			=	"";
	var SessionStage_old		=	"";
	var HTMLCTRL				=	new HTMLCONTROL(); 	//provide help functions
	var	PCARSVehicleList		=	new PCARSVEHICLELIST(); // creates an empty object
	var	aCurrentVehicleClasses	=	new Array();		//array of all vehicle classes within the current race
	var PCARSd					=	new PCARSdriver(); 	// only use the object to get functions of it
	PCARSd.SetExampleData();							// setDefaultValues
	
	var CSSClsChg			=	new CSSClassChanger(CSSDEFINITIONS);	// CSS defined in config.js
	var PCARS_Rec			=	new PCARSRECORDER(aRecConfig);			// initialize PcarsRecording instance	
	var record_pos;						//used for playback of data during DEMO mode
	var record_pos_helper;          	//for WORKERDELAY_DEMODATA calculation needed
	
	var sensorLayer_UpdateDelta_DEMOdiff;	//Difference between sensorLayer_UpdateDelta of the recorded data and the playback
	var WORKERDELAY_DEMODATA = WORKERDELAY_DSDATA;	//Worker delay for DEMO mode to adapt the playback speed to the recording

	// set to global var, to modify in future stage for periodical updates via ajax
	var DsName			=	"-+-"; // aDsData.name;
	var DsState			=	"-+-"; //aDsData.state;		//idle/running
	var DsTrackName		=	"Slightly Mad Studios Ltd";		//aTrackList[aDsData.TrackId];
	var DsMaxMemberCnt	=	"-+-"; //aDsData.max_member_count;
	var cuircitID		=	9999999999;		//aDsData.TrackId;
	
	var CSVExport = {	//CSV Export Data
		Practice1:	"",
		Practice2:	"",
		Qualifying:	"",
		Warmup:		"",
		Race1:		"",
		Race2:		""
	}

	//preset HTML elemets
	setParamDemoStartPos(demo_start_pos , true);
	setParamDemoEndPos(demo_end_pos, true);
	// catch demo array boundary breaks
	if(demo_start_pos > demo.length-1 || demo_start_pos < 0){
		setParamDemoStartPos(0 , true);
		//demo_start_pos = 0;
	}
	record_pos = demo_start_pos;
	
	if(demo_end_pos < 0){
		setParamDemoEndPos(9999 , true);
		//demo_end_pos = 0;		
	}
		
	
	// in the case of APIMODE==DEMO, load zipped demo file to variable demo
	if ( APIMODE == "DEMO" ) {			
		open_popup_load_demofile();						
	}
								
	// hide or unhide objects as defined within config.js
	if ( SHOWTRACKLIST 	== false ) { 	$( "#TrackList" ).hide();		}
	if ( SHOWDSDATA 	== false ) { 	$( "#DSdata" ).hide();			}						
	if ( SHOWDRIVERDATA	== false ) { 	$( "#DriverDataArea" ).hide();	}
	if ( SHOWSETTINGS	== false ) { 	$( "#Settings" ).hide();		}
	if ( SHOWCARLIST	== false ) { 	$( "#CarList" ).hide();			}
	if ( SHOWDSSTATISTIC== false ) { 	$( "#DSstatistic" ).hide();		}
	if ( SHOWDSRELAY	== false ) { 	$( "#DSreplay" ).hide();		}
	if ( SHOWRECSTATISTIC== false ) { 	$( "#DSRecStatistics" ).hide();		}
	
	//Set toggles to correct
	$("#btn-start-rec-data").prop( "checked", isRecEnabled);  // set state to button configure in config.js
			
	
	// init W2UI elemets
	// info: moved to start of the script and in front of init_map() to show google maps within a W2UI tab in correct format
	initW2UI();
	
	// init button and events for import Recording files from client
	initRecFileReader( HTMLCTRL );
	
	///////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////
	// BLOCK to set settings
	$( document ).ready(function() {
		
		//set default value for CSS coloration
		//$("#DRIVERCOLOR").val(  ).change();
		HTMLCTRL.DRIVERCOLOR_SetActiveElement( CSSDEFAULTSET );
		
		//set dropdown menu APIMODE	
		HTMLCTRL.APIMODE_SetSelection( APIMODE );
		
		//make elements dragable/resizable
		$(function() {
			$( "#DSdata" ).draggable();
			$( "#TrackList" ).draggable();
			$( "#CarList" ).draggable();
			$( "#DriverDataArea" ).draggable();
			$( "#Settings" ).draggable();
			
			$( "#DSdata" ).resizable({
				//animate: true
				ghost: true
       		});
		});
		
		
		CSSClsChg.setCutDriverLabel();
		
	});

	if (AllowUrlParams) {
		// check if url params overwrite the default ds info
		if (get_url_param('dsurl') && get_url_param('dsport'))	{
				DsServerURL     =       get_url_param('dsurl');
				DsPort          =       get_url_param('dsport');
				APIMODE         =       "DS";
				//overwrite dropdown menu selection
				HTMLCTRL.APIMODE_SetSelection( APIMODE );
		}
		// check if url params overwrite the default CREST info
		if (get_url_param('cresturl') && get_url_param('crestport'))	{
			CRESTServerURL		=	get_url_param('cresturl');
			CRESTPort			=	get_url_param('crestport');
			APIMODE				=	"CREST";
			DisplayDuration		=	DisplayDurationCREST;
			//overwrite dropdown menu selection
			HTMLCTRL.APIMODE_SetSelection( APIMODE );
		}
		// check if url params overwrite the default CREST2 info
		if (get_url_param('crest2url') && get_url_param('crest2port'))	{
			CREST2ServerURL		=	get_url_param('crest2url');
			CREST2Port			=	get_url_param('crest2port');
			APIMODE				=	"CREST2";
			DisplayDuration		=	DisplayDurationCREST;
			//overwrite dropdown menu selection
			HTMLCTRL.APIMODE_SetSelection( APIMODE );
		}
		// check if url params overwrite the default autoExport option
		if (get_url_param('autoexport')){
			autoExport = get_url_param('autoexport');
		}
	}//END AllowUrlParams check
	
		
	
	/////////////////////////////////////
	// Event Handler 
	$("#APIMODE").change(function() {
			$("#APIMODE option:selected").each(function() {
					APIMODE = $( this ).text();
					if(log >= 4){console.log('------- Switch API Mode to: ', APIMODE );}										
			});			
	}); // end #APIMODE change event
	
	// Recording button
	$("#btn-start-rec-data").change(function() {			
		if ( !isRecEnabled){ PCARS_Rec.clearDataSet()};
		isRecEnabled = !isRecEnabled;	//switch between true/false					
	});
	
	//changing loop positions
	$("#loop_start_pos").change(function() {		
		setParamDemoStartPos( $( this ).val(), false );
	});
	$("#loop_end_pos").change(function() {		
		setParamDemoEndPos( $( this ).val(), false );		
	});
	
	
	$( "#DRIVERCOLOR" ).change(function() {
        $("#DRIVERCOLOR option:selected").each(function() {
        	var str1 = $( this ).val();
	        switch ( str1 ) {
	        
	        	case "hidedrivers":
	        		CSSClsChg.HideAllSvg();
	        		break;
	        		
	        	case "unhidedrivers":
		        	CSSClsChg.UnHideAllSvg();
	        		break;
	        	
	        	case "colortop3":
	        		CSSClsChg.ColorTop3vehicles();
		    		break;
		    		
	        	case "deletecssclasses":
	        		CSSClsChg.ClearAllCssClases();
	        		break;
	        		
	    	    default:
	        		CSSClsChg.ClearAllCssClases();
	    			break;
	        }
        });            
	}); // end #DRIVERCOLOR change Venet

	$( "#DRIVERLABELSTYLE" ).change(function() {
        $("#DRIVERLABELSTYLE option:selected").each(function() {
        	
               		CSSClsChg.setDriverLabelStyle($( this ).val());	        			         	
        });            
	}); // end #DRIVERLABELSTYLE change Venet
	
	
	
	// Event handler for Slider
	$(function() {
		$( "#slider-range-max" ).slider({
			range: "max",
			min: -1000,
			max: 1000,
      			value: DisplayDurationCorrector, 
			step: 25,
			slide: function( event, ui ) {
        		$( "#amount" ).val( ui.value );
				//set new value
				DisplayDurationCorrector = ui.value;
      			}
    		});
    		$( "#amount" ).val( $( "#slider-range-max" ).slider( "value" ) );
  	});
	
	
	$(function() {
		$( "#slider-workerdelay_dsdata" ).slider({
			range: "max",
			min:	0,
			max:	1500,
      		value:	WORKERDELAY_DSDATA, 
			step:	50,
			slide:	function( event, ui ) {
						$( "#workerdelay_dsdata" ).val( ui.value );
						//set new value
						WORKERDELAY_DSDATA = ui.value;
      			}
    		});
    		$( "#workerdelay_dsdata" ).val( $( "#slider-workerdelay_dsdata" ).slider( "value" ) );
  	});
	
	$(function() {
		$( "#slider-gui_update_interval" ).slider({
			range: "max",
			min:	1,
			max:	10,
      		value:	GuiUpdateIntervall, 
			step:	1,
			slide:	function( event, ui ) {
						$( "#gui_update_interval" ).val( ui.value );
						//set new value
						GuiUpdateIntervall = ui.value;
      			}
    		});
    		$( "#workerdelay_dsdata" ).val( $( "#slider-workerdelay_dsdata" ).slider( "value" ) );
  	});
	
	
		
	// initiate jqGrid for DriverData
	// todo: add subgrid information like: Long,Lat,RefPoint,...
	jQuery("#tracklisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        width:	790,
	        hiddengrid: true,
	        colNames:['ID','TrackID','TrackName','Max Gridsize', 'RefPoints exists?','Comment'],
	        colModel:[
					{name:'id', index:'id', formatter: 'integer', width:45, sorttype:"int"},
					{name:'trackid', index:'trackid', width:80, sorttype:"int"},
					{name:'trackname', index: 'trackname', width:240, sorttype:"text"},
					{name:'gridsize', width:50, align:"center", sorttype:"text"},
					{name:'refpoint', width:70, align:"center", sorttype:"text"},
					{name:'comment', width:250, align:"left", sorttype:"text"},
	        ],
			caption: "List of available Tracks",
			rowNum: 200,
			//rowList:[10,20,30],
			//pager: 'pager_tracklisttable',
	});			
	//add filter option bar
	jQuery("#tracklisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	//add StopRefresh table button within jqgrid header - Method with Button
	jQuery('#tracklisttable').setCaption('List of available Tracks&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Stop automatic refresh of table" id="cbTracklistRefresh" value="Pause" style="background-color:#dddddd; width:50px"></input>');


	// car list overview
	jQuery("#carlisttable").jqGrid({	
	        datatype: "local",
	        height: 'auto',
	        hiddengrid: true,
	        colNames:['ID','CarName','class','Set1', 'Set2','Comment'],
	        colModel:[
					{name:'vehicleid', 	width:100, 	sorttype:"float",align:"left", index:'id', formatter: 'float'},
					{name:'name', 		width:100, 	sorttype:"text"},
					{name:'cls',  		width:200, 	sorttype:"text"},
					{name:'set1', 		width:40, 	sorttype:"text", align:"right"},
					{name:'set2', 		width:90, 	sorttype:"text", align:"center"},
					{name:'comment', 	width:160, 	sorttype:"text", align:"left"},
	        ],
	        caption: "List of available Cars with properties.",
			rowNum: 200,
	});
	// add filter option bar
	jQuery("#carlisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////// create GUI worker thread
	var workerGUIUPDATES      =       new Worker('./worker_guiupdates.js');	
	var RecStatistics		  = 	[];
	workerGUIUPDATES.addEventListener('message', function(e) {			
					RecStatistics			=	PCARS_Rec.getStatistics();
					ChangeHtmlContentByID( '#pcars-rec-elemnr' 		, "Element number:  "	 	+ 	RecStatistics['number']  );
					ChangeHtmlContentByID( '#pcars-rec-elemsize' 		, "Element size:  "	 	+ 	RecStatistics['size']  );					
					workerGUIUPDATES.postMessage({workerdelay: GuiUpdateIntervall});				
	}, false);
	workerGUIUPDATES.postMessage({delay: GuiUpdateIntervall});
	
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create worker to get vehicle list
	var workerVEHICLELIST      =       new Worker('./worker_vehiclelist.js');
	
	workerVEHICLELIST.addEventListener('message', function(e) {
		
		if(log >= 4){console.log('+++++++++++ GETVEHICLELIST Worker returned: e ', e );}
		if ( e.data.avehiclelist.length > 0 ){
			
			aVehicleList	=	e.data.avehiclelist;	//copy the array of vehicle objects to global var			
			aVehicleIdToName = transformVehicleObjectToHash(aVehicleList);		
			//display vehicle data in table 
			PCARSVehicleList.setVehicleData(aVehicleList);
			refreshVehicleList(PCARSVehicleList);
									
		}else{			
			// no return value from DS, start another run
			workerVEHICLELIST.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETVEHICLELIST", arefpoint: aRefPointTMP});
		}		
	}, false);
	workerVEHICLELIST.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETVEHICLELIST", arefpoint: aRefPointTMP});
	

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create DS data object
	var workerDSDATA			=	new Worker('./worker_dsdata.js');
	sensorLayer_UpdateTime_old	=	Date.now();	//initialize a value for first time
	//event handler of the worker
	workerDSDATA.addEventListener('message', function(e) {
		
		if(log >= 4){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: ', e);}
                
		SessionState = e.data.globals.attributes.SessionState;
		SessionStage = e.data.globals.attributes.SessionStage;
                
		// write in HTML page for DS status		 
		ChangeHtmlContentByID( '#pcars-dsurl' 		, "DS URL:  "	 	+ DsServerURL + " : " +  DsPort );
		ChangeHtmlContentByID( '#pcars-dsstate' 	, "DS State: " 		+ e.data.globals.state );
		ChangeHtmlContentByID( '#pcars-dsjoinable' 	, "DS Joinable: " 	+ e.data.globals.joinable );		
		ChangeHtmlContentByID( '#pcars-dslobbyid' 	, "DS Lobby ID:	" 	+ e.data.globals.lobbyid );		
		ChangeHtmlContentByID( '#pcars-dsnow' 		, "DS now: "		+ e.data.globals.now );				
		ChangeHtmlContentByID( '#pcars-apimode' 	, "API: "			+ APIMODE );		
		ChangeHtmlContentByID( '#pcars-displayduration' 	, "Display Duration: " + DisplayDuration );
		ChangeHtmlContentByID( '#pcars-record_pos' 	, "record_pos: " + record_pos + " / "  + demo.length);		
		ChangeHtmlContentByID( '#pcars-trackname' 	, 'TrackName:     	' + e.data.arefpoint[e.data.globals.attributes.TrackId]["Name"] );
		ChangeHtmlContentByID( '#pcars-dssessionstage' 	, "DS SessionStage:   " + SessionStage );		
		ChangeHtmlContentByID( '#pcars-dssessionstate' 	, "DS SessionState:   " + SessionState );
		ChangeHtmlContentByID( '#demo_start_pos' 	, "demo_start_pos:   " + demo_start_pos );
		ChangeHtmlContentByID( '#demo_end_pos' 	, "demo_end_pos:   " + demo_end_pos );
		
		
		
		if(StopRefreshDriverlist == "false"){
			var resttime = ConvertLaptimeInReadbaleFormat((e.data.globals.attributes.SessionTimeDuration-e.data.globals.attributes.SessionTimeElapsed)*1000);       //Times in seconds, but function need it in milliseconds, multiplied by 1000
			if(resttime != "-"){
				resttime = '  Time: ' + resttime;
			}
			if (SessionState == "Race" || SessionState == 2 || SessionState == 3){	//SessionState 2 and 3 is for CREST mode, enum for GAME_INGAME_PLAYING and GAME_INGAME_PAUSED
				document.getElementById("txtSessionStage").value = ' Session: ' + e.data.globals.attributes.SessionStage + resttime.slice(0,-4);     //slice for deleting the milliseconds part of the time
			}else{
				document.getElementById("txtSessionStage").value = '';
			}
		}
				
		//Reset CSVs on a new Race Weekend
		if (SessionState_old != "Loading" && SessionState == "Loading"){
			for (var key in CSVExport) {
				CSVExport[key] = "";
			}
		}

		// Build CSVs - must be done before refreshDriverList updates the table, because we need the data of the last worker run of a SessionStage and the if statements match on the first worker run of the following SessionStage
		//TODO: search for better implementation
		//after Practice1
		if (SessionState_old != "Lobby" && SessionState_old != "Loading" && SessionStage_old == "Practice1" && SessionStage != "Practice1"){     //During SessionState Lobby the SessionStage is Practice1
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");	//sort grid for the case that the user changed the sorting
			CSVExport.Practice1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Practice 1 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Practice2
		if (SessionStage_old == "Practice2" && SessionStage != "Practice2"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Practice2 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Practice 2 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Qualifying
		if (SessionStage_old == "Qualifying" && SessionStage != "Qualifying"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Qualifying = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Qualifying Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Warmup
		if (SessionStage_old == "Warmup" && SessionStage != "Warmup"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Warmup = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Warmup Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","posx","posy","posz",]);
		}
		//after Race1 if there is a Race2
		if (SessionStage_old == "Race1" && SessionStage != "Race1" && SessionState == "Race"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			CSVExport.Race1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race 1 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","gap2ahead","gap2first","posx","posy","posz",]);
		}
		//after Race Weekend finished
		if (SessionState_old == "Race" && SessionState == "PostRace"){
			jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
			if (SessionStage_old == "Race1"){       //matches if Race1 is the only race
				CSVExport.Race1 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","gap2ahead","gap2first","posx","posy","posz",]);
			}
			if (SessionStage_old == "Race2"){
				CSVExport.Race2 = JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Race 2 Results",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","lastlap","gap2ahead","gap2first","posx","posy","posz",]);
			}
			//Auto Export
			if (autoExport == "true"){
				var CSVall = "";
				for (var key in CSVExport) {
					if(CSVExport[key] != ""){
						CSVall += CSVExport[key] + '\r\n\n';
					}
				}
				ExportCSV(CSVall,"Results");
			}
		}
		//if(log >= 4){console.log("SessionState: ", SessionState, " , CSV Oject", CSVExport)};
		
		//todo var declaration needed within loop ???
		var tmpcuircitID;
		tmpcuircitID = e.data.globals.attributes.TrackId;
		if(log >= 3){console.log("tmpcuircitID worker: ", tmpcuircitID);}

		if (SessionState_old != "Loading" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}  //Hide markers on Loading / before calculation, unhide is after calculation.
		//if (SessionState_old == "Lobby" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}    //Hide markers before calculation, unhide is after calculation.
		//if (SessionState_old == "" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}         //Hide if you open the website during "Loading"
		//if (SessionState_old == "NA" && SessionState == "Loading"){CSSClsChg.HideAllSvg();}       //Hide if you switch receivemodes, because the default SessionState = "NA"
		
		if ((SessionStage_old != SessionStage && SessionStage_old != "") || (SessionState_old != SessionState && SessionState_old != "")){	//SessionStage_old != "" for startup, because the init value is "" - SessionState check, because SessionStage stays from SessionState "Loading" to "Race" for example, but the markers are reset at SessionState change for this case
			StopTransitionDelay = "true";
			StopTransitionDelay_StartTime = Date.now();
			sensorLayer.interruptTransition();
		}
		
		//update map
		for (var i = 0; i < e.data.driverlist.length; i++ ){
			
				//convert vehicleID to VehicleName
				e.data.driverlist[i].VehicleId	=  VehicleIdToName(e.data.driverlist[i].VehicleId , aVehicleIdToName);

				//gatthering all vehicle classes of the current race
				aCurrentVehicleClasses[i] = e.data.driverlist[i].VehicleId;
				
				//calculate GPS coordinates
				gpsCoTmp =  calc_coordinates (cuircitID , e.data.driverlist[i].PosX , e.data.driverlist[i].PosZ , e.data.arefpoint);

				//cast object type because losing while webworker transfer
				e.data.driverlist[i].__proto__ = PCARSdriver.prototype;
				
				//fill data array
				aSensorData[i] = {
						"Key": 				e.data.driverlist[i].Name
						,"MarkerLabel" :	buildDriverName( e.data.driverlist[i].Name , e.data.driverlist[i].RacePosition )						
						,"DateTime":		"2013-09-04T09:41:09+10:00"
						,"Lat": 			gpsCoTmp["Lat"]
						,"Long": 			gpsCoTmp["Long"]
						,"Heading":			286.0
						,"Speed":			e.data.driverlist[i].Speed
						,"CSSTextClasses":	e.data.driverlist[i].GetCSSTextClass()
						,"CSSCircleClasses":	e.data.driverlist[i].GetCSSCircleClass(PCARSVehicleList.idToClassMappingNormalized)
				}												
		}// end update map
		
		//todo: dynamically fill up selection box with vehicle classes
		//if(log >= 3){console.log('+++++++++ aCurrentVehicleClasses:', aCurrentVehicleClasses)};
		var lcvc 	= aCurrentVehicleClasses.length;
		var tmpcvc	= "";		
		for(var i = 0; i < lcvc; i++){			
			tmpcvc	=	aCurrentVehicleClasses[i];
			HTMLCTRL.DRIVERCOLOR_AddSelElement(tmpcvc , tmpcvc);
		}
		
		/////////////////////////////////////////// update driver data /////////////////////
		// refresh table of Driver data
        refreshDriverList(e.data.driverlist);
		
        sensorLayer_UpdateTime = Date.now();
		sensorLayer_UpdateDelta = sensorLayer_UpdateTime - sensorLayer_UpdateTime_old;	//Determine time duration between recent and currrent worker run
		sensorLayer_UpdateTime_old = sensorLayer_UpdateTime;
		if(log >= 2){console.log("+++++++++Sensor Update Delta:",sensorLayer_UpdateDelta);}
                
		//Calculation of dynamic DisplayDuration
		if ((APIMODE == "DS" || APIMODE == "DEMO") && sensorLayer_UpdateDelta < UpdateRateDS) {
				DisplayDuration = UpdateRateDS + DisplayDurationCorrector       //If the worker runs more often than the data is updated in the DS API, then the duration is set to the DS update rate
		}else{
				DisplayDuration = sensorLayer_UpdateDelta  + DisplayDurationCorrector;
		}
		if (DisplayDuration < 0) { DisplayDuration = 0 }        //catch a negative value
		if (DisplayDuration > 2000) { DisplayDuration = 2000 }	// set a max DisplayDuration		
		
		sensorLayer.update(aSensorData);

		// in case track changes on DS adjust the map settings for new possition
        if ( cuircitID != tmpcuircitID ){			
			if (typeof tmpcuircitID == 'undefined'){tmpcuircitID = 9999999999;}	//tmpcuircitID is undefined if you switch to an APIMODE where the data source is not available, for example the pcars DS is not running
			//map.setCenter({lat: 50.332733, lng: 6.943355});
			changeMapSettings(e.data.arefpoint[tmpcuircitID] , map);

            cuircitID = tmpcuircitID;  // give the global var the new TrackId
		}
		
		if (SessionState_old != "Race" && SessionState == "Race"){   //Unhide markers after calculation, with a delay of 1000 ms
                        UnHide = "true";
                }
                if (UnHide == "true"){
                        UnHide_Timer = UnHide_Timer + sensorLayer_UpdateDelta;
                        if (UnHide_Timer > 1000){
                        	StopTransitionDelay = "true";
                                sensorLayer.interruptTransition();
                                sensorLayer.update(aSensorData);
                                CSSClsChg.UnHideAllSvg();
                                UnHide_Timer = 0;
                                UnHide = "false";
                                if(log >= 2){console.log("+++++++++UnHide StopTransitionDelay:    ",StopTransitionDelay);}
                        }
                }
                SessionState_old = SessionState;
                SessionStage_old = SessionStage;

		// start recording data if option is enabled
		if (isRecEnabled){		
						// insert additional info before put into data record 
						e.data.globals.sensorLayer_UpdateDelta	=	sensorLayer_UpdateDelta;					
						// add new data set
						PCARS_Rec.addDataset({
									globals:		e.data.globals,
									participants:	e.data.driverlist
						});								                      
		}
		
		//call worker again for next itteration -> currently endless loop
		switch(APIMODE) {
                        case "DS": //DS receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 DsServerURL
                                        ,dsport:                DsPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   "GETDSANDDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
                        case "CREST": //CREST receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 CRESTServerURL
                                        ,dsport:                CRESTPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   "GETCRESTDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
						case "CREST2":  //CREST2 receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 CREST2ServerURL
                                        ,dsport:                CREST2Port
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   "GETCREST2DRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                                break;
                        case "DEMO":   //DEMO receive mode

	                        //Calculation of WORKERDELAY_DEMODATA to adapt the playback speed to the recording speed
	                        //The record_pos is the array element of the recorded data and correlates to one worker run. Each element includes the sensorLayer_UpdateDelta. This is the time between the last and the current worker run. Now we calculate the WORKERDELAY_DEMODATA, which is the delay to the next worker run. Because of that we need the sensorLayer_UpdateDelta of the next array element and not of the current.
	                        record_pos_helper = record_pos + 1;
	                        if(record_pos_helper > demo.length-1){record_pos_helper = 0;}	//if last array element with record_pos is reached, record_pos_helper exceeds the upper array boundary. In this case the helper jumps to the first array element
	                        	                        	                        
	                        try {
	                        	sensorLayer_UpdateDelta_DEMOdiff = demo[record_pos_helper].globals.sensorLayer_UpdateDelta - sensorLayer_UpdateDelta;	//diff time between recorded data and playback sensorLayer_UpdateDelta	                        	
	                        } catch (e) {
	                        	if(log >= 3){console.log("ERROR: -------- record_pos_helper error catch: ", e);}	                        
	                        }
	                        
	                        
	                        WORKERDELAY_DEMODATA = WORKERDELAY_DEMODATA + sensorLayer_UpdateDelta_DEMOdiff;		//adapt playback speed to recorded data with the worker delay
	                        if(WORKERDELAY_DEMODATA < 0){WORKERDELAY_DEMODATA = 0;} //catch negative values. If the playback machine is to slow and is not able to hold the playback speed of the recording machine, then the delay is calculated negative, but the delay must be positive
	                  		if(log >= 2){console.log("Record Pos: ", record_pos, ", Demo Delta: ",demo[record_pos].globals.sensorLayer_UpdateDelta,", cur Delta: ",sensorLayer_UpdateDelta, "diff: ", sensorLayer_UpdateDelta_DEMOdiff, "Delay: ", WORKERDELAY_DEMODATA);}
	
	                        workerDSDATA.postMessage({
	                                workerdelay:            WORKERDELAY_DEMODATA
	                                ,dsurl:                 ""
	                                ,dsport:                0
	                                ,timeout:               demo[record_pos]	//timeout parameter used for transerring demo_data array element to the worker
	                                ,receivemode:   "GETDEMODATA"
	                                ,arefpoint:             e.data.arefpoint});
	                        
	                      //prepare next step size for e.g. fast forward scenarios 
	                        record_pos = record_pos + replay_step_size;				
	                        
	                        if(record_pos > demo.length-1 || record_pos > demo_end_pos-1){          //jump to beginning if end of array or demo_end_pos is reached/ -1, because the array begins with 0
	                                record_pos = demo_start_pos;
	                        		if (typeof record_pos !== 'number'){
	                        			if(log >= 3){console.log("ERROR: -------- var type changes of record_pos to: ",  typeof record_pos );}	                        			
	                        		}
	                        
	                                StopTransitionDelay = "true";
	                                StopTransitionDelay_StartTime = Date.now();
	                        }
	                        break;
                        default:
                                //DS receive mode
                                workerDSDATA.postMessage({
                                        workerdelay:            WORKERDELAY_DSDATA
                                        ,dsurl:                 DsServerURL
                                        ,dsport:                DsPort
                                        ,timeout:               XMLHTTPTimeout
                                        ,receivemode:   		"GETDSANDDRIVERDATA"
                                        ,arefpoint:             e.data.arefpoint});
                }
	}, false);
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// receive data from pcars dedicated server (DS) and returns an array of PCARSdriver objects
	//         Receive_DS_data(url,port,timeout,RetrivelMode)
	// initial call of the worker
	// initial call for map initialization

	switch(APIMODE) {
		case "DS":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
			break;
		case "CREST":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: CRESTServerURL, dsport: CRESTPort, timeout: XMLHTTPTimeout, receivemode: "GETCRESTDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(CRESTServerURL, CRESTPort, 2000, "GETCRESTDRIVERDATA", aRefPointTMP);
			break;
		case "CREST2":
			workerDSDATA.postMessage({workerdelay: 100, dsurl: CREST2ServerURL, dsport: CREST2Port, timeout: XMLHTTPTimeout, receivemode: "GETCREST2DRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(CREST2ServerURL, CREST2Port, 2000, "GETCREST2DRIVERDATA", aRefPointTMP);
			break;
		case "DEMO":
			//timeout parameter used for transerring demo_data array element to the worker
			workerDSDATA.postMessage({workerdelay: 100, dsurl: "", dsport: 0, timeout: demo[record_pos], receivemode: "GETDEMODATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data("", 0, demo[record_pos], "GETDEMODATA", aRefPointTMP);
			cuircitID = aDrivers.globals.attributes.TrackId;
			break;
		default:
			workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});
			aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
	}
        
	for (var i = 0; i < aDrivers.driverlist.length; i++ ){

               // calculate GPS coordinates
                gpsCoTmp =  calc_coordinates (cuircitID , aDrivers.driverlist[i].GetPosX() , aDrivers.driverlist[i].GetPosZ() , aRefPointTMP );

                // fill data array
                aSensorData[i] = {
                                "Key":					aDrivers.driverlist[i].GetName()
                                ,"MarkerLabel" :        buildDriverName( aDrivers.driverlist[i].GetName() , aDrivers.driverlist[i].GetRacePosition() )
                                ,"DateTime":            "2013-09-04T09:41:09+10:00"
                                ,"Lat":					gpsCoTmp["Lat"]
                                ,"Long":				gpsCoTmp["Long"]
                                ,"Heading":				286.0
                                ,"Speed":				aDrivers.driverlist[i].Speed
                                ,"CSSTextClasses":      aDrivers.driverlist[i].GetCSSTextClass()
                                ,"CSSCircleClasses":    aDrivers.driverlist[i].GetCSSCircleClass()
                }
	}
	
	
	// init google map
	init_map(cuircitID , aRefPointTMP);

	// add map Listener
	map.addListener('zoom_changed', function() {
		if(log >= 4){console.log("+++++++++++++++++++++++++++++++++++++++++++ current StopTransitionDelay: " , StopTransitionDelay);}
		StopTransitionDelay = "true";
        //StopTransitionDelay_StartTime = Date.now();
		sensorLayer.interruptTransition();
		sensorLayer.update(aSensorData);
		if(log >= 4){console.log("+++++++++++++++++++++++++++++++++++++++++++ set StopTransitionDelay to: " + StopTransitionDelay + ", StopTransitionDelay_StartTime:" + StopTransitionDelay_StartTime);}
  	});

	// create Table with list of all tracks
	// checkbox Event handling
	$('#cbTracklistRefresh').click(function () {
	
		//Method with button
		var self = this;
		changeRefreshTracklist(self);                
	});
	
	function changeRefreshTracklist(data){
                if(data.value === "Pause"){
                        StopRefreshTracklist    = "true";
                        WORKERDELAY_TRACKLIST   = 10000;
                        data.value = "Play";
                        data.title = "Resume automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshTracklist    = "false";
                        WORKERDELAY_TRACKLIST   = 5000;
                        data.value = "Pause";
                        data.title = "Pause automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
	}


	// create worker for Tracklist updates //////////////////////////////////////////////////////////////////////
	var w_tracklist      =       new Worker('./worker_tracklist.js');
	
	w_tracklist.addEventListener('message', function(e) {

			if(log >= 3){console.log("+++++++++++ GETTRACKLIST Worker Trackliste Event: ", e );}
			
			if ( e.data.aTrack.length > 0 ){
				// in case DS return a result refresh track table
				refreshTrackList(buildTracklist(e.data.aTrack , e.data.aRefpoint ));

			}else{
				refreshTrackList(buildTracklist(e.data.aTrack , e.data.aRefpoint ));
				w_tracklist.postMessage({
					workerdelay: 	WORKERDELAY_TRACKLIST
					,dsurl: 		DsServerURL
					,dsport: 		DsPort
					,timeout: 		2000
					,receivemode: 	"GETTRACKLIST" 
					,aRefpoint:		e.data.aRefpoint});
				
			}
			
	}, false);
	//initial call of the tracklist worker. initiate endless loop
	w_tracklist.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETTRACKLIST", aRefpoint: aRefPointTMP });


	//todo: add subgrid for more drivers information
	jQuery("#DriverDataTable").jqGrid({
                datatype: "local",
                height: 'auto',
		width: 910,
		hiddengrid: true,
		rowNum: 200,
		caption: "List of available drivers",
                colNames:['RefID','Pos', 'Driver Name', 'State', 'Sector', 'Lap', 'Vehicle', 'last lap', 'fastest lap','diff','gap','Hu/AI','PosX', 'PosY', 'PosZ' ],
                colModel:[
                        {name:'refid',hidden: true, index:'invdate', width:40, sorttype:"int"},
                        {name:'driverposition', width:18, sorttype:"int", search:true},
                        {name:'drivername', width:100,sorttype:"text", search:true},
                        {name:'driverstate',width:40, align:"center",sorttype:"text"},
                        {name:'driversector',width:20, align:"center",sorttype:"int"},
                        {name:'lapnumber',width:18, align:"center",sorttype:"int"},
                        {name:'vehiclename',width:90,sorttype:"text"},
                        {name:'lastlap',width:35, align:"center",sorttype:"text"},
                        {name:'fastestlap',width:35, align:"center",sorttype:"text"},
                        {name:'gap2ahead',width:30, align:"center",sorttype:"text"},
						{name:'gap2first',width:30, align:"center",sorttype:"text"},
                        {name:'isplayer',width:20, align:"center",sorttype:"text"},
                        {name:'posx',hidden: JQGridIsDriversPOSHidden, width:40, align:"center",sorttype:"float"},
                        {name:'posy',hidden: JQGridIsDriversPOSHidden, width:40, align:"center",sorttype:"float"},
                        {name:'posz',hidden: JQGridIsDriversPOSHidden, width:40, align:"center",sorttype:"float"}
                ],
                afterInsertRow: function (rowid, rowdata) {
			if (rowdata.driverposition == 1){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: 'gold' });}
			if (rowdata.driverposition == 2){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: 'silver' });}
			if (rowdata.driverposition == 3){jQuery("#DriverDataTable").jqGrid('setRowData', rowid, false, { background: '#CD7F32' });}
		}
	});
	
	// add filter option bar
	jQuery("#DriverDataTable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	// sort driver table on startup
	jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
	// add StopRefresh Table button in jqgrid header
	//Method with checkbox
	//$('#DriverDataArea span.ui-jqgrid-title').after(' | Stop refresh table:<input type="checkbox" id="cbDriverlistRefresh"/>');
	//Method with Button
	//TODO: tune Layout
	jQuery('#DriverDataTable').setCaption('Driver Table&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Pause automatic refresh of table" id="cbDriverlistRefresh" value="Pause" style="background-color:#dddddd; width:50px"></input>'+ '&nbsp;&nbsp;&nbsp;' + '<input type="button" title="Export table to CSV" id="cbDriverlistExport" value="Export" style="background-color:#dddddd"></input>' + '&nbsp;&nbsp;' + '<input type="button" title="Export all past session results of this race weekend to CSV" id="cbDriverlistExportAll" value="Export All" style="background-color:#dddddd"></input>' + '&nbsp;&nbsp;&nbsp;&nbsp;' + '<input type="text" id="txtSessionStage" readonly size="30" style="border:0; background: transparent; font-weight:bold;">');
			
	// checkbox Event handling
	$('#cbDriverlistRefresh').click(function () {

		/* Method with checkbox
		if ($('#cbDriverlistRefresh').is(':checked') == true) {
			StopRefreshDriverlist   = "true";
		}else{
			StopRefreshDriverlist  	= "false";
		}*/
		//Method with Button
		var self = this;
		changeRefreshDriverlist(self);                                                
	});
        
	function changeRefreshDriverlist(data){
                if(data.value === "Pause"){
                        StopRefreshDriverlist   = "true";
                        data.value = "Play";
                        data.title = "Resume automatic refresh of table";
                        data.style="background-color:#ffffff";
                }else{
                        StopRefreshDriverlist  	= "false";
                        data.value = "Pause";
                        data.title = "Pause automatic refresh of table";
                        data.style="background-color:#dddddd";
                }
	}

	$('#cbDriverlistExport').click(function () {		
		ExportCSV(JSONToCSVConvertor(jQuery("#DriverDataTable").jqGrid("getRowData"), "Current Driver Table",true,jQuery("#DriverDataTable").jqGrid("getGridParam", "colNames"),["refid","id","driverstate","driversector","posx","posy","posz",]/*,"Report_DriverTable"*/),"Report_DriverTable");
	});
	
	$('#cbDriverlistExportAll').click(function () {
		var CSVall = "";
		for (var key in CSVExport) {
			if(CSVExport[key] != ""){
				CSVall += CSVExport[key] + '\r\n\n';
			}
		}
		ExportCSV(CSVall,"Results");
	});
	
	
	// setting up google maps overlays
	function GPSSensor(initData) {
               //state information
               var _div = null;
               var _data = initData;
               var _projection = null;

               function transform(d) {
                   var padding = 10;                   
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this) 
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }
               
               function transformWithEase(d) {
                   var padding = 10;
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this)
                       .transition().duration(DisplayDuration)
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }

               //superclass methods for google maps
               this.onAdd = function() {
                   _div = d3.select(this.getPanes().overlayLayer)
                            .append("div")
                            .attr("class", "stations");
               };               
                              
               this.draw = function () {                   
                   var padding = 10;
                   _projection = this.getProjection();		  
               };

               this.onRemove = function () {
                   _div.remove();
               };


               // todo: known issue: Beim Wechsel der Position, bleibt eine "Leiche" auf der Karte uebrig, weil Key "Pos - Name" zusammensetzt
               // easyt solution:  deleting leading position number 
               this.update = function (data) {     
			
				var marker;
				var padding = 10;
						
				//update internal data which drive redrawing on zoom_changed
				_data = data.slice();
				   
				//Detect time between StopTransitionDelay set to "true" and now
				var CurrentTime = Date.now();
				var StopTransitionDelay_TimeRun = CurrentTime - StopTransitionDelay_StartTime;
	
				if( StopTransitionDelay == "true" ){
						if(log >= 3){console.log ("++++++++++++++++++++++++++++++ stopped StopTransitionDelay: " + StopTransitionDelay + " , TimeRun:" + StopTransitionDelay_TimeRun);}
						//this.draw();
						marker = _div.selectAll("svg")
							.data(_data, function (d) { return d.Key; })
							.each(transform) // update existing markers
							.enter().append("svg:svg")
							.each(transform)
							.attr("class", function (d){ return d.CSSTextClasses });
		
						// reset to default after zoom event finished. 
						//A zoom change in Google Maps takes some time. If the worker runs have a short interval you need a minimum time where the transformWithEase have to be interrupted
						if (StopTransitionDelay_TimeRun > StopTransitionDelay_minTimeRun) {StopTransitionDelay = "false";}
				
				}else{
						if(log >= 3){console.log ("++++++++++++++++++++++++++++++ normal StopTransitionDelay: " , StopTransitionDelay );}
						//this.draw();
		
						marker = _div.selectAll("svg")
							.data(_data, function (d) { return d.Key; })
							.each(transformWithEase) // update existing markers
							.enter().append("svg:svg")
							.each(transform)
							.attr("class", function (d){ return d.CSSTextClasses });
		
						// reset to default after zoom event finished
						//StopTransitionDelay = "false";
				}
			
				// Add a circle.
				marker.append("svg:circle")
					.attr("r", 4.5)
					.attr("cx", padding)
					.attr("cy", padding)
					.attr("class", function (d){ return d.CSSCircleClasses } );
	
				// Add a label.
				marker.append("svg:text")
					.attr("x", padding + 7)
					.attr("y", padding)
					.attr("dy", ".31em")
					//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
					//      it seem that the function within .text(...) will called only once at the beginning
					//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
					.text(function (d) {
						//if(log >= 4){console.log("+++++ d: " , d );}
	
						for (var i = 0; i < aSensorData.length; i++){
							if (aSensorData[i].Key == d.Key){
								//if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
								return  aSensorData[i].MarkerLabel;
							}
						}
						return d.MarkerLabel;
					})
					
				// Update CSS classes new
				var svgs = _div.selectAll("circle")
							.data(_data, function (d){ return d.Key; })
							.attr("class" ,(function(d){ return d.CSSCircleClasses; }));
				
				// Update labels new
				var svgs = _div.selectAll("text")
							.data(_data, function (d){ return d.Key; })							
							.text(function(d){ return d.MarkerLabel; });
	
				// delete unneeded svg objects from dom tree
				this.CleanupDriverObjects(_data);			
			
		  	}; //end update()
            
		  	this.CleanupDriverObjects = function(data) {
		  		// remapping of array of drivers to array of key
		  		var aTmp = {};
		  		for ( i = 0; i < data.length; i++) {
		  			aTmp[data[i].Key] = "";
		  		}
		  			
		  		var svgs = 	d3.selectAll("svg")
		  					.each(function( d ) {
		  							if ( aTmp[d.Key] == undefined ) {		  								
		  								this.remove(); 	// delete svg object / ghots cars
		  							}	
		  					});
		  	}; // end CleanupDriverObjects()

			this.interruptTransition = function (){
		  		// interrupt transition while zoom event
				if(_div != null){
					_div.selectAll("svg")
						.interrupt();
				}
            }; // end interruptTransition()
            
          } // end GPSSensor(initData)


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////				
//////////////////////////////////////////////////////////////////////////
function init_map(_TrackID , aRefPoint){
        	  
	//subclassing			
	if(log >= 3){console.log("INFO: typeof google map object: ", typeof google);}
	GPSSensor.prototype = new google.maps.OverlayView();
						
	map = new google.maps.Map(d3.select("#map").node(), {        	 
			zoom: aRefPoint[_TrackID]["Zoom"],                
		    center: new google.maps.LatLng( aRefPoint[_TrackID]["MapInitLat"] , aRefPoint[_TrackID]["MapInitLong"] ),
			mapTypeId: google.maps.MapTypeId.SATELLITE,
		    //deactivate google streetview
			streetViewControl: false
	});
		
	sensorLayer = new GPSSensor(aSensorData);
	sensorLayer.setMap(map); 
		
	//todo: maybe change from static to dynamic binding of HTML elements
	// deactivate because of problems with table height of div blocks
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('CarList'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('TrackList'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('DSdata'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('DriverDataArea'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('Settings'));
	//map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(document.getElementById('DSRecStatistics'));
	//map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(document.getElementById('DSstatistic'));       	
		       	
	return 1;		       				
}


function changeMapSettings(newTrackObj, mapobj){
	//todo: replace map (global variable) with mapobj(if this is not a copy)
	//example: map.setCenter({lat: 50.332733, lng: 6.943355});
	map.setCenter({lat: newTrackObj["MapInitLat"], lng: newTrackObj["MapInitLong"]});

	map.setZoom(newTrackObj["Zoom"]);

	StopTransitionDelay = "true";
	StopTransitionDelay_StartTime = Date.now();

	//todo: change also picture Overlay prevered mapsourc(google,openstreetmap) in needed
	return 1;
}

///////////////////
function refreshTrackList(a){

	// if set to true, no refresh of table wanted
	if (StopRefreshTracklist == "true") {
		if(log >= 4){console.log("--- INFO stop refresh tracklist because StopRefreshTracklist set to:", StopRefreshTracklist );}
		return 1;
	}

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#tracklisttable").jqGrid("clearGridData");

	var gridcnt = 0;
	var _data;
	
	for (var key in a ){		
		_data = {
                                        id:             gridcnt
                                        ,trackid:       a[key]["trackid"]
                                        ,trackname:     a[key]["trackname"]
                                        ,gridsize:      a[key]["gridsize"]
                                        ,refpoint:      a[key]["refpoint"]
                                        ,comment:       a[key]["comment"]
                                };		
		jQuery("#tracklisttable").jqGrid('addRowData',gridcnt, _data);

		gridcnt++
	}

	// relaod data into jqGrid
	jQuery("#tracklisttable").trigger("reloadGrid");
	
}

//fill
function refreshVehicleList(aVL){
	
	a	=	aVL.getVehicleList();
	var _data;
	
	if(log >= 3){console.log("--- INFO refreshVehicleList aVL: ", a );}
	
	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#carlisttable").jqGrid("clearGridData");	
	
	
	for (i=0; i < a.length; i++) {
		_data = {
   					vehicleid:	a[i].vehicleid,
					name:		a[i].name,
					cls:		a[i].cls,
					set1:		"-",
					set2:		"-",
					comment:	"-"
				};
		
		jQuery("#carlisttable").jqGrid('addRowData',i, _data);
	}
	
	return 1;	
}

//////////////////
function refreshDriverList(a){
	// if set to true, no refresh of table wanted
	if (StopRefreshDriverlist == "true") {
                if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshDriverlist set to:", StopRefreshDriverlist );}
                return 1;
	}

	var _data;
	var _allDrivers = new Array();
	var Gaps = [];

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#DriverDataTable").jqGrid("clearGridData");	

	// get current size of the table
    //var GridSize = jQuery("#DriverDataTable").getGridParam("reccount");	//disabled, because after clearGridData it is 0 every time


	//todo: if drivertable is longer then new driverlist, all old values should be deleted
	//todo: if clearGridData method is working, no need for a decision if use setRowData or addRowData !
	for (i=0; i < a.length; i++) {
		
		if (i == 0){
			Gaps = CalcGaps(a[i].FastestLapTime,a[0].FastestLapTime,a[i].FastestLapTime);
		}else{
			Gaps = CalcGaps(a[i].FastestLapTime,a[0].FastestLapTime,a[i-1].FastestLapTime);
		}
		//if(log >= 3){console.log("Driver: " , a[i].Name , " , gap2ahead: ", Gaps.gap2ahead , " , gap2first: ", Gaps.gap2first);}
                
		_data = {   
					refid:				a[i].RefID
					,driverposition:	a[i].RacePosition	
					,drivername:		a[i].Name
					,driverstate:		a[i].State
					,driversector:		a[i].CurrentSector
					,lapnumber:			a[i].CurrentLap
//Issue82			,vehiclename:		VehicleIdToName(a[i].VehicleId , aVehicleIdToName)	//in DEMO mode a[i].VehicleId contains directly the VehicleName and the VehicleIdToName returns it back
					,vehiclename:		a[i].VehicleId 						
					,lastlap:			ConvertLaptimeInReadbaleFormat(a[i].LastLapTime)
					,fastestlap:		ConvertLaptimeInReadbaleFormat(a[i].FastestLapTime)
					,gap2ahead:			Gaps.gap2ahead
					,gap2first:			Gaps.gap2first
					,isplayer:			ConvertIsPlayer(a[i].IsPlayer)
					,posx:				a[i].PosX
					,posy:				a[i].PosY
					,posz:				a[i].PosZ
		};
		//update line
		jQuery("#DriverDataTable").jqGrid('addRowData',i, _data);
	
		//build hash for clean up map	
		_allDrivers[buildDriverName(a[i].Name, a[i].RacePosition)] =  {driverposition : a[i].RacePosition};
	}

	//Hide columns diff and gap during SessionStage Race1 and Race2
	if((SessionStage_old != "Race1" && SessionStage_old != "Race2") && (SessionStage == "Race1" || SessionStage == "Race2")){
		//if(log >= 3){console.log("Hide Gaps");}
		jQuery("#DriverDataTable").hideCol(["gap2first","gap2ahead"]);
	}
	if((SessionStage_old == "Race1" || SessionStage_old == "Race2") && (SessionStage != "Race1" && SessionStage != "Race2")){
		//if(log >= 3){console.log("Show Gaps");}
		jQuery("#DriverDataTable").showCol(["gap2first","gap2ahead"]);
	}

	jQuery("#DriverDataTable").trigger("reloadGrid");

	return 1;
}

function buildDriverName(drivername , raceposition){
	// Diego Xavier on race position 5 => "5-Diego Xavier"
	return raceposition + " - " + drivername;
}

function transformVehicleObjectToHash(a){
	
	var hash = {};	
	for (var i=0; i < a.length; i++){
		// '' + a[i].vehicleid -> needed to convert negative numbers to string
		hash[ '' + a[i].vehicleid ] = a[i].name;
	}
				
	return hash;
}

function VehicleIdToName(id, array){
	
	if (array[id]){
		return array[id];	
	} else {
		// in the case vehilce IDs not in hash		
	}
	//if ID not found return id
	return id;
}

function ConvertIsPlayer(bool){
	
	if (bool){
		return "Hu";
	} else {
		return "AI";	
	}
}

///////////////////
function buildTracklist( aTrackList , aRefPoint ){

	// INFO: sometime problems with negative index number in associative array !!
	
	var aRefPointInt	= aRefPoint;
	//var aRefPointInt  = new Refpoint("-1"); // works fine, but slower because creating new RefPointArry
	//var aRefPointInt	= aRefPoint.slice(); // real copy an arrayworks but did not copy negative indexes
	
	var commenttmp 		= '';
	var tmpObj;
	var aNewTrackList 	= [];
	var aTmpTracklist	= [];
	var aSkipList		= []; //List of all existing RefIDs

	// go through all responded tracks from pcars dedicated server
	for (var i=0; i < aTrackList.length; i++) {
		tmpObject = aTrackList[i];

		//if refpoint for a track exists
		if (aRefPointInt['' + tmpObject.trackid]){

			aNewTrackList[tmpObject.trackid.toString()] = { 	
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"yes"
				,comment:	aRefPointInt[tmpObject.trackid]["Comment"]
            };

		//no Refpoint entry exists , fill with dummy values
		}else{
			
			aNewTrackList[tmpObject.trackid.toString()] = {
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"no"
				,comment:	"no comment because no refpoint"
           };
		}
			
		// remember trackids that allready covered by DS output from RefpointArray
		aSkipList['' + tmpObject.trackid] = "allready found";
	}
			
	//fill up with refpoint entries that are not listed in DS array
	for (var key in aRefPointInt ){
				
		//skip run if allready found 
		if ( aSkipList['' + key] ){
			continue;		
		};
				
		tmpObject = aRefPointInt['' + key];

		// check if comment field exists in the RefPoint array
		commenttmp = '';
		if ( 'Comment' in tmpObject ) {  commenttmp = tmpObject["Comment"];  };

		aNewTrackList['' + key] = {
				trackid:	key
				,trackname:	aRefPointInt[key]["Name"]
				,gridsize:	"no info"
				,refpoint:	"yes"
				,comment:	commenttmp 
		};
	}

	return aNewTrackList;
}

function CalcGaps(bestLaptime,bestLaptimeFirst,bestLaptimeAhead){
	var gap2ahead = 0;
	var gap2first = 0;

	if (bestLaptime != 0){
		if (bestLaptimeAhead != 0){gap2ahead = bestLaptime - bestLaptimeAhead;}
		if (bestLaptimeFirst != 0){gap2first = bestLaptime - bestLaptimeFirst;}
	}

	var Gaps = {
		gap2first: ConvertLaptimeInReadbaleFormat(gap2first),
		gap2ahead: ConvertLaptimeInReadbaleFormat(gap2ahead)
	}

	return Gaps;
}

function ConvertLaptimeInReadbaleFormat(milliseconds){
	//todo: implemet date format with leading zeros for seconds and milliseconds
	//var date = new Date(milliseconds);
	
	if (milliseconds == 0){
		return "-";
	}
	
	var str = '';

	var ms = parseInt((milliseconds%1000))
	 , s = parseInt((milliseconds/1000)%60)
	 , m = parseInt((milliseconds/(1000*60))%60);

	//m = (m < 10) ? "0" + m : m;
	s = (s < 10 && m > 0) ? "0" + s : s;
	ms = (ms < 10) ? "00" + ms : ms;
	ms = (ms > 9 && ms < 100) ? "0" + ms : ms;

	if (m > 0){
		str = m + ":" + s + "." + ms;
	}else{
		str = s + "." + ms;
	}

	return str;
}

function JSONToCSVConvertor(JSONData, ReportTitle, ShowLabel,header_names,excludeColumns/*,fileName*/) {
	//If JSONData is not an object then JSON.parse will parse the JSON string in an Object
	var arrData = typeof JSONData != 'object' ? JSON.parse(JSONData) : JSONData;

	//header mapping Names <--> IDs, for example header_mapping[0][3] correlates to header_mapping[1][3]
	var header_mapping = [];
	var header_ids = [];
	var cnt = 0;

	for (var colName in arrData[0]) {
		header_ids[cnt] = colName;
		cnt++;
	}

	header_mapping[0] = header_names;
	header_mapping[1] = header_ids;

	//if(log >= 3){console.log("Export - arrData:" , arrData , " , headers: " , header_mapping );}

	var CSV = '';
	//Set Report title in first row or line

	CSV += ReportTitle + '\r\n\n';

	//This condition will generate the Label/Header
	if (ShowLabel) {
		var row = "";

		for (var col in arrData[0]) {
			//Now convert each value to string and comma-seprated
			if(excludeColumns && excludeColumns.indexOf(col) != -1){
				continue;
			}
			if(header_names){
				row += header_mapping[0][header_ids.indexOf(col)] + ',';
			}else{
				row += col + ',';
			}
		}
		row = row.slice(0, -1);
		//append Label row with line break
		CSV += row + '\r\n';
	}

	//1st loop is to extract each row
	for (var i = 0; i < arrData.length; i++) {
		var row = "";

		//2nd loop will extract each column and convert it in string comma-seprated
		for (var colName in arrData[i]) {
			//if(log >= 2){console.log("Export - colName: " , colName , " , Exclude: ", excludeColumns.indexOf(colName));}
			if(excludeColumns && excludeColumns.indexOf(colName) != -1){
				continue;
			}
			row += '"' + arrData[i][colName] + '",';
		}

		row.slice(0, row.length - 1);

		//add a line break after each row
		CSV += row + '\r\n';
	}
        	
	return CSV;
}

//SaveAsFile("text","filename.txt","text/plain;charset=utf-8");
function SaveAsFile(t,f,m) {
            try {
                var b = new Blob([t],{type:m});
                saveAs(b, f);
            } catch (e) {
                window.open("data:"+m+"," + encodeURIComponent(t), '_blank','');
            }
}

function ExportCSV(CSV,fileName){

	if (CSV == '') {
		alert("There are no results");
		return;
	}

	if(!fileName){
		//Generate a file name
		fileName = "MyReport_";
		//this will remove the blank-spaces from the title and replace it with an underscore
		//fileName += ReportTitle.replace(/ /g,"_");
	}

	if (navigator.appName == "Microsoft Internet Explorer") {
		var oWin = window.open();
		oWin.document.write('sep=,\r\n' + CSV);
		oWin.document.close();
		oWin.document.execCommand('SaveAs', true, fileName + ".csv");
		oWin.close();
	} else{
		//Initialize file format you want csv or xls
		var uri = 'data:text/csv;charset=utf-8,' + escape(CSV);

		// Now the little tricky part.
		// you can use either>> window.open(uri);
		// but this will not work in some browsers
		// or you will not get the correct file extension

		//this trick will generate a temp <a /> tag
		var link = document.createElement("a");
		link.href = uri;

		//set the visibility hidden so it will not effect on your web-layout
		link.style = "visibility:hidden";
		link.download = fileName + ".csv";

		//this part will append the anchor tag and remove it after automatic click
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

function get_url_param( name ) {
	
	name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
	var regexS = "[\\?&]"+name+"=([^&#]*)";
	var regex = new RegExp( regexS );
	var results = regex.exec( window.location.href );

	if ( results == null )
		return "";
	else
		return results[1];
}



/////////////////////////////////////////////////////////////////////////////////////////////
function initRecFileReader( HTMLCONTROLLHANDLE ){

	var fileInput 	= 	document.getElementById("RecFileUploader");

    readFile = function () {
        var reader = new FileReader();
        reader.onload = function () {

			//INFO: it slice file with static value 33. hopefully its each time the same length to cut off the prefix like "___PCARSCompressedJSONC_v01___" !! 
			// since moving to zip compression, set slice to 0
			PCARS_Rec.importData(reader.result.slice(0));	

			//switch to demo mode
			HTMLCTRL.APIMODE_SetSelection( "DEMO" );
			
			//and initialize demo array with new data -> because of async read of zipFile, initDemoData(...) called within pcars_recorder.js 			
        };		
        // start reading the file. When it is done, calls the onload event defined above.
        reader.readAsBinaryString(fileInput.files[0]);
    };
	fileInput.addEventListener('change', readFile);

	//TODO:  Reset fileInput. Needed to load file with same name again	
}


/////////////////////////////////////////////////////////////////////////////////////////////
function initDemoData(aNewData, SetApiModeTo ){

	//overwrite global array with new data
	demo = aNewData;	
			
	//reset values to default
	setParamDemoStartPos( 0 , true );
	setParamDemoEndPos( demo.length-1 , true );	
	record_pos 			= 0;
	record_pos_helper 	= 0;	
		
	return 1;
}

function LoadDemoFile(){
	
	$("#pcars_demofile_select option:selected").each(function() {
		
    	var url_demo_file =	GetURLPath() + "data/demo/" + $( this ).val();
    	
    	// load specific demo file		     
		$.ajax({			
		    type:    		"GET",
		    url:     		url_demo_file,
		    contentType:	'application/zip',
	        dataType:		'text',
			beforeSend: function( xhr ) {
				xhr.overrideMimeType( "text/plain; charset=x-user-defined" );
			},
		    success: function(text) {		        
		        PCARS_Rec.importData(text); // including decompress and set variable demo with new data via initdemodata()
		    },
		    statusCode: {
		        404: function() {
		          alert( "404 page not found" );
		        }
		    },
		    error:   function(e) {
		        // An error occurred
		    	alert("Error! Could not load file.");
		    }
		});
  	
    });			
}

function open_popup_load_demofile(){	  				
	// get list of available demo files in path ./data/demo/
	var url1 = GetURLPath() + "helper/dir_listing_demo.php";
	
	//http://api.jquery.com/jQuery.ajax/
	$.ajax({			
	    type:    		"GET",
	    url:     		url1,
	    //contentType:	'application/zip',
	    dataType:		'json',			
	    success: function(text) {
	    	var htmlselection;
			for (i = 0; i < text.length; i++){		    	   
				htmlselection += '<option value="' + text[i] +'">' + text[i] + '</option>';   
			}		    
	        
	        // open popup window with selection field
			w2popup.open({
	        	width: 600,
	            height: 150,
	            title:	'Popup Loading Demo Files',
	            body:
	            	'<div height="100%" align="center" vertical-align="middle">' +
		            '<label for="pcars_demofile_select">Select a file</label>' +
		            '<select id="pcars_demofile_select" name="pcars_demofile_select">' +
		              '<optgroup label="files online from ' + url1  + '">' +
		              	htmlselection	+ 	
		              '</optgroup>' +
		              '<optgroup label="Other files">' +
		                '<option value="somefile">Some other file from git URL</option>' +			                
		              '</optgroup>' +
		            '</select>' +
		            '</div>',
	            buttons:	'<button class="w2ui-btn" onclick="w2popup.close();LoadDemoFile();">Load</button>'+
	              			'<button class="w2ui-btn" onclick="w2popup.close()">Cancel</button>',
				onClose: 	function (event) { 
							//console.log('close'); 
							}
	        });
	    },		   
	    error:   function(e) {
	        if(log >= 3){console.log('+++++++++++ ERROR Ajax listing files: ', e );}
	    }
	});		
}

function setParamDemoStartPos(new_val, isHtmlChange){	
	//convert each time to a number
	new_val 	=	Number(new_val);
	
	//validate new value
	if (typeof new_val 	=== 'number'		&&
		new_val  		>=	0				&&
		new_val			<	demo_end_pos	&&			
		new_val  		<	demo.length			
	){
		demo_start_pos			= new_val;
		
		//each time jump to beginning of the loop
		record_pos			= new_val;
		record_pos_helper 	= record_pos+1;
		
		if (isHtmlChange){
			$("#loop_start_pos").val( new_val ).change();
		}
		
	}else{				
		// set to minum possible value
		$("#loop_start_pos").val( 0 ).change();		
	}
	
	return 1;
}

function setParamDemoEndPos(new_val, isHtmlChange){
	//convert each time to a number
	new_val 	=	Number(new_val);
	
	if (	typeof new_val 	=== 'number'		&&
			new_val  		>=	0				&&
			new_val			>	demo_start_pos	&&			
			new_val  		<	demo.length			
	){
		demo_end_pos		= Number(new_val);
	
		//TODO: check if vars record* should be set to a new value
		if(record_pos > new_val ){
			record_pos			= new_val - 1;
			record_pos_helper 	= new_val;
		}
		
		if (isHtmlChange){
			$("#loop_end_pos").val( new_val ).change();
		}
		
	}else{		
		// set to maximum possible value
		$("#loop_end_pos").val( demo.length-1 ).change();		
	}
	
	return 1;
}

//function definition
function GetURLPath(){
	var str1 = document.location.origin + document.location.pathname;		
	//get the path without any filename at the end. Static variant: return str1.replace("index.html","");  			
	return	str1.substr(0, str1.lastIndexOf("/") + 1 );
}		

/////////////////////////////////////////////////////////////////////////////////////////////
function initW2UI(){
	
	// start top toolbar
	$(function () {		
		$('#toolbar').w2toolbar({
            name: 'toolbar',
            items: [				
				{ type: 'break',  id: 'break0' },
				{ type: 'radio',  id: 'w2ui_liveview',  	group: '1', caption: 'Liveview', icon: 'w2ui-icon-plus', checked: true },
                { type: 'radio',  id: 'w2ui_replay',  		group: '1', caption: 'Replay', icon: 'w2ui-icon-plus' },
                { type: 'radio',  id: 'w2ui_statistics',  	group: '1', caption: 'Statistics', icon: 'w2ui-icon-plus' },                
				{ type: 'break',  id: 'break1' },
                { type: 'check',  id: 'w2ui_drivertable', 	caption: 'drivers', icon: 'w2ui-icon-check', checked: SHOWDRIVERDATA },
                { type: 'check',  id: 'w2ui_tracktable', 	caption: 'tracks', icon: 'w2ui-icon-check', checked: SHOWTRACKLIST },
                { type: 'check',  id: 'w2ui_cartable', 		caption: 'cars', icon: 'w2ui-icon-check', checked: SHOWCARLIST },
                { type: 'check',  id: 'w2ui_dsdata', 		caption: 'DS Data', icon: 'w2ui-icon-check', checked: SHOWDSDATA },
				{ type: 'check',  id: 'w2ui_recstatistics', caption: 'Rec/Save/Load', icon: 'w2ui-icon-check', checked: SHOWRECSTATISTIC },
                { type: 'break',  id: 'break2' },
                { type: 'check',  id: 'w2ui_dssettings', 	caption: 'DS Set.', icon: 'w2ui-icon-pencil', checked: SHOWSETTINGS },
                { type: 'break', id: 'break3' },
                { type: 'html',  id: 'common_stats',
                    html: '<div id="pcars-apimode" style="padding: 3px 10px;">' +
                          'API' +
                          '</div>' 
				},
				{ type: 'break', id: 'break4' },
                { type: 'spacer' },
				{ type: 'html', id: 'item9',
                	html:	'<div id="pcars-scriptversion">Version: ' + SCRIPTVERSION + '</div>'
                }				                
            ],              		
        });
								
		//////////////////////////////////////////////////////
    	//// W2UI event handler
    	//w2ui.toolbar.on('*', function (event) { 
		w2ui.toolbar.on('click', function (event) { 
			if (event.target != undefined) {
	    		
	        	switch (event.target) {
	        	
	        		case "w2ui_drivertable": 	
	        									$( "#DriverDataArea" ).toggle();
	        									//w2ui.toolbar.items[5].icon = "w2ui-icon-cross";
	        									//w2ui.toolbar.refresh();	        									
	        									//this.refresh();
	        									//$( "#toolbar" ).refresh();
	        									break;
	        		
	        		case "w2ui_tracktable": 	$( "#TrackList" ).toggle(); break;
	        			             		             
	             	case "w2ui_cartable": 		$( "#CarList" ).toggle(); break;
	             			             	
	             	case "w2ui_dsdata":			$( "#DSdata" ).toggle(); break;
	             	
	             	case "w2ui_dssettings":		$( "#Settings" ).toggle(); break;
					
					case "w2ui_recstatistics":	$( "#DSRecStatistics" ).toggle(); break;
	             		             	
	             	case "w2ui_liveview":
	             								$( "#DSreplay" ).hide();
												$( "#DSstatistic" ).hide();
												$( ".pcarswindowgrp2" ).each(function( index ) {
													$( this ).removeClass( "pcars-force-hide" );	             									
             									});
												this.enable('w2ui_drivertable');
												this.enable('w2ui_tracktable');
												this.enable('w2ui_cartable');
												this.enable('w2ui_dsdata');
												break;	
	             	
	             	case "w2ui_statistics":		
	             								$( "#DSstatistic" ).fadeIn( "slow" ); 
	             								$( "#DSreplay" ).hide();	             								
	             								$( ".pcarswindowgrp2" ).each(function( index ) {
													$( this ).addClass( "pcars-force-hide" );	             									
             									});
	             								this.disable('w2ui_drivertable');
	             								this.disable('w2ui_tracktable');
	             								this.disable('w2ui_cartable');
	             								this.disable('w2ui_dsdata');
	             								
	             								//trigger lap Statistic call
	             								//alert ("test");
	             								initLap_LapChart();
	             								break;	             							
	             	
	             	case "w2ui_replay":			             								
	             								$( "#DSreplay" ).fadeIn( "slow" );
	             								$( "#DSstatistic" ).hide();	             									             								
	             								$( ".pcarswindowgrp2" ).each(function( index ) {
													$( this ).addClass( "pcars-force-hide" );	             									
             									});
	             								this.disable('w2ui_drivertable');
	             								this.disable('w2ui_tracktable');
	             								this.disable('w2ui_cartable');
	             								this.disable('w2ui_dsdata');
	             								break;
													             			             			             		             		
	        	}
	        	

	     	}
	    }); // end of w2ui.toolbar.on()
		
	}); // end of function top toolbar

	
}; // end of initW2UI()


       </script>
   </body>
</html>

