<!DOCTYPE html>
<html lang="de">
     <head>
         <meta charset="utf-8"/>
         <title>Project Cars DS - live view with position update.</title>
         
         <script src="https://maps.google.com/maps/api/js??v=3.exp&sensor=true"></script>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.3.3/d3.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/js-url/1.8.6/url.min.js"></script>
 
 	 <script src="./config.js" charset="utf-8"></script>
	 <script src="./pcars_driver.js" charset="utf-8"></script>
	 <script src="./pcars_track.js" charset="utf-8"></script>
	 <script src="./pcars_vehicle.js" charset="utf-8"></script>
	 <script src="./receive_ds_data.js" charset="utf-8"></script>
	 <script src="./calc_coordinates.js" charset="utf-8"></script>
	 <script src="./class_reference_points.js" charset="utf-8"></script>
	 <script src="./get_url_param.js" charset="utf-8"></script>

	<!--Ermoeglicht das verschieben von DIV Bloecken -->
	<!-- Jquery UI needed for jTable-->
        <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
        <script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
        <script>
                $(function() {
					$( "#DSdata" ).draggable();
					$( "#TrackList" ) .draggable();
					$( "#CarList" ) .draggable();
					$( "#DriverDataArea" ) .draggable();
					$( "#Settings" ) .draggable();
                });
		
		$(function() {
            		$( "#DSdata" ).resizable({
//             		animate: true
			ghost: true
            		});
//		        $( "#TrackList" ).resizable({
//               		ghost: true
//            		});
         	});
	
        </script>

	<!-- The jqGrid language file code-->
        <link rel="stylesheet" type="text/css" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/css/ui.jqgrid.css">
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/i18n/grid.locale-de.js"></script>
        <!-- The atual jqGrid code -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/jquery.jqGrid.src.js"></script>


        <!-- CSS definitions--> 
        <style type="text/css">

             html, body, #map {
                 width: 100%;
                 height: 100%;
                 margin: 0;
                 padding: 0;
             }
	     #DSdata{
				position: 	absolute; 
				left: 		55%; 
				top: 		0px; 
				width: 		300px; 
				height: 	200px;
				border:		1;
				background:	lightgreen;
	     }

	     #TrackList{
				position:       absolute;
                left:           5%;
                top:            45px;
                border:         1;
				text-align: 	center;
	     }
	     
	     #CarList{
				position:       absolute;
                left:           5%;
                top:            90px;
                border:         1;
				text-align: 	center;
	     }

	     #DriverData{
				position:       absolute;
                left:           55%;
				top:		250px;
	     }
		
	     #DriverDataArea{
				position:       absolute;
				left:           5%;
				top:            0px;
				background:	lightgrey
	     }
	     #hide or unhide objects
	     starthidden {
   				 display: none;
  		}

	     #Settings{
		position:       absolute;
                left:           75%;
                top:            25px;
                background:     lightgrey
	     }

             .stations, .stations svg {
                 position: absolute;
             }

             .stations svg {
                 width: 60px;
                 height: 20px;
                 padding-right: 100px;
                 font: 10px sans-serif;
             }

             .stations circle {
                 fill: brown;
                 stroke: black;
                 stroke-width: 1.5px;
             }
		.tableoption {
			background:     lightgrey;
		}


         </style>
     </head>
   <body>

	<!-- definition of data areas, the order of the tables decides which one is in foreground and which in background-->
	<div id="map"></div>
	<div id="DSdata">
		<p0>-</p0><br><p1></p1><br><p2></p2><br><p3></p3><br><p4></p4><br><p7></p7><br><p8></p8><br><p9></p9><br>----- Settings ----<br><p5></p5><br><p6></p6>
		<div id="DSdataInformation"></div>
		<div id="DSdataSettings"></div>
	</div>
	<div id="CarList">
		<table id="carlisttable"></table>
	</div>
	<div id="TrackList">
		<div class="tableoption" align="right">Stop refresh table:<input type="checkbox" id="cbTracklistRefresh"/></div>
		<table id="tracklisttable"></table>
	</div>
	<div id="DriverDataArea">
		<div class="tableoption" align="right">Stop refresh table:<input type="checkbox" id="cbDriverlistRefresh"/></div>
		<table id="DriverDataTable"></table>
	</div>

	<!-- definition of option panel-->	
	<div id="Settings">
		Settings: <br>

		<!-- API dropdown -->
		<form action="#">
		  <fieldset id="fieldset">
			<label for="APIMODE">Select API Type</label>
	    		<select class="APIMODE" name="APIMODE" id="APIMODE">
	      			<option selected="selected">DS</option>
	      			<option>CREST</option>
			</select>
		</fieldset>
		</form>

		<br>----<br>
		<p>
  			<label for="amount">DisplayDurationCorrector:</label>
			<input type="text" id="amount" readonly style="border:0;">
		</p> 			
		<!-- Slider Duration -->
		<div id="slider-range-max"></div>
	</div>

       <script>
	// initialize vars
	var aDrivers 			= new Array();		// array for PCARSdriver objects
	var aSensorData 		= new Array();		// array of Hashes, each hash includes parameters of a driver
	var XMLHTTPTimeout		= 2000;
	var StopTransitionDelay = "false";	// if set to true, DisplayDuration set to 0 ( cases: zoom, mapchange )
	var global_i			= 0;
	var map;				// google map object
	var sensorLayer;
	var sensorLayer_UpdateTime;		//time, when marker are updated
        var sensorLayer_UpdateTime_old;		//time of the recent dsdata-worker run, when the marker were updated
        var sensorLayer_UpdateDelta;		//time between recent and current dsdata-worker run, when the marker were updated
	var DisplayDurationCorrector = 0;
	var aRefPointTMP		= new Refpoint("-1");			// hash of all RefPoints for available tracks
	var StopRefreshTracklist	=	"false";
	var StopRefreshDriverlist	=	"false";
	var APIMODE					=	"DS";   // possible values DS,CREST
	var PCARSd	= new PCARSdriver(
									9234567
									,"NO_PARTICIPANT_TestData"
									,3
									,277
									,278
									,279
									,"StateTest"
									,"Sector1"
									,"123"
									,"123456"
									,"123456"
									,"0"
									,"321"
									,{TrackId: 920145926}
								); // only use the object to get functions of it
						
								
	// hide or unhide objects defined within config.js
	if ( SHOWTRACKLIST 	== false ) { 	$( "#TrackList" ).hide();			}
	if ( SHOWDSDATA 	== false ) { 	$( "#DSdata" ).hide();				}						
	if ( SHOWDRIVERDATA	== false ) { 	$( "#DriverDataArea" ).hide();		}
	if ( SHOWSETTINGS	== false ) { 	$( "#Settings" ).hide();			}
	if ( SHOWCARLIST	== false ) { 	$( "#CarList" ).hide();			}
	
	
	
								
	// check if url params overwrite the default ds info
	if (get_url_param('dsurl') && get_url_param('dsport'))
        {
			DsServerURL     =       get_url_param('dsurl');
			DsPort          =       get_url_param('dsport');

			if(log >= 3){
				console.log("overwrite ds default settings with: " 
					+ get_url_param('dsurl') 
					+ " / " 
					+ get_url_param('dsport'));
			}
	}
	
	// check if url params overwrite the default CREST info
	if (get_url_param('cresturl') && get_url_param('crestport'))
	{
		CRESTServerURL		=	get_url_param('cresturl');
		CRESTPort		=	get_url_param('crestport');
		APIMODE			=	"CREST";
		DisplayDuration		=	DisplayDurationCREST;
		document.getElementById("fieldset").elements.namedItem("APIMODE").value = "CREST";
		
		if(log >= 3){
			console.log("overwrite crest default settings with: " 
				+ get_url_param('cresturl') 
				+ " / " 
				+ get_url_param('crestport'));
		}
	}


	// set to global var, to modify in future stage for periodical updates via ajax
	var DsName			=	"-+-"; // aDsData.name;
	var DsState			=	"-+-"; //aDsData.state;		//idle/running
	var DsTrackName		=	"Slightly Mad Studios Ltd";		//aTrackList[aDsData.TrackId];
	var DsMaxMemberCnt	=	"-+-"; //aDsData.max_member_count;
	var cuircitID		=	9999999999;		//aDsData.TrackId;	


	/////////////////////////////////////
	// Event Handler
	// Dropdown API
	$( ".APIMODE" ).change(function() {

                var str = "";
                $( "select option:selected" ).each(function() {
                      str += $( this ).text();
                });

                APIMODE = str;
        });

	// Event handler for Slider
	$(function() {
		$( "#slider-range-max" ).slider({
			range: "max",
			min: -200,
			max: 1000,
      			value: DisplayDurationCorrector, 
			step: 25,
      			slide: function( event, ui ) {
        			$( "#amount" ).val( ui.value );
				//set new value
				DisplayDurationCorrector = ui.value;
      			}
    		});
    		$( "#amount" ).val( $( "#slider-range-max" ).slider( "value" ) );
  	});

	// initiate jqGrid for DriverData
	// todo: make table searchable   and  add new Theme
	// todo: add subgrid information like: Long,Lat,RefPoint,...
	jQuery("#tracklisttable").jqGrid({	
	        datatype: "local",
	        height: 250,
	        hiddengrid: true,
	        colNames:['ID','TrackID','TrackName','Max Gridsize', 'RefPoints exists?','Comment'],
	        colModel:[
					{name:'id', index:'id', formatter: 'integer', width:100, sorttype:"int"},
					{name:'trackid', index:'trackid', width:100, sorttype:"int"},
					{name:'trackname', index: 'trackname', width:200, sorttype:"text"},
					{name:'gridsize', width:40, align:"right", sorttype:"int"},
					{name:'refpoint', width:90, align:"center", sorttype:"text"},
					{name:'comment', width:160, align:"left", sorttype:"text"},
	        ],
	        caption: "List of available Tracks",
		rowNum: 200,
	});
	
	// add filter option bar
	jQuery("#tracklisttable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });

	// initial data for grid !!! Needed because of Refresh problem !!
	// todo: really needed ?
	jQuery("#tracklisttable").jqGrid('addRowData',0,{	
								id: 		0
								,trackid:	"2" 
								,trackname:	"initialdata2"
								,gridsize:	"-"
								,refpoint:	"no"
								,comment:	"test comment" 
							});

	// car lis overview
	jQuery("#carlisttable").jqGrid({	
	        datatype: "local",
	        height: 250,
	        hiddengrid: true,
	        colNames:['ID','CarName','Set1','Set2', 'Set3','Comment'],
	        colModel:[
					{name:'id', index:'id', formatter: 'integer', width:100},
					{name:'trackid', index:'trackid', width:100},
					{name:'trackname', index: 'trackname', width:200},
					{name:'gridsize', width:40, align:"right"},
					{name:'refpoint', width:90, align:"center",sorttype:"float"},
					{name:'comment', width:160, align:"left"},
	        ],
	        caption: "List of available Cars with properties.",
		rowNum: 200,
	});
	
	

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create DS data object
	var workerDSDATA      =       new Worker('./worker_dsdata.js');
	sensorLayer_UpdateTime_old = Date.now();	//initialize a value for first time
	//event handler of the worker
	workerDSDATA.addEventListener('message', function(e) {
		
		if(log >= 3){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: ', e);}
		if (e.data.driverlist[0].Name != "NO_PARTICIPANT_TestData"){
                        if(log >= 2){console.log('+++++++++++ GETDSANDDRIVERDATA Worker returned: PosX:' + e.data.driverlist[i].PosX + ", Speed:" + e.data.driverlist[i].Speed);}
                }
                
		// write in HTML page for DS status
		document.getElementsByTagName('p0')[0].innerHTML = 'DS URL:   		' + DsServerURL + " : " +  DsPort; 
		document.getElementsByTagName('p1')[0].innerHTML = 'DS Status:   	' + e.data.globals.state;
		document.getElementsByTagName('p2')[0].innerHTML = 'DS Joinable: 	' + e.data.globals.joinable;
		document.getElementsByTagName('p3')[0].innerHTML = 'DS Lobby ID: 	' + e.data.globals.lobbyid;
		document.getElementsByTagName('p4')[0].innerHTML = 'DS now:      	' + e.data.globals.now; 
		document.getElementsByTagName('p5')[0].innerHTML = 'used API type:	' + APIMODE;
		document.getElementsByTagName('p6')[0].innerHTML = 'Display Duration:      ' + DisplayDuration;
		document.getElementsByTagName('p7')[0].innerHTML = 'TrackName:     	' + e.data.arefpoint[e.data.globals.attributes.TrackId]["Name"];		
		document.getElementsByTagName('p8')[0].innerHTML = 'SessionStage:   ' + e.data.globals.attributes.SessionStage;
		document.getElementsByTagName('p9')[0].innerHTML = 'SessionState:   ' + e.data.globals.attributes.SessionState;
		
		//todo:  replace document.get... by Jquery functionality
		//$('#DSdataInformation').append( 
		//				$("<p0>").text("DS URL2: " + DsServerURL + " : " +  DsPort)
		//);
		
		
		
		
		/////////////////////////////////////////// update driver data /////////////////////
		// refresh table of Driver data
        refreshDriverList(e.data.driverlist);
		
		//todo var declaration needed within loop ???
		var tmpcuircitID;

		//update map
		for (var i = 0; i < e.data.driverlist.length; i++ ){

				// calculate GPS coordinates
				gpsCoTmp =  calc_coordinates (cuircitID , e.data.driverlist[i].PosX , e.data.driverlist[i].PosZ , e.data.arefpoint);

				// fill data array
				aSensorData[i] = {
						"Key": 				e.data.driverlist[i].Name
						,"MarkerLabel" :	e.data.driverlist[i].RacePosition + "-" + e.data.driverlist[i].Name
						,"DateTime":		"2013-09-04T09:41:09+10:00"
						,"Lat": 			gpsCoTmp["Lat"]
						,"Long": 			gpsCoTmp["Long"]
						,"Heading":			286.0
						,"Speed":			22
				}
				
        		tmpcuircitID = e.data.driverlist[i].variousParameters.TrackId;
		}
		
		sensorLayer_UpdateTime = Date.now();
                sensorLayer_UpdateDelta = sensorLayer_UpdateTime - sensorLayer_UpdateTime_old;	//Determine time duration between recent and currrent worker run
                sensorLayer_UpdateTime_old = sensorLayer_UpdateTime;
                if(log >= 2){console.log("+++++++++Sensor Update Delta:",sensorLayer_UpdateDelta);}
                
                DisplayDuration = sensorLayer_UpdateDelta + DisplayDurationCorrector;
                if (DisplayDuration < 0) { DisplayDuration = 0 }	//catch a negative value
                if (APIMODE == "DS" && DisplayDuration < UpdateRateDS) { DisplayDuration = UpdateRateDS }	//If the worker runs more often than the data is updated in the DS API, then the duration is set to the DS update rate
                if (DisplayDuration > 2000) { DisplayDuration = 2000 }	// set a max DisplayDuration
                if(log >= 2){console.log("+++++++++DisplayDuration:    ",DisplayDuration);}
                
                //if(log >= 3){console.log("++++++++ aSensorData_NEW" , aSensorData);}
		sensorLayer.update(aSensorData);

		// in case track changes on DS adjust the map settings for new possition
        if ( (cuircitID != tmpcuircitID) && ( typeof tmpcuircitID != 'undefined') ){

        	//if(log >= 3){console.log("----------- TrackID SHOULDbe changed: ", aRefPointTMP);}
            //map.setCenter({lat: 50.332733, lng: 6.943355});
			changeMapSettings(e.data.arefpoint[tmpcuircitID] , map);

            cuircitID = tmpcuircitID;  // give the global var the new TrackId
            if(log >= 3){console.log("----------- TrackID changed. Call map.SetCenter(),  cuircitID / tmpcuircitID " + cuircitID + " / " + tmpcuircitID);}
		}
		
		//call worker again for next itteration -> currently endless loop
		if (APIMODE == "DS"){
			//DS receive mode
			workerDSDATA.postMessage({
				workerdelay: 		WORKERDELAY_DSDATA
				,dsurl:			DsServerURL
				,dsport:		DsPort
				,timeout:		XMLHTTPTimeout
				,receivemode:	"GETDSANDDRIVERDATA"
				,arefpoint:		e.data.arefpoint});
		}else{
			//CREST receive mode
			workerDSDATA.postMessage({
				workerdelay: 		WORKERDELAY_DSDATA
				,dsurl:			CRESTServerURL
				,dsport:		CRESTPort
				,timeout:		XMLHTTPTimeout
				,receivemode:	"GETCRESTDRIVERDATA"
				,arefpoint:		e.data.arefpoint});
		}
		
	}, false);
	
	//initail call of the worker
	workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSANDDRIVERDATA", arefpoint: aRefPointTMP});


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// receive data from pcars dedicated server (DS) and returns an array of PCARSdriver objects
	//	   Receive_DS_data(url,port,timeout,RetrivelMode)
	// initial call for map initialization
	if (APIMODE == "DS"){
		aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDSANDDRIVERDATA", aRefPointTMP);
	}else{
		aDrivers = Receive_DS_data(CRESTServerURL, CRESTPort, 2000, "GETCRESTDRIVERDATA", aRefPointTMP);
	}
	
	for (var i = 0; i < aDrivers.length; i++ ){

		// calculate GPS coordinates
		if(log >= 3){console.log("-------- aDrivers: " , aDrivers[i] );}
		gpsCoTmp =  calc_coordinates (cuircitID , aDrivers[i].GetPosX() , aDrivers[i].GetPosZ() , aRefPointTMP );

		// fill data array
		aSensorData[i] = {
				"Key": aDrivers[i].GetName()
				,"MarkerLabel" : buildDriverName ( aDrivers[i].GetRacePosition(), aDrivers[i].GetName() )
				,"DateTime":"2013-09-04T09:41:09+10:00"
				,"Lat": gpsCoTmp["Lat"]
				,"Long": gpsCoTmp["Long"]
				,"Heading":286.0
				,"Speed":22
		}
		// bookmark current TrackID to detect track changes and adjust Map
		tmpcuircitID = aDrivers[i].GetVariousParameter("TrackId");
	}

	// init google map
	init_map(cuircitID , aRefPointTMP);

	// add map Listener
	map.addListener('zoom_changed', function() {
		if(log >= 3){console.log("+++++++++++++++++++++++++++++++++++++++++++ current StopTransitionDelay: " , StopTransitionDelay);}
        	StopTransitionDelay = "true";
		if(log >= 3){console.log("+++++++++++++++++++++++++++++++++++++++++++ set StopTransitionDelay to: " , StopTransitionDelay);}
  	});

	// create Table with list of all tracks
	// checkbox Event handling
	$('#cbTracklistRefresh').click(function () {

		if ($('#cbTracklistRefresh').is(':checked') == true) {
			StopRefreshTracklist 	= "true";
			WORKERDELAY_TRACKLIST 	= 10000;
		}else{
			StopRefreshTracklist 	= "false";
			WORKERDELAY_TRACKLIST	= 5000;
		}
	})


	// create worker for Tracklist updates //////////////////////////////////////////////////////////////////////
	var w_tracklist      =       new Worker('./worker_tracklist.js');
	
	w_tracklist.addEventListener('message', function(e) {

			if(log >= 3){console.log("+++++++++++ GETTRACKLIST Worker Trackliste Event: ", e );}
					
		//	var str = e.data;	// data string from return object

			refreshTrackList(buildTracklist(e.data.aTrack , aRefPointTMP ));
			w_tracklist.postMessage({
								workerdelay: 	WORKERDELAY_TRACKLIST
								,dsurl: 		DsServerURL
								,dsport: 		DsPort
								,timeout: 		2000
								,receivemode: 	"GETTRACKLIST" 
								,aRefpoint:		e.data.aRefpoint});
	}, false);
	
	//initial call of the tracklist worker. initiate endless loop
	w_tracklist.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETTRACKLIST", aRefpoint: aRefPointTMP });



	//todo: add subgrid for more drivers information
	jQuery("#DriverDataTable").jqGrid({
                datatype: "local",
                height: 200,
		width: 800,
		hiddengrid: true,
		caption: "List of available drivers",
                colNames:['RefID','Pos', 'Driver Name', 'State', 'Sector', 'Lap', 'Vehicle', 'fastest lap', 'last lap','PosX', 'PosY', 'PosZ' ],
                colModel:[
                        {name:'refid',hidden: true, index:'invdate', width:40, sorttype:"int"},
			{name:'driverposition', width:18, sorttype:"int", search:true},
                        {name:'drivername', width:80,sorttype:"text", search:true},
			{name:'driverstate',width:40, align:"center",sorttype:"text"},
			{name:'driversector',width:20, align:"center",sorttype:"int"},
			{name:'lapnumber',width:18, align:"center",sorttype:"int"},
			{name:'vehiclename',width:40, align:"center",sorttype:"text"},
			{name:'fastestlap',width:35, align:"center",sorttype:"text"},
			{name:'lastlap',width:35, align:"center",sorttype:"text"},
			{name:'posx',hidden: true,width:20, align:"center",sorttype:"float"},
                        {name:'posy',hidden: true,width:20, align:"center",sorttype:"float"},
                        {name:'posz',hidden: true,width:20, align:"center",sorttype:"float"}
                ]
	});
	
	// add filter option bar
	jQuery("#DriverDataTable").jqGrid('filterToolbar', { stringResult: true, searchOnEnter: false, defaultSearch: "cn" });
	// sort driver table on startup
	jQuery("#DriverDataTable").jqGrid('sortGrid',"driverposition",false,"asc");
	
	// checkbox Event handling
        $('#cbDriverlistRefresh').click(function () {

                if ($('#cbDriverlistRefresh').is(':checked') == true) {
                        StopRefreshDriverlist   = "true";
                }else{
                        StopRefreshDriverlist  	= "false";
                }
        })

	
	// setting up google maps overlays
	function GPSSensor(initData) {
               //state information
               var _div = null;
               var _data = initData;
               var _projection = null;

               function transform(d) {
                   var padding = 10;                   
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this) 
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }
               
               function transformWithEase(d) {
                   var padding = 10;
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this)
                       .transition().duration(DisplayDuration)
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }

               //superclass methods for google maps
               this.onAdd = function() {
                   _div = d3.select(this.getPanes().overlayLayer)
                            .append("div")
                            .attr("class", "stations");
               };               
                              
               this.draw = function () {                   
                   var padding = 10;
                   _projection = this.getProjection();
		  
                   var marker = _div.selectAll("svg")
                       .data(_data, function (d) { return d.Key; })
                       .each(transform) // update existing markers
                        .enter().append("svg:svg")
                       .each(transform)
                       .attr("class", "marker");

		   if(log >= 3){console.log("++ Marker" , marker);}

                   // Add a circle.
                   marker.append("svg:circle") 
                       .attr("r", 4.5)
                       .attr("cx", padding)
                       .attr("cy", padding)
		       .style("fill", "red");

		//todo experimental method call	
		//marker.text("test123456");	
		   if(log >= 3){console.log("Marker: " , marker);}
		

                   // Add a label.
		   if(log >= 3){console.log ("++++ in function draw() ->  aSensorData: " , aSensorData);}
                   marker.append("svg:text")
                       .attr("x", padding + 7)
                       .attr("y", padding)
                       .attr("dy", ".31em")
			//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
			//      it seem that the function within .text(...) will called only once at the beginning 
			//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
		       .text(function (d) {
						if(log >= 3){console.log("+++++ d: " , d );}
						if(log >= 3){console.log("+++++ this: " , this );}

						for (var i = 0; i < aSensorData.length; i++){
						
							if(log >= 3){console.log(" for Update MarkerLabel:" , aSensorData);}
							if (aSensorData[i].Key == d.Key){
								if(log >= 3){console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);}
								return  aSensorData[i].MarkerLabel;
							}
						}
						
						//todo: during update d is not an array its an individual hash
						if(log >= 3){console.log("++++not array:");}
						return d.MarkerLabel;
						
					})
               //       .text(function (d) { return d.Key; });                                      
               };

               this.onRemove = function () {
                   _div.remove();
               };


		// todo: known issue: Beim Wechsel der Position, bleibt eine "Leiche" auf der Karte uebrig, weil Key "Pos - Name" zusammensetzt
		// easyt solution:  deleting leading position number 
               this.update = function (data) {                    
                   //update internal data which drive redrawing on zoom_changed                  

                 	for (var i = 0; i < data.length; i++) {
			       //if(log >= 3){console.log ("------------------------------------------- data", data);}
	                       var found = false;
	                       for (var j = 0; j < _data.length; j++) {
	                           if (_data[j].Key === data[i].Key) {
	        	                       found = true;
	                               _data[j].Lat = data[i].Lat;
	                               _data[j].Long = data[i].Long;
				       _data[j].MarkerLabel = data[i].MarkerLabel;
				//	if(log >= 3){console.log("---12 _data changes for key:" + _data[j].Key + " // " + data[i].Key);}
	                           }
	                       }
	                       if (!found)
	                           _data.push(data[i]);
	                   }

			   //todo: what does this draw() call ?
			   if(log >= 3){console.log ("THIS Updated data:" , _data);}
			   if(log >= 3){console.log ("THIS:" , this);}

			   if( StopTransitionDelay == "true" )
			   {
				if(log >= 3){console.log ("++++++++++++++++++++++++++++++ stopped StopTransitionDelay: " , StopTransitionDelay );}
				this.draw();
                                   _div.selectAll("svg")
                                       .data(_data, function (d) { return d.Key; })
                                       .each(transform);

				// reset to default after zoom event finished
                                StopTransitionDelay = "false";
			
			   }else{

				if(log >= 3){console.log ("++++++++++++++++++++++++++++++ normal StopTransitionDelay: " , StopTransitionDelay );}
		                   this.draw();
		                   _div.selectAll("svg")
		                       .data(_data, function (d) { return d.Key; }) 
		                       .each(transformWithEase);                

				// reset to default after zoom event finished
				StopTransitionDelay = "false";
			   }		 
               };
           }


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////				
//////////////////////////////////////////////////////////////////////////
function init_map(_TrackID , aRefPoint)
{
	
           //subclassing
           GPSSensor.prototype = new google.maps.OverlayView();


           // Create the Google Map
           map = new google.maps.Map(d3.select("#map").node(), {
               zoom: aRefPoint[cuircitID]["Zoom"],

                // use cuircit RefPoint for center google map
                center: new google.maps.LatLng( aRefPoint[_TrackID]["MapInitLat"] , aRefPoint[_TrackID]["MapInitLong"] ),
                mapTypeId: google.maps.MapTypeId.SATELLITE
           });

           //if(log >= 3){console.log("-+-+- aSensorData-Array: ", aSensorData);}
           sensorLayer = new GPSSensor(aSensorData);
           sensorLayer.setMap(map);
}

function changeMapSettings(newTrackObj, mapobj)
{
	if(log >= 3){console.log("----- call function changeMapSettings() with track data: " , newTrackObj );}
	if(log >= 3){console.log("----- call function changeMapSettings() with map data: " , mapobj );}

	//todo: replace map (global variable) with mapobj(if this is not a copy)
	//example: map.setCenter({lat: 50.332733, lng: 6.943355});
        map.setCenter({lat: newTrackObj["MapInitLat"], lng: newTrackObj["MapInitLong"]});

        map.setZoom(newTrackObj["Zoom"]);


	//todo: change also picture Overlay prevered mapsourc(google,openstreetmap) in needed
        return 1;
}

///////////////////
function refreshTrackList(a)
{
	if(log >= 3){console.log("------------------------ refreshTrackList() parameter a : " , a);}

	// if set to true, no refresh of table wanted
	if (StopRefreshTracklist == "true")
	{
		if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshTracklist set to:", StopRefreshTracklist );}
		return 1;
	}

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#tracklisttable").jqGrid("clearGridData");

	var gridcnt = 0;
	var _data;

	
	for (var key in a ){

		//if(log >= 3){console.log("--- Info for loop value a[key]: ", a[key]);}
		_data = {
                                        id:             gridcnt
                                        ,trackid:       a[key]["trackid"]
                                        ,trackname:     a[key]["trackname"]
                                        ,gridsize:      a[key]["gridsize"]
                                        ,refpoint:      a[key]["refpoint"]
                                        ,comment:       a[key]["comment"]
                                };		
		jQuery("#tracklisttable").jqGrid('addRowData',gridcnt, _data);

		gridcnt++
	}

	// relaod data into jqGrid
	jQuery("#tracklisttable").trigger("reloadGrid");
	
}
//////////////////
function refreshDriverList(a)
{
	// if set to true, no refresh of table wanted
        if (StopRefreshDriverlist == "true")
        {
                if(log >= 3){console.log("--- INFO stop refresh tracklist because StopRefreshDriverlist set to:", StopRefreshDriverlist );}
                return 1;
        }

	if(log >= 3){console.log("refreshDriverList(e): " , a);}
	var grididcnt = 0;
	var _data;
	var _allDrivers = new Array();

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#DriverDataTable").jqGrid("clearGridData");	

        // get current size of the table
        var GridSize = jQuery("#DriverDataTable").getGridParam("reccount");	


	//todo: if drivertable is longer then new driverlist, all old values should be deleted
	//todo: if clearGridData method is working, no need for a decision if use setRowData or addRowData !
	if(log >= 3){console.log ("++++++++ length of driverlist array:" + a.length);}
	for (i=0; i < a.length; i++)
	{
		//if(log >= 3){console.log("update data on row: " + i + " / " + a.data);}
		//if(log >= 3){console.log("update data on row: " + i + " / " + a.data[i]);}
		_data = {   
					refid:				a[i].RefID
					,driverposition:	a[i].RacePosition	
					,drivername:		a[i].Name
					,driverstate:		a[i].State
					,driversector:		a[i].CurrentSector
					,fastestlap:		PCARSd.GetFastestLapTime(  a[i].FastestLapTime )
					,lastlap:			PCARSd.GetLastLapTime(  a[i].LastLapTime )
					,posx:				a[i].PosX
					,posy:				a[i].PosY
					,posz:			a[i].PosZ
		};
		//decision if replace or add a row to jqGrid
		if (i < GridSize){
				jQuery("#DriverDataTable").jqGrid('setRowData',i, _data);
				//if(log >= 3){console.log("+++++ set " + i );}
		}else{
				jQuery("#DriverDataTable").jqGrid('addRowData',i, _data);
				//if(log >= 3){console.log("+++++ add " + i );}
		}
		grididcnt++;
	
		//build hash for clean up map	
		_allDrivers[buildDriverName(a[i].Name, a[i].RacePosition)] =  {driverposition : a[i].RacePosition};

	}

	jQuery("#DriverDataTable").trigger("reloadGrid");

	CleanupDriverObjects(_allDrivers);

	return 1;
}

function buildDriverName(drivername , raceposition)
{
	// Diego Xavier on race position 5 => "5-Diego Xavier"
	return raceposition + "-" + drivername;
}

function CleanupDriverObjects(allDrivers)
{
        //if(log >= 3){console.log("---------- Call function CleanupDriverObjects() with driver list ----" , allDrivers );}
	
	var svgs = 	d3.selectAll("svg")
			.each(function( obj ) {
				if(log >= 3){console.log("---------- svg object this:" , this );}
		
				if ( allDrivers[this.textContent] === undefined )
				{
					if(log >= 3){console.log("------- Ghost car found and delete it from map (this.textContent: " , this.textContent);}
					//todo: delete ghost cars from map via D3 functions
					this.remove();
				}
			});
	//todo: maybe add an additional routine for cleaning up Driver names

        return 1;
}




///////////////////
function buildTracklist( aTrackList , aRefPointTMP ){

	var aRefPointInt	= aRefPointTMP; // copy object to a new one, because the object will be changed
	var commenttmp 		= '';
	var tmpObj;
	var aNewTrackList 	= new Array();
	var aTmpTracklist	= new Array();

	//if(log >= 3){console.log("--------------------------------- buildTracklist() for DSTrackList:" , aTrackList);}
	//if(log >= 3){console.log("-------------------------- buildTracklist() with:" , aRefPointInt);}

	// go through all responded tracks from pcars dedicated server
	for (var i=0; i < aTrackList.length; i++)
	{

		tmpObject = aTrackList[i];
		//if(log >= 3){console.log("--------------------------------- buildTracklist() tmpObject: " , tmpObject);}

		//if refpoint for a track exists
		if (aRefPointInt[tmpObject.trackid]){

			aNewTrackList[tmpObject.trackid] = { 	
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"yes"
				,comment:	aRefPointInt[tmpObject.trackid]["Comment"]
            };

		//no Refpoint entry exists , fill with dummy values
		}else{
			
			aNewTrackList[tmpObject.trackid] = {
				trackid:	tmpObject.trackid
				,trackname:	tmpObject.name
				,gridsize:	tmpObject.gridsize
				,refpoint:	"no"
				,comment:	"no comment because no refpoint"
           };
		}
			
		// delete objects that allready covered by DS output from RefpointArray
		delete aRefPointInt[tmpObject.trackid];
	}

	//fill up with refpoint entries taht are not listed in DS array
	for (var key in aRefPointInt ){
		
		//if(log >= 3){console.log("--------------------------------- buildTracklist() aRefPointInt[key]" , aRefPointInt[key] );}

		tmpObject = aRefPointInt[key];

		// check if comment field exists in the RefPoint array
		commenttmp = '';
		if ( 'Comment' in tmpObject ) {  commenttmp = tmpObject["Comment"];  };

		aNewTrackList[key] = {
				trackid:	key
				,trackname:	aRefPointInt[key]["Name"]
				,gridsize:	"no info"
				,refpoint:	"yes"
				,comment:	commenttmp 
		};
	}

	if(log >= 3){console.log("--------------------------------- buildTracklist() with refpoint information:" , aNewTrackList);}

	return aNewTrackList;
}

       </script>
   </body>
</html>

