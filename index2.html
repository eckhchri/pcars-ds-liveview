<!DOCTYPE html>
 <html>
     <html lang="de">
     <head>
         <meta charset="utf-8"/>
         <title>Project Cars DS - live view with position update.</title>
         
         <script src="https://maps.google.com/maps/api/js??v=3.exp&sensor=true"></script>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.3.3/d3.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/js-url/1.8.6/url.min.js"></script>
 
	 <script src="./pcars_driver.js" charset="utf-8"></script>
	 <script src="./receive_ds_data.js" charset="utf-8"></script>
	 <script src="./calc_coordinates.js" charset="utf-8"></script>
	 <script src="./class_reference_points.js" charset="utf-8"></script>
	 <script src="./get_url_param.js" charset="utf-8"></script>

	<!--Ermoeglicht das verschieben von DIV Bloecken -->
	<!-- Jquery UI needed for jTable-->
        <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
        <script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
        <script>
                $(function() {
                    $( "#DSdata" ).draggable();
		    $( "#TrackList" ) .draggable();
		    $( "#DriverDataArea" ) .draggable();
		    $( "#Settings" ) .draggable();
                });
		
		$(function() {
            		$( "#DSdata" ).resizable({
//             		animate: true
			ghost: true
            		});
//		        $( "#TrackList" ).resizable({
//               		ghost: true
//            		});
         	});
	
        </script>

	<!-- The jqGrid language file code-->
        <link rel="stylesheet" type="text/css" media="screen" href="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/css/ui.jqgrid.css"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/i18n/grid.locale-de.js"></script>
        <!-- The atual jqGrid code -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqgrid/4.6.0/js/jquery.jqGrid.src.js"></script>


        <!-- CSS definitions--> 
        <style type="text/css">

             html, body, #map {
                 width: 100%;
                 height: 100%;
                 margin: 0;
                 padding: 0;
             }
	     #DSdata{
		position: 	absolute; 
		left: 		55%; 
		top: 		0px; 
		width: 		300px; 
		height: 	125px;
		border:		1;
		background:	lightgreen;
	     }

	     #TrackList{
		position:       absolute;
                left:           5%;
                top:            0px;
                border:         1;
		text-align: 	center;
	     }

	     #DriverData{
		position:       absolute;
                left:           55%;
		top:		250px;
	     }
		
	     #DriverDataArea{
		position:       absolute;
		left:           5%;
		top:            45px;
		background:	lightgrey
	     }

	     #Settings{
		position:       absolute;
                left:           75%;
                top:            25px;
                background:     lightgrey
	     }

             .stations, .stations svg {
                 position: absolute;
             }

             .stations svg {
                 width: 60px;
                 height: 20px;
                 padding-right: 100px;
                 font: 10px sans-serif;
             }

             .stations circle {
                 fill: brown;
                 stroke: black;
                 stroke-width: 1.5px;
             }
		.tableoption {
			background:     lightgrey;
		}


         </style>
     </head>
   <body>

	<!-- definition of data areas-->
	<div id="map"></div>
	<div id="DSdata"><p0>-</p0><br><p1></p1><br><p2></p2><br><p3></p3><br><p4></p4><br>----- Settings ----<br><p5></p5></div>
	<div id="DriverDataArea">
		<div class="tableoption" align="right">Stop refresh table:<input type="checkbox" id="cbDriverlistRefresh"/></div>
		<table id="DriverDataTable"></table></div>	
	<div id="TrackList">
		<div class="tableoption" align="right">Stop refresh table:<input type="checkbox" id="cbTracklistRefresh"/></div>
		<table id="tracklisttable"></table></div>

	<!-- definition of option panel-->	
	<div id="Settings">
		Settings: <br>

		<!-- API dropdown -->
		<form action="#">
		  <fieldset>
			<label for="APIMODE">Select API Type</label>
	    		<select class="APIMODE" name="APIMODE" id="APIMODE">
	      			<option selected="selected">DS</option>
	      			<option>CREST</option>
			</select>
		</fieldset>
		</form>
	</div>

       <script>
	// initialize vars
	var aDrivers 	= new Array();		// array for PCARSdriver objects
	var aSensorData = new Array();		// array of Hashes, each hash includes parameters of a driver
	var DsServerURL = "www.eckhchri.de";
	var DsPort	= 9000;
	var CRESTServerURL = "localhost";
	var CRESTPort = 8080;
	var XMLHTTPTimeout = 2000;
	var DisplayDuration = 600;		// duration for displaying marker updates
	var global_i		= 0;
	var map;				// google map object
	var sensorLayer;
	var aRefPointTMP;			// hash of all RefPoints for available tracks
	var WORKERDELEAY_TRACKLIST	=	5000; 	// in ms
	var WORKERDELEAY_DRIVERLIST	=	200;	// in ms
	var StopRefreshTracklist	=	"false";
	var StopRefreshDriverlist	=	"false";
	var APIMODE			=	"DS";   // possible values DS,CREST
	var PCARSd	= new PCARSdriver(
                                                                        9234567
                                                                        ,"NO_PARTICIPANT_TestData"
                                                                        ,3
                                                                        ,277
                                                                        ,278
                                                                        ,279
                                                                        ,"StateTest"
                                                                        ,"Sector1"
                                                                        ,"123"
                                                                        ,"123456"
                                                                        ,"123456"
                                                                        ,"0"
                                                                        ,"321"
                                                                        ,{TrackId: 920145926}
                                                ); // only use the object to get functions of it


	// check if url params overwrite the default ds info
	if (get_url_param('dsurl') && get_url_param('dsport'))
        {
                DsServerURL     =       get_url_param('dsurl');
                DsPort          =       get_url_param('dsport');

		console.log("overwrite ds default settings with: " 
				+ get_url_param('dsurl') 
				+ " / " 
				+ get_url_param('dsport'));
	}


	// set to global var, to modify in future stage for periodical updates via ajax
	var DsName 		=	"-+-"; // aDsData.name;
	var DsState		=	"-+-"; //aDsData.state;		//idle/running
	var DsTrackName		=	"Hockenheim";		//aTrackList[aDsData.TrackId];
	var DsMaxMemberCnt	=	"-+-"; //aDsData.max_member_count;
	var cuircitID		=	1695182971;		//aDsData.TrackId;	

        // initialize RefPoint
        aRefPointTMP         =      new Refpoint( cuircitID );

	// Test - determine TrackID by Game API Name
	var testname = BuildTrackNameFromGameAPI("Road America","");
        var testID = GetTrackIDbyName(testname);
        console.log("TRACKID: " , testID);


	/////////////////////////////////////
	// Event Handler
	// Dropdown API
	$( ".APIMODE" ).change(function() {

                var str = "";
                $( "select option:selected" ).each(function() {
                      str += $( this ).text() + " ";
                });

                APIMODE = str;
        });



	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// create DS data object
	var workerDSDATA      =       new Worker('./worker_dsdata.js');

        //event handler of the worker
        workerDSDATA.addEventListener('message', function(e) {
                console.log('Worker said: ', e.data);
                // write in HTML page
		document.getElementsByTagName('p0')[0].innerHTML = 'DS URL:   ' + DsServerURL + " : " +  DsPort;
                document.getElementsByTagName('p1')[0].innerHTML = 'DS Status:   ' + e.data.state;
		document.getElementsByTagName('p2')[0].innerHTML = 'DS Joinable: ' + e.data.joinable;
		document.getElementsByTagName('p3')[0].innerHTML = 'DS Lobby ID: ' + e.data.lobbyid;
		document.getElementsByTagName('p4')[0].innerHTML = 'DS now:      ' + e.data.now; 
		document.getElementsByTagName('p5')[0].innerHTML = 'used API type:	' + APIMODE;
		//call worker again for next itteration -> currently endless loop
		workerDSDATA.postMessage({
						workerdelay: 	100
						,dsurl:		DsServerURL
						,dsport:	DsPort
						,timeout:	XMLHTTPTimeout
						,receivemode:	"GETDSDATA"});
        }, false);
	//initail call of the worker
	workerDSDATA.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: XMLHTTPTimeout, receivemode: "GETDSDATA"});


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// receive data from pcars dedicated server (DS) and returns an array of PCARSdriver objects
	//	   Receive_DS_data(url,port,timeout,RetrivelMode)
	// initial call for map initialization
	if (APIMODE == "DS"){
		aDrivers = Receive_DS_data(DsServerURL, DsPort, 2000, "GETDRIVERDATE");
	}else{
		aDrivers = Receive_DS_data(CRESTServerURL, CRESTPort, 2000, "GETCRESTDRIVERDATA");
	}

        for (var i = 0; i < aDrivers.length; i++ ){

                        // calculate GPS coordinates
			console.log("-------- aDrivers" , aDrivers);
                        gpsCoTmp =  calc_coordinates (cuircitID , aDrivers[i].GetPosX() , aDrivers[i].GetPosZ() );

                        // fill data array
                        aSensorData[i] = {
                                        "Key": aDrivers[i].GetName()
                                        ,"MarkerLabel" : aDrivers[i].GetRacePosition() + "-" + aDrivers[i].GetName()
                                        ,"DateTime":"2013-09-04T09:41:09+10:00"
                                        ,"Lat": gpsCoTmp["Lat"]
                                        ,"Long": gpsCoTmp["Long"]
                                        ,"Heading":286.0
                                        ,"Speed":22
                                        }
			// bookmark current TrackID to detect track changes and adjust Map
                        tmpcuircitID = aDrivers[i].GetVariousParameter("TrackId");
        }

	// init google map
        init_map(cuircitID);

	// create Table with list of all tracks
	// checkbox Event handling
	$('#cbTracklistRefresh').click(function () {

		if ($('#cbTracklistRefresh').is(':checked') == true) {
			StopRefreshTracklist 	= "true";
			WORKERDELEAY_TRACKLIST 	= 10000;
		}else{
			StopRefreshTracklist 	= "false";
			WORKERDELEAY_TRACKLIST	= 5000;
		}
	})


	// create worker for Tracklist updates //////////////////////////////////////////////////////////////////////
	var w_tracklist      =       new Worker('./worker_tracklist.js');
	
	w_tracklist.addEventListener('message', function(e) {

					console.log("Worker Trackliste Event: ", e );
//					console.log("Worker Trackliste Event: JSON PARSE ", JSON.parse(e.data) );
					
					var str = e.data;	// data string from return object

//					var strtmp = str.replace("null", " ");	// workaround for FireFox; convert [null] -> []

//					refreshTrackList( buildTracklist(JSON.parse(strtmp)) );
					refreshTrackList(buildTracklist(e.data));
					w_tracklist.postMessage({
								workerdelay: 	WORKERDELEAY_TRACKLIST
								,dsurl: 	DsServerURL
								,dsport: 	DsPort
								,timeout: 	2000
								,receivemode: 	"GETTRACKLIST" });
        }, false);
	
	//initial call of the tracklist worker. initiate endless loop
	w_tracklist.postMessage({workerdelay: 100, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETTRACKLIST" });

	// initiate jqGrid
	// todo: make table searchable   and  add new Theme
	// todo: add subgrid information like: Long,Lat,RefPoint,...
	jQuery("#tracklisttable").jqGrid({	
	        datatype: "local",
	        height: 250,
	        hiddengrid: true,
	        colNames:['ID','TrackID','TrackName', 'RefPoints exists?','Comment'],
	        colModel:[
			{name:'id', index:'id', formatter: 'integer', width:100},
	                {name:'trackid', index:'trackid', width:100},
	                {name:'trackname', index: 'trackname', width:200},
	                {name:'refpoint', width:90, align:"right",sorttype:"float"},
			{name:'comment', width:160, align:"left"},
	        ],
	        caption: "List of available Tracks",
		rowNum: 200,
	});

	// initial data for grid !!! Needed because of Refresh problem !!
	// todo: really needed ?
	jQuery("#tracklisttable").jqGrid('addRowData',0,{	id: 0
								,trackid:	"1" 
								,trackname: 	"initialdata"
								,refpoint:	"no"
								,comment:	"" 
							});


	// create worker for Driver data updates //////////////////////////////////////////////////////////////////////
	var workerDRIVERDATA      =       new Worker('./worker_driverdata.js');
	workerDRIVERDATA.addEventListener('message', function(e) {
		
                console.log('Worker3 DriverList and  said: ', e.data);
		// refresh table of Driver data
                refreshDriverList(e);

		//todo var declaration needed within loop ???
		var tmpcuircitID;

		//update map
		for (var i = 0; i < e.data.length; i++ ){

                        // calculate GPS coordinates
                        gpsCoTmp =  calc_coordinates (cuircitID , e.data[i].PosX , e.data[i].PosZ );

                        // fill data array
                        aSensorData[i] = {
                                        "Key": e.data[i].Name
                                        ,"MarkerLabel" : e.data[i].RacePosition + "-" + e.data[i].Name
                                        ,"DateTime":"2013-09-04T09:41:09+10:00"
                                        ,"Lat": gpsCoTmp["Lat"]
                                        ,"Long": gpsCoTmp["Long"]
                                        ,"Heading":286.0
                                        ,"Speed":22
                                        }
                        tmpcuircitID = e.data[i].variousParameters.TrackId;
                }

		//console.log("++++++++ aSensorData_NEW" , aSensorData);
		sensorLayer.update(aSensorData);

                //todo: Move map dynamically if cuircit changes to a new GPS coordinate
		console.log("+++++++++++++++++++++++++++" , aRefPointTMP);
		//console.log("+++++++++++++++++++++++++++ (tmpcuircitID)" , tmpcuircitID);
                //console.log("+++++++++++++++++++++++++++ (aRefPointTMP[tmpcuircitID]" , aRefPointTMP[tmpcuircitID]);
                if ( (cuircitID != tmpcuircitID) && (tmpcuircitID == 'defined') ){
                        //map.setCenter({lat: 50.332733, lng: 6.943355});
                        map.setCenter({lat: aRefPointTMP[tmpcuircitID]["MapInitLat"], lng: aRefPointTMP[tmpcuircitID]["MapInitLong"]});
                        cuircitID = tmpcuircitID;  // give the global var the new TrackId
                        console.log("TrackID changed. Call map.SetCenter(),  cuircitID / tmpcuircitID " + cuircitID + " / " + tmpcuircitID);
                }

		// start next run of this loop
		if (APIMODE == "DS"){
			workerDRIVERDATA.postMessage({  workerdelay: WORKERDELEAY_DRIVERLIST
                                                ,dsurl: DsServerURL
                                                ,dsport: DsPort
                                                ,timeout: 2000
                                                ,receivemode: "GETDRIVERDATE" });
		}else{
			workerDRIVERDATA.postMessage({  workerdelay: WORKERDELEAY_DRIVERLIST
                                                ,dsurl: CRESTServerURL
                                                ,dsport: CRESTPort
                                                ,timeout: 2000
                                                ,receivemode: "GETCRESTDRIVERDATA" });
		}

        }, false);
	
        //initial call of worker and start the loop
        if (APIMODE == "DS"){
        	workerDRIVERDATA.postMessage({workerdelay: 200, dsurl: DsServerURL, dsport: DsPort, timeout: 2000, receivemode: "GETDRIVERDATE" });
        }else{
        	workerDRIVERDATA.postMessage({workerdelay: 200, dsurl: CRESTServerURL, dsport: CRESTPort, timeout: 2000, receivemode: "GETCRESTDRIVERDATA" });	
        }
	//Todo: start a second worker loop with delay, to have continous updates on map
//	workerDRIVERDATA.postMessage({workerdelay: 3000, dsurl: "www.eckhchri.de", dsport: 9000, timeout: 2000, receivemode: "GETDRIVERDATE" });


	//todo: add subgrid for more drivers information
	jQuery("#DriverDataTable").jqGrid({
                datatype: "local",
                height: 200,
		width: 800,
		hiddengrid: true,
		caption: "List of available drivers",
                colNames:['RefID','Pos', 'Driver Name', 'State', 'Sector', 'fastest lap', 'last lap','PosX', 'PosY', 'PosZ' ],
                colModel:[
                        {name:'refid',index:'invdate', width:40},
			{name:'driverposition',index:'name', width:15, search:true},
                        {name:'drivername',index:'name', width:75, search:true},
			{name:'driverstate',width:40, align:"center",sorttype:"float"},
			{name:'driversector',width:10, align:"center",sorttype:"float"},
			{name:'fastestlap',width:20, align:"center",sorttype:"float"},
			{name:'lastlap',width:20, align:"center",sorttype:"float"},
			{name:'posx',width:20, align:"center",sorttype:"float"},
                        {name:'posy',width:20, align:"center",sorttype:"float"},
                        {name:'posz',width:20, align:"center",sorttype:"float"}
                ]
	});

	
	// checkbox Event handling
        $('#cbDriverlistRefresh').click(function () {

                if ($('#cbDriverlistRefresh').is(':checked') == true) {
                        StopRefreshDriverlist   = "true";
                        WORKERDELEAY_DRIVERLIST	= 3000;
                }else{
                        StopRefreshDriverlist  	= "false";
                        WORKERDELEAY_DRIVERLIST	= 200;
                }
        })

	
	// setting up google maps overlays
	function GPSSensor(initData) {
               //state information
               var _div = null;
               var _data = initData;
               var _projection = null;

               function transform(d) {
                   var padding = 10;                   
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this) 
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }
               
               function transformWithEase(d) {
                   var padding = 10;
                   d = new google.maps.LatLng(d.Lat, d.Long);
                   d = _projection.fromLatLngToDivPixel(d);
                   return d3.select(this)
                       .transition().duration(DisplayDuration)
                       .style("left", (d.x - padding) + "px")
                       .style("top", (d.y - padding) + "px");
               }

               //superclass methods for google maps
               this.onAdd = function() {
                   _div = d3.select(this.getPanes().overlayLayer)
                            .append("div")
                            .attr("class", "stations");
               };               
                              
               this.draw = function () {                   
                   var padding = 10;
                   _projection = this.getProjection();
		  
                   var marker = _div.selectAll("svg")
                       .data(_data, function (d) { return d.Key; })
                       .each(transform) // update existing markers
                        .enter().append("svg:svg")
                       .each(transform)
                       .attr("class", "marker");

		   console.log("++ Marker" , marker);

                   // Add a circle.
                   marker.append("svg:circle") 
                       .attr("r", 4.5)
                       .attr("cx", padding)
                       .attr("cy", padding)
		       .style("fill", "red");

		//todo experimental method call	
		//marker.text("test123456");	
		   console.log("Marker: " , marker);
		

                   // Add a label.
		   console.log ("++++ in function draw() ->  aSensorData: " , aSensorData);
                   marker.append("svg:text")
                       .attr("x", padding + 7)
                       .attr("y", padding)
                       .attr("dy", ".31em")
			//todo !!!!!!!!!!!!!!!!!!!!   very uggly implementation !!! only temporary workaround
			//      it seem that the function within .text(...) will called only once at the beginning 
			//      question: is it possible to call _div.selectAll("svg") and set text style direct in loop() ??
		       .text(function (d) {
						console.log("+++++ d:" , d);

						for (var i = 0; i < aSensorData.length; i++){
						
							console.log(" for Update MarkerLabel:" , aSensorData);
							if (aSensorData[i].Key == d.Key){
								console.log("Match found ---- Update MarkerLabel: " , aSensorData[i].MarkerLabel);
								return  aSensorData[i].MarkerLabel;
							}
						}
						
						//todo: during update d is not an array its an individual hash
						console.log("++++not array:");
						return d.MarkerLabel;
						
					})
               //       .text(function (d) { return d.Key; });                                      
               };

               this.onRemove = function () {
                   _div.remove();
               };


		// todo: known issue: Beim Wechsel der Position, bleibt eine "Leiche" auf der Karte uebrig, weil Key "Pos - Name" zusammensetzt
		// easyt solution:  deleting leading position number 
               this.update = function (data) {                    
                   //update internal data which drive redrawing on zoom_changed                  

                 	for (var i = 0; i < data.length; i++) {
			       //console.log ("------------------------------------------- data", data);
	                       var found = false;
	                       for (var j = 0; j < _data.length; j++) {
	                           if (_data[j].Key === data[i].Key) {
	        	                       found = true;
	                               _data[j].Lat = data[i].Lat;
	                               _data[j].Long = data[i].Long;
				       _data[j].MarkerLabel = data[i].MarkerLabel;
				//	console.log("---12 _data changes for key:" + _data[j].Key + " // " + data[i].Key);
	                           }
	                       }
	                       if (!found)
	                           _data.push(data[i]);
	                   }

			   //todo: what does this draw() call ?
			   console.log ("THIS Updated data:" , _data);
			   console.log ("THIS:" , this);
	                   this.draw();
	                   _div.selectAll("svg")
	                       .data(_data, function (d) { return d.Key; }) 
	                       .each(transformWithEase);                
			 
               };
           }


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////				
//////////////////////////////////////////////////////////////////////////
function init_map(_TrackID)
{
           //subclassing
           GPSSensor.prototype = new google.maps.OverlayView();


           // Create the Google Map
           map = new google.maps.Map(d3.select("#map").node(), {
               zoom: aRefPointTMP[cuircitID]["Zoom"],

                // use ´cuircit RefPoint for center google map
                center: new google.maps.LatLng( aRefPointTMP[_TrackID]["MapInitLat"] , aRefPointTMP[_TrackID]["MapInitLong"] ),
                mapTypeId: google.maps.MapTypeId.SATELLITE
           });

           //console.log("-+-+- aSensorData-Array: ", aSensorData);
           sensorLayer = new GPSSensor(aSensorData);
           sensorLayer.setMap(map);
}

///////////////////
function refreshTrackList(a)
{

	console.log("refreshTrackList(): " , a);
	// if set to true, no refresh of table wanted
	if (StopRefreshTracklist == "true")
	{
		console.log("--- INFO stop refresh tracklist because StopRefreshTracklist set to:", StopRefreshTracklist );
		return 1;
	}

	// clean complete table befor reloading new data to prevent ghost entries
        jQuery("#tracklisttable").jqGrid("clearGridData");

	var gridcnt = 0;
	var _data;

	a.forEach(function(entry){

		_data = {      id:             gridcnt
                               ,trackid:       entry.trackid
                               ,trackname:     entry.trackname
                               ,refpoint:      entry.refpoint
                               ,comment:       entry.comment
                        };

                
                jQuery("#tracklisttable").jqGrid('addRowData',gridcnt, _data);
               
		gridcnt++;
		
	});
	
	// relaod data into jqGrid
	jQuery("#tracklisttable").trigger("reloadGrid");
	
}
//////////////////
function refreshDriverList(a)
{
	// if set to true, no refresh of table wanted
        if (StopRefreshDriverlist == "true")
        {
                console.log("--- INFO stop refresh tracklist because StopRefreshDriverlist set to:", StopRefreshDriverlist );
                return 1;
        }

        console.log("refreshDriverList(e): " , a);
	var grididcnt = 0;
        var _data;

	// clean complete table befor reloading new data to prevent ghost entries
	jQuery("#DriverDataTable").jqGrid("clearGridData");	

        // get current size of the table
        var GridSize = jQuery("#DriverDataTable").getGridParam("reccount");	


	//todo: if drivertable is longer then new driverlist, all old values should be deleted
	//todo: if clearGridData method is working, no need for a decision if use setRowData or addRowData !
	console.log ("++++++++ length of data:" + a.data.length);
	for (i=0; i < a.data.length; i++)
        {
		console.log("update data on row: " + i + " / " + a.data);
                //console.log("update data on row: " + i + " / " + a.data[i]);
                _data = {   
				refid:			a.data[i].RefID
				,driverposition:	a.data[i].RacePosition	
				,drivername:		a.data[i].Name
	                        ,driverstate:		a.data[i].State
	                        ,driversector:		a.data[i].CurrentSector
	                        ,fastestlap:		PCARSd.GetFastestLapTime(  a.data[i].FastestLapTime )
	                        ,lastlap:		PCARSd.GetLastLapTime(  a.data[i].LastLapTime )
	                        ,posx:			a.data[i].PosX
	                        ,posy:			a.data[i].PosY
	                        ,posz:			a.data[i].PosZ
                        };
                //decision if replace or add a row to jqGrid
                if (i < GridSize)
                {
                        jQuery("#DriverDataTable").jqGrid('setRowData',i, _data);
                        //console.log("+++++ set " + i );
                }else{
                        jQuery("#DriverDataTable").jqGrid('addRowData',i, _data);
                        //console.log("+++++ add " + i );
                }
                grididcnt++;
        }
	//console.log("Driver table: ", _data);
        jQuery("#DriverDataTable").trigger("reloadGrid");
	return 1;
}
///////////////////
function buildTracklist( a ){

	aTrackList = a;
	console.log("-------------------------- Tracklist Worker return value:" , a);
	console.log("-------------------------- Tracklist2:" , aTrackList);

	var aRefPointTMP         =      new Refpoint();
        var k = 0;
        var rpexists = "no";
        var commenttmp = '';
        var tmpObj;
        var aNewTrackList = new Array();
        var LengthTracklist = 0;

        // Todo: undefined check is workaround for FireFox behaviour
        if ( Object.keys(aTrackList).length != 0 ){
                console.log("+++ use data from DS return value, because of empty array");
                // use data from DS return value
                for (var key in aTrackList ){

                        tmpObject = aRefPointTMP[key];
                        commenttmp = '';

                        if (aRefPointTMP[key]){rpexists="yes"}else{rpexists="no"};
                        // check if track is in local tracklist array and if comment field exists
                        if (key in aRefPointTMP){
                                if ( 'Comment' in tmpObject ) {
                                        commenttmp = tmpObject["Comment"];
                                };
                        };

                        aNewTrackList[k] = {    trackid:key
                                                ,trackname:aTrackList[key]
                                                ,refpoint:rpexists
                                                ,comment:commenttmp
                                            };

                        k++;
                }
        }else{
		console.log("+++ use data from RefPoint Array");
                // this case if no DS available, generate from RefPoint list
                for (var key in aRefPointTMP ){

                        tmpObject = aRefPointTMP[key];
                        // check if comment field exists in an array
                        commenttmp = '';
                        if ( 'Comment' in tmpObject ) {
                                        commenttmp = tmpObject["Comment"];
                        };

                        aNewTrackList[k] = {    trackid:key
                                                ,trackname:aRefPointTMP[key].Name
                                                ,refpoint:rpexists
                                                ,comment:commenttmp
                                            };
                        k++;
                }
        }

	return aNewTrackList;
}

function BuildTrackNameFromGameAPI(TrackLocation,TrackVariation)
{
        //combines the TrackName and TrackVariation from the Game API to one Name
        var TrackName;

        if (TrackVariation == ""){
                TrackName = TrackLocation; 
        }else{
                TrackName = TrackLocation + " " + TrackVariation;
        }
        
        return TrackName;
}

function GetTrackIDbyName(TrackName)
{
       //returns the TrackID for the Game API Name

        var TMP_TrackID = 9999999999;   //Default TrackID
        //aRefPointTMP must be known or alternatively defined new with var aRefPointTMP = new Refpoint();
        var TMP_Name;

        for (var key in aRefPointTMP){
                if(aRefPointTMP[key]["Name2"] == ""){
                        TMP_Name = aRefPointTMP[key]["Name"];
                }else{
                        TMP_Name = aRefPointTMP[key]["Name2"];
                }

                if (TMP_Name == TrackName){
                        TMP_TrackID = key;
                }
        }
        return TMP_TrackID;
}

       </script>
   </body>
